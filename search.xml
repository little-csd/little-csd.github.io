<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[csapp-Bomblab]]></title>
    <url>%2F2019%2F01%2F12%2Fcsapp-Bomblab%2F</url>
    <content type="text"><![CDATA[序 这是csapp系列的第二篇文章。具体的题目请见官网。另，本文均为自己手打，可能会有不少错误。如若发现有错误或者哪里写得不清楚，欢迎联系我修改。 这个lab从头到尾都是自己慢慢看过来的，花了很长的时间，也不知道算不算值得吧。个人见解：看反汇编代码是真的很花时间，对着几十行的代码有的时候看了几个小时还是懵的。这个时候还是换一下心情，做点别的事，可能突然就看懂了。但也不要看到代码多就直接放弃了吧，沉下心来看，还是可以看得懂的。 bomb lab实验要求 如同字面上的意思，这个实验要求我们拆一个“炸弹”。总共有六个关卡，需要保证每一个题目的输出结果都能满足某个特定的要求（答案不一定唯一），否则炸弹爆炸，游戏失败。 实验文件：bomb: 炸弹，打开后需要正确输入对应的字符串才能通关bomb.c: bomb的main函数所在的文件，提供给我们进行查看 实验目的：考察gdb的使用，以及reverse engneering的能力。需要学会使用gdb参考网站 さあ、私たちの実験を始めましょう。 首先，我们需要先使用objdump -d bomb &gt; bomb.txt这个命令，将bomb反编译，并保存在txt文件当中，方便我们查看。然后，不妨来看一下bomb.c的代码，方便我们对整个实验有一个整体的了解。 注意看一下注释，上面告诉了我们，可以将已解决的答案放入另一个txt文件当中，运行时用run &lt; answer.txt将其导入，可以不用重复打。然后我们看一下整体，总共有六个字符串，每一个字符串输入后，会判断是否正确，错误则发生爆炸，正确则继续输入。看完之后，就准备进入反编译得到的文件了。 bomb.txt 我们先整体看一下这个文件里面有什么。文件很长，总共有一千多行，不可能每一行都去解读。我们可以利用一些小技巧帮助我们理解。如main函数，我们可以看到它分成如下的几个部分。12345678910111213141516171819202122// 读取第一个字符串 400e32: e8 67 06 00 00 callq 40149e &lt;read_line&gt; 400e37: 48 89 c7 mov %rax,%rdi 400e3a: e8 a1 00 00 00 callq 400ee0 &lt;phase_1&gt; 400e3f: e8 80 07 00 00 callq 4015c4 &lt;phase_defused&gt; 400e44: bf a8 23 40 00 mov $0x4023a8,%edi 400e49: e8 c2 fc ff ff callq 400b10 &lt;puts@plt&gt;// 第二个 400e4e: e8 4b 06 00 00 callq 40149e &lt;read_line&gt; 400e53: 48 89 c7 mov %rax,%rdi 400e56: e8 a1 00 00 00 callq 400efc &lt;phase_2&gt; 400e5b: e8 64 07 00 00 callq 4015c4 &lt;phase_defused&gt; 400e60: bf ed 22 40 00 mov $0x4022ed,%edi 400e65: e8 a6 fc ff ff callq 400b10 &lt;puts@plt&gt;// 第三个 400e6a: e8 2f 06 00 00 callq 40149e &lt;read_line&gt; 400e6f: 48 89 c7 mov %rax,%rdi 400e72: e8 cc 00 00 00 callq 400f43 &lt;phase_3&gt; 400e77: e8 48 07 00 00 callq 4015c4 &lt;phase_defused&gt; 400e7c: bf 0b 23 40 00 mov $0x40230b,%edi 400e81: e8 8a fc ff ff callq 400b10 &lt;puts@plt&gt; ... 结合bomb.c，我们应该可以很容易理解main.c的反汇编代码了。接下来，我们再看下其他函数。 1.strings_not_equal函数。名字很明显告诉了我们，这个函数是判断两个字符串是否相等的。相等则返回0 2.explode_bomb函数，注意到，其中使用了exit函数。也就是说，这个函数一旦运行，就意味着游戏失败，直接exit退出。12345678000000000040143a &lt;explode_bomb&gt;: 40143a: 48 83 ec 08 sub $0x8,%rsp 40143e: bf a3 25 40 00 mov $0x4025a3,%edi 401443: e8 c8 f6 ff ff callq 400b10 &lt;puts@plt&gt; 401448: bf ac 25 40 00 mov $0x4025ac,%edi 40144d: e8 be f6 ff ff callq 400b10 &lt;puts@plt&gt; 401452: bf 08 00 00 00 mov $0x8,%edi 401457: e8 c4 f7 ff ff callq 400c20 &lt;exit@plt&gt; 3.read_line函数。由名字我们也可以知道，这个函数就是为了读取一行字符串。 4.read_six_numbers函数。由名字，我们知道，这个函数就是用来读六个数字。注意代码中用到了sscanf函数，用于从某一个字符串中格式化读取。其中%rdi存放的是待读取字符串，%rsi存储的是用于格式化的串，后面跟着的都是变量的地址。如sscanf(“7 0”, “%d %d”, &amp;a, &amp;b)，返回值为成功读取的变量个数。 5.phase_1 phase_2 … 用于判断输入的字符串是否满足要求 phase_11234567890000000000400ee0 &lt;phase_1&gt;: 400ee0: 48 83 ec 08 sub $0x8,%rsp 400ee4: be 00 24 40 00 mov $0x402400,%esi 400ee9: e8 4a 04 00 00 callq 401338 &lt;strings_not_equal&gt; // 直接判断与0x402400位置的字符串是否相同 400eee: 85 c0 test %eax,%eax 400ef0: 74 05 je 400ef7 &lt;phase_1+0x17&gt; 400ef2: e8 43 05 00 00 callq 40143a &lt;explode_bomb&gt; 400ef7: 48 83 c4 08 add $0x8,%rsp 400efb: c3 retq 题目很短，难度也很小，就是将读取的字符串直接与首地址为0x402400的字符串作比较，若相同则返回，否则引爆炸弹。因此，我们需要知道0x402400中究竟放着什么字符串。直接从反汇编代码中没办法看出来，这个时候就要用到强大的gdb了。需要用到x命令。语法为: x/&lt;n/f/u&gt; 其中，n是一个正整数，表示需要显示的内存单元的个数。每个内存单元的大小与u相关。u表示每个单元的大小。f表示输出的格式。较常用的如下。 x 按十六进制格式输出 d 按十进制格式输出 t 按二进制格式输出 c 按字符格式输出 如：x/10c 0x402400 将以字符形式输出从0x402400开始的十个字节 x/10xw 0x402400 将以字符形式输出从0x402400开始的十个单元，每个单元为4个字节 具体的使用自己试一试就知道了。我们直接查看内存后就发现，对应的字符串为： Border relations with Canada have never been better. 第一题结束。 phase_2 第二题，长度明显加长了一些。我们可以试着将其分段解读。至于从哪里开始分的话，尽量是选择jmp类的命令所在的行或者jmp命令跳转到的行，这种地方有可能是for循环，或者条件分支语句的结尾。就第二题来说，我们可以将其分成两个部分。第一个部分如下：123456400efe: 48 83 ec 28 sub $0x28,%rsp // 分配40kb的内存空间400f02: 48 89 e6 mov %rsp,%rsi400f05: e8 52 05 00 00 callq 40145c &lt;read_six_numbers&gt; // 将空间传给函数，读取六个数字400f0a: 83 3c 24 01 cmpl $0x1,(%rsp) // 判断第一个数字是否为1400f0e: 74 20 je 400f30 &lt;phase_2+0x34&gt; // 为1，跳开；否则，引爆炸弹400f10: e8 25 05 00 00 callq 40143a &lt;explode_bomb&gt; 第二个部分如下：12345678400f17: 8b 43 fc mov -0x4(%rbx),%eax400f1a: 01 c0 add %eax,%eax // 取出下一个数字，并*2400f1c: 39 03 cmp %eax,(%rbx) // 判断每一个数字是否为上一个数字的两倍400f1e: 74 05 je 400f25 &lt;phase_2+0x29&gt; // 是，跳开；不是，爆炸400f20: e8 15 05 00 00 callq 40143a &lt;explode_bomb&gt; // 循环体内部，依次判断输入是否正确400f25: 48 83 c3 04 add $0x4,%rbx400f29: 48 39 eb cmp %rbp,%rbx400f2c: 75 e9 jne 400f17 &lt;phase_2+0x1b&gt; 于是我们发现，整个程序对我们的要求有三个： 1.输入六个数字 2.第一个数字是1 3.第二个数字开始，每一个数字是前一个的两倍 由此，我们可以得到结果为：1， 2， 4， 8， 16， 32 phase_3 第三题，题目又变长了一些。在400f65之前，就是用sscanf读入两个数字。也就是说这次我们需要输入两个满足特定关系的数字。 再接下来的三行，程序判断输入的第一个数字是否大于小于等于7，否则爆炸。 接下来一行是重点了。1400f75: ff 24 c5 70 24 40 00 jmpq *0x402470(,%rax,8) 这个代码是什么意思呢？注意号的作用,该指令跳转的目标点是地址为0x402470+8%rax的内存单元。因此，我们需要打印出来0x402470+8i的值，对照代码后会发现，其实源代码应该就是一个switch函数。再看下接下来的几行代码，基本都是这样的格式：12400f7c: b8 cf 00 00 00 mov $0xcf,%eax400f81: eb 3b jmp 400fbe &lt;phase_3+0x7b&gt; 也就是说，根据你所输入的第一个数，你的第二个数需要对应这跳转目标点mov赋的值。为了简单起见，笔者直接打印0x402470，得到答案。12345678// b为我们输入的第一个数字，v为我们输入的第二个数字。int a;switch(b) &#123; case 0: a = ... case 1: a = ... case 2: a = ...&#125;if (a != v) explode_bomb(); phase_4 这道题看起来难度并不大。前面我们已经做了三道题了，基本上开始能够看懂一些复杂一点点的代码。phase_3函数应该也就不成问题了。首先输入两个数字，第二个数字必须为0，第一个数字将放入func4函数当中。也就是说，我们目的就是看懂func4这个函数在干什么。然后根据函数推断出我们需要输入的第一个数字即可。1234400fd6: 89 c1 mov %eax,%ecx400fd8: c1 e9 1f shr $0x1f,%ecx400fdb: 01 c8 add %ecx,%eax400fdd: d1 f8 sar %eax 首先，上面这个部分一开始让我迷惑了很久，这是要干嘛？？其中shr向右移动31位只有两个结果，当%ecx的值大于等于0时，得到结果为0，否则得到-1。因此这几行其实是当%eax的值小于0的时候就减去1。最后再向又移一位（缺省则位移一位）。 再接下来这段笔者看了特别久，最后是采用尝试着打出源代码才理解的。如果有跟我一样的看不太懂的，也不妨试试这个办法。12345678910111213141516400fdf: 8d 0c 30 lea (%rax,%rsi,1),%ecx 400fe2: 39 f9 cmp %edi,%ecx 400fe4: 7e 0c jle 400ff2 &lt;func4+0x24&gt; 400fe6: 8d 51 ff lea -0x1(%rcx),%edx 400fe9: e8 e0 ff ff ff callq 400fce &lt;func4&gt; 400fee: 01 c0 add %eax,%eax 400ff0: eb 15 jmp 401007 &lt;func4+0x39&gt; 400ff2: b8 00 00 00 00 mov $0x0,%eax 400ff7: 39 f9 cmp %edi,%ecx 400ff9: 7d 0c jge 401007 &lt;func4+0x39&gt; 400ffb: 8d 71 01 lea 0x1(%rcx),%esi 400ffe: e8 cb ff ff ff callq 400fce &lt;func4&gt; 401003: 8d 44 00 01 lea 0x1(%rax,%rax,1),%eax 如上，将其通过跳转指令划分为4个部分。然后我们发现它调用了自己，也就是说这是一个递归函数。注意到phase_4调用它之前放入了3个参数。我们可以尝试着打出源代码。1234567891011// a为我们输入的数，b初始为0，c初始值为15。我们需要返回的值是0。因此，只需要让一开始tt就等于a即可void func4(int a, int b, int c)&#123; int t = c-b; if(t&lt;0) t--; t&gt;&gt;=1; int tt=t+b; if(tt&gt;a) c=tt-1; return 2*func4(a,b,c); else if (tt==a) return 0; else return 2*func4(a,tt+1,c)+1;&#125; phase_5 这道题长度又一次增加了，不过好在难度还不算太大。其实能做完第四题的话做第五题问题应该是不大的。和之前一样。我们先尝试着将整个代码拆分成几个部分。 首先，要求我们输入的应该是一个字符串，且长度必须为6。接下来的几行是一个循环，我们先跳过。先看最后面的几行代码。12344010ae: c6 44 24 16 00 movb $0x0,0x16(%rsp)4010b3: be 5e 24 40 00 mov $0x40245e,%esi4010b8: 48 8d 7c 24 10 lea 0x10(%rsp),%rdi4010bd: e8 76 02 00 00 callq 401338 &lt;strings_not_equal&gt; 上面几行将栈上面位于%rsp+10～%rsp+15的字符串与首地址为0x40245e的字符串相比较，打印地址后我们看到，字符串为flyers，也就是说我们的输入经过变换之后要变成flyers这个字符串。这个时候我们再回去看一下循环体内部是怎样做变换的。12345678940108b: 0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx40108f: 88 0c 24 mov %cl,(%rsp)401092: 48 8b 14 24 mov (%rsp),%rdx401096: 83 e2 0f and $0xf,%edx401099: 0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx4010a0: 88 54 04 10 mov %dl,0x10(%rsp,%rax,1)4010a4: 48 83 c0 01 add $0x1,%rax4010a8: 48 83 f8 06 cmp $0x6,%rax4010ac: 75 dd jne 40108b &lt;phase_5+0x29&gt; 注意到这一段代码，一次取出每一个字符。并将其与0xf相与，也就是说我们取出后四位的值c，再加上0x4024b0得到一个值v，再取出内存地址为v的值，放入栈当中。这样说可能有点难理解。我们来举一个例子。比如第一个字符串处理之后要变成’f’，查询ASCII得，相当与102，也就是0x66, 再查看一下内存，看到‘f’位于0x4024b9。因此我们需要的c的值为9，为了方便，我第一个字符输入的是i(0x69),和0xf相与之后恰好为9，满足要求。后面的同理，不再赘述。由此，本题成功解决了。 phase_6 这道题可以说是有点丧心病狂了。难度和之前感觉完全不在一个档次上。不过毕竟是压轴题，也可以理解。同样的，我们先将代码拆分成几个小部分。 首先，题目读取了六个数字。然后需要对这六个数字做出相当长的处理。下面的这一段应该是目前为止最难理解的一个点。如果无法理解，还请多看几遍。12345678910111213141516171819202122232425// 下面为一个嵌套循环，终止条件为r12 == 6 目的为检测是否所有字符均不相等以及小于等于6// %eax = a[i] (%r13)// %rbp = &amp;a[i]401114: 4c 89 ed mov %r13,%rbp401117: 41 8b 45 00 mov (%r13),%eax40111b: 83 e8 01 sub $0x1,%eax40111e: 83 f8 05 cmp $0x5,%eax401121: 76 05 jbe 401128 &lt;phase_6+0x34&gt; // a[i] &gt; 6 爆炸401123: e8 12 03 00 00 callq 40143a &lt;explode_bomb&gt;401128: 41 83 c4 01 add $0x1,%r12d40112c: 41 83 fc 06 cmp $0x6,%r12d401130: 74 21 je 401153 &lt;phase_6+0x5f&gt; // %r12 == 6 退出循环// 第二层循环401132: 44 89 e3 mov %r12d,%ebx401135: 48 63 c3 movslq %ebx,%rax401138: 8b 04 84 mov (%rsp,%rax,4),%eax40113b: 39 45 00 cmp %eax,0x0(%rbp)40113e: 75 05 jne 401145 &lt;phase_6+0x51&gt; // a[i] != a[i+j] 否则爆炸401140: e8 f5 02 00 00 callq 40143a &lt;explode_bomb&gt;401145: 83 c3 01 add $0x1,%ebx401148: 83 fb 05 cmp $0x5,%ebx40114b: 7e e8 jle 401135 &lt;phase_6+0x41&gt;// 第二层循环外40114d: 49 83 c5 04 add $0x4,%r13401151: eb c1 jmp 401114 &lt;phase_6+0x20&gt; 接下来的部分就比较好理解了。最终对整个程序的影响是将每一个值a[i]转化为7-a[i]。123456789401153: 48 8d 74 24 18 lea 0x18(%rsp),%rsi401158: 4c 89 f0 mov %r14,%rax40115b: b9 07 00 00 00 mov $0x7,%ecx401160: 89 ca mov %ecx,%edx401162: 2b 10 sub (%rax),%edx401164: 89 10 mov %edx,(%rax) // a[i] = 7 - a[i]401166: 48 83 c0 04 add $0x4,%rax40116a: 48 39 f0 cmp %rsi,%rax40116d: 75 f1 jne 401160 &lt;phase_6+0x6c&gt; 再接下来这一段就比较麻烦了。和之前一样，我采用了尝试这打出源代码的方法进行理解。由于接下来的两段代码经常要访问内存，为了方便理解，我将内存代码打出来，欢迎查阅。 address address + 4 address + 8 address + 12 0x6032d0 0x0000014c 0x00000001 0x006032e0 0x00000000 0x6032e0 0x000000a8 0x00000002 0x006032f0 0x00000000 0x6032f0 0x0000039c 0x00000003 0x00603300 0x00000000 0x603300 0x000002b3 0x00000004 0x00603300 0x00000000 0x603310 0x000001dd 0x00000005 0x00603320 0x00000000 0x603320 0x000001bb 0x00000006 0x00000000 0x00000000 12345678910111213141516401176: 48 8b 52 08 mov 0x8(%rdx),%rdx40117a: 83 c0 01 add $0x1,%eax40117d: 39 c8 cmp %ecx,%eax40117f: 75 f5 jne 401176 &lt;phase_6+0x82&gt;401181: eb 05 jmp 401188 &lt;phase_6+0x94&gt;401183: ba d0 32 60 00 mov $0x6032d0,%edx401188: 48 89 54 74 20 mov %rdx,0x20(%rsp,%rsi,2)40118d: 48 83 c6 04 add $0x4,%rsi401191: 48 83 fe 18 cmp $0x18,%rsi401195: 74 14 je 4011ab &lt;phase_6+0xb7&gt;401197: 8b 0c 34 mov (%rsp,%rsi,1),%ecx40119a: 83 f9 01 cmp $0x1,%ecx40119d: 7e e4 jle 401183 &lt;phase_6+0x8f&gt;40119f: b8 01 00 00 00 mov $0x1,%eax4011a4: ba d0 32 60 00 mov $0x6032d0,%edx4011a9: eb cb jmp 401176 &lt;phase_6+0x82&gt; 123456789101112 // %rsi : 4 * i // %eax : 用于和a[i]做比较 // %ecx : a[i]for (int i = 0; i &lt; 6; i++)&#123; if (a[i]&lt;=1) &#123; M[%rsp + 8 * i + 32] = 0x6032d0; &#125; else &#123; // 经查看内存可得 M[%rsp + 8 * i + 32] = 0x6032d0 + 16 * (a[i]-1); &#125;&#125; 关于上面的这段函数，我们可以理解为它在构造一个结构体Node(注意，指针为64位，且为小端)，其中Node的成员如下：12345Node &#123; int value; int id; Node* next;&#125; 倘若我们这样看，会发现整个代码容易理解了很多，结合具体内存中的值，我们发现，下面的这一段其实就是将各个结构体元素连接起来，形成一个链表。1234567891011124011ab: 48 8b 5c 24 20 mov 0x20(%rsp),%rbx4011b0: 48 8d 44 24 28 lea 0x28(%rsp),%rax4011b5: 48 8d 74 24 50 lea 0x50(%rsp),%rsi4011ba: 48 89 d9 mov %rbx,%rcx4011bd: 48 8b 10 mov (%rax),%rdx4011c0: 48 89 51 08 mov %rdx,0x8(%rcx)4011c4: 48 83 c0 08 add $0x8,%rax4011c8: 48 39 f0 cmp %rsi,%rax4011cb: 74 05 je 4011d2 &lt;phase_6+0xde&gt;4011cd: 48 89 d1 mov %rdx,%rcx4011d0: eb eb jmp 4011bd &lt;phase_6+0xc9&gt;4011d2: 48 c7 42 08 00 00 00 movq $0x0,0x8(%rdx) 最后这一段其实就好理解很多了。其实就是从前往后遍历链表，然后检查下一个结构体元素的value是否大于上一个的，否则爆炸。再看一下前面的内存值。我们就可以得到满足每一个元素value均大于上一个的链表的顺序了：2，1，6，5，4，3。当然要是你信心满满直接把这个顺序输入进去的话（像我一样），你会发现，炸弹还是爆炸了。别忘了，前面有一个操作将a[i]变成了7-a[i]，因此，我们应该再处理一下，得到最终的正确答案为：5，6，1，2，3，4 Congratulations! You’ve defused the bomb.1234567894011da: bd 05 00 00 00 mov $0x5,%ebp4011df: 48 8b 43 08 mov 0x8(%rbx),%rax4011e3: 8b 00 mov (%rax),%eax4011e5: 39 03 cmp %eax,(%rbx)4011e7: 7d 05 jge 4011ee &lt;phase_6+0xfa&gt;4011e9: e8 4c 02 00 00 callq 40143a &lt;explode_bomb&gt;4011ee: 48 8b 5b 08 mov 0x8(%rbx),%rbx4011f2: 83 ed 01 sub $0x1,%ebp4011f5: 75 e8 jne 4011df &lt;phase_6+0xeb&gt; secret_phase 然而，真的通关了吗？ 细心的同学可能会发现（我也发现啦！），在bomb.c中有着这样一段注释： /Wow, they got it! But isn’t something… missing? Perhaps something they overlooked? Mua ha ha ha ha! 从这句话，我们可以猜出，作者果然还是有阴谋的。于是我们再重新回去看了一下，发现了一个神奇的函数，叫secret_phase，果然有问题。crtf+f查找，发现这是在phase_defused中调用的，而且再看一下它调用的相关代码：12344015d1: 48 89 44 24 68 mov %rax,0x68(%rsp)4015d6: 31 c0 xor %eax,%eax4015d8: 83 3d 81 21 20 00 06 cmpl $0x6,0x202181(%rip) # 603760 &lt;num_input_strings&gt;4015df: 75 5e jne 40163f &lt;phase_defused+0x7b&gt; 我们发现，只有当前6个炸弹全部拆除后才可以调用。这不明摆着是彩蛋了吗。接下来一大坨代码就是看你能不能顺利揭开彩蛋了。 接下来，再看下这坨代码：12345678910111213144015e1: 4c 8d 44 24 10 lea 0x10(%rsp),%r84015e6: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx4015eb: 48 8d 54 24 08 lea 0x8(%rsp),%rdx4015f0: be 19 26 40 00 mov $0x402619,%esi4015f5: bf 70 38 60 00 mov $0x603870,%edi4015fa: e8 f1 f5 ff ff callq 400bf0 &lt;__isoc99_sscanf@plt&gt; // 读取两个整数和一个字符串4015ff: 83 f8 03 cmp $0x3,%eax401602: 75 31 jne 401635 &lt;phase_defused+0x71&gt; // 没有读取到三个，原地爆炸401604: be 22 26 40 00 mov $0x402622,%esi401609: 48 8d 7c 24 10 lea 0x10(%rsp),%rdi40160e: e8 25 fd ff ff callq 401338 &lt;strings_not_equal&gt; // 将读取的字符串与0x402622为首地址的字符串作比较401613: 85 c0 test %eax,%eax401615: 75 1e jne 401635 &lt;phase_defused+0x71&gt; // 字符串和给定的不相同，还是爆炸 恩，好吧，从一个给定的串中读取一些东西，打印0x402619后面的几个字符，我们发现结果是“%d %d %s”，读取两个整数和一个字符串。可事情并没有这么简单。我们尝试打印一下0x603870，发现字符串就只有“7 0”，不可能读3个数字。那我们怎么玩？？ 看来我们只好作弊了。使用gdb直接用print指令更改内存的值，将“7 0”后面补一点东西，补什么呢？那当然是0x402622上面的东西了。打印一下，发现是“DrEvil”，好吧满满的恶意。补上之后（可以用类似 p {int}0x603873=’D’ 这样的指令为内存单元赋值），就顺利进入了secret_phase函数了。 再看一下这个函数干了些什么。恩，读取了一个字符串，再用strtol函数将其转化为数字，也就是说，我们目的就是输入一个满足要求的数字。然后，又与2进行比较，也就是说，我们目的是要运行fun7函数，并且得到答案为2的返回值。 接下来我们看一下fun7函数。主体大概是这样子的。可以看出，这是一个递归。其中的v为我们输入的那个值。1234567if (x &lt;= v) &#123; return 2 * fun7(...);&#125;else if (x == v) return 0;else &#123; return 2 * fun7(...)+1;&#125; 好了，我们发现代码中有0x8(%rdi),%rdi这样的指令，接下来又要打印内存信息了。注意到一开始传入的值为0x6030f0,故我们打印一下0x6030f8和0x603100的值，发现答案为0x603110和0x603130,又是两个地址。并且，打印0x6030f0,0x603100,0x603110我们发现，结果都是一个比较小的值，不难猜测，这应该是一个二叉树。于是，按照这个规律，我们可以将整棵树打印出来.（其中各个框内表示的是该点的地址） 0x6030f00x6031100x6031300x6031900x6031500x6031700x6031b00x6031f00x6032500x6032700x6032300x6031d00x6032900x6032100x6032b0 接着，再倒推，2 = 2 * 1, 1 = 2 * 0 + 1 . 则应该选择地址为0x603150的点，打印得到，答案为22，结束。]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>overflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[summary-2018]]></title>
    <url>%2F2019%2F01%2F01%2Fsummary-2018%2F</url>
    <content type="text"><![CDATA[2018年的一个小总结： 首先，其实不知道应该说什么比较好，整个2018年的话，应该还是算过得去吧。不知道该写什么，就还是按照时间的顺序写一下一些对我影响比较大的事情吧。 年初 记得2018年刚开始的时候，感慨还是挺深的，毕竟处在高三的中期，各个科目也基本都开始了总复习，心情还是略有些紧张的。尽管对很多事情都不确定，但还是硬着头皮往前走，当时基本上就一个目标，把高考考好。那段时间也算是挺努力的了，寒假也没玩什么游戏，基本上花了挺多时间来学习。 四五月份 这段时间就算是出生以来最难熬的一段时期了。天气十分的炎热，坐在教室里也几乎静不下心来学习。整个人的状态很乱。每天基本上就是刷题，除了题目还是题目，整个人真的十分的疲惫，但也没有任何办法，只能继续坚持下去。也许，那段时间也算是大学之前一段十分快乐的时光吧， 毕竟全班的同学一起向着同一个目标努力，这种机会以后基本上也都不会再有了。 六月七号 八号 每一年的这两天我想对全国的几百万考生来说都是及其难忘的。即便现在已经过了半年，那个时候自己的状态，心情，甚至在什么时间干了什么事，至今都记忆犹新。还有印象六月七号的那个晚上，下课时分，和另一个同学一起，在教室里谈论着未来。将来会发生什么事呢？考试要是砸了会怎么样呢？恩，基本上整个人都在那样的状态下，坐立不安。 到了六月八号下午，也许那是在那段时间心态最平和的时候了，什么也没说，什么也没想。考完恍若隔世，也是吧，毕竟十几年的读书最终换来的，最主要的也便是那一张写着成绩的白纸罢了。和父母一起，走在学校的街道上，心情说不上好，说不上坏。考完了，理论上来说应该是要比较开心的，可是在这种场合下却也怎么都开心不起来。是的，一个强烈的直觉告诉我：这次考试考得并不好，或者说很差。 接下来的一段时间里，基本上还是尽量让自己不要再去回忆考试的事情了。考得好坏都已经注定，再去想确实也没有任何意义。那段时间和母亲一起去珠海找我哥，又去普宁了一个同学家玩，接下来就是毕业典礼，然后就是揭晓成绩的时刻。 成绩揭晓 恩，看到成绩出来的那一刻，就像高考完铃声响起的刹那，脑子是空白的，不知该说些什么。然后就是不敢相信自己–我拿到了自己几乎未曾想过的分数，甚至都不敢去再看它一眼。还有印象，那个中午我啥也没吃，就躺在床上发呆，想想自己今后的路该怎么走。是要复读吗？不，绝对不行，我没有勇气去再面对一次高三。就这样吧，差一点就差一点吧，毕竟考试总有人会考得不好的，为什么不能偏偏是我呢？基本上，其实经过了一两天的缓和，也就没有再去想那么多了。尽管现在再次提起还是有些难过的，但也没办法吧。 后面到八月初，就又是一段算是十分快乐的时光了。加入了本地的一个补习社，和几个小伙伴们一起，备课，讲课，每天基本上都是在这样的重复中度过。最多的时候一天能有8节课，常常不得已要利用睡觉的时间来备课。那段时间觉得很累，但是却很舒坦。这里放一张照片纪念一下。 Before enter University 在忙完了辅导社之后，接下来的时间基本上都是在做一些提前的学习了。毕竟想要在大学考得好，还是需要提前下一番功夫，起码在这一点，要比别人赢在起跑线上，真的不愿意再一次输了。也就是在那段时间，认识了吴晓杰师兄和陈钊燚师兄，也是在他们的帮助下，对大学有了一点了解，也算是更加了解了一下自己究竟想要一些什么。然后就是在不断的学习了。 很奇怪，也许是高考考得不好，也许是因为一些其他什么事情，自从那段时间以来，心里最大的目标就只剩学习（其实还有看番hhh）了。可能是心里那一股不服输的劲吧，以及对自己越来越高的要求，总是不断地告诉自己，必须比别人多付出更多的时间，一定要学得更多，更好。也是从那段时间开始，基本上就已经不再碰任何游戏了，社团也不想参加，变成了一个真真正正的“宅”了。也许这确实有些不好吧。 Enter UniqueStudio 经过了开学以来的努力学习，以及一点运气，最后终于挺过了数轮面试，进入到了联创团队（uniquestudio）当中。还是很高兴能成为团队的一员的，至少说明了，自己的努力真的还是有回报的。然后再接下来，到年底的时间里面，基本上大部分的课余时间都留给了团队了。平均每周四五十小时以上的学习时间，一周又一周地过去。 刚开始进来的那段时间，也许是最艰难的。很多东西都完全不会，android studio的各种配置什么的问题可以卡好几天。在第一个任务的时候，还啥都不会，所有东西都是边学边做，一个小功能要重复改来改去弄好多遍，往往弄很多遍之后还是不太好，弄到自己也是很烦躁。所以第一个任务做得很差。到了第二个任务的时候，慢慢地开始注意了一些设计模式方面的问题，不会太盲目地想往哪里加功能就往哪里加，不过也是由于经验太少，反复踩了很多坑。好在最后终于算是基本完成了要求了，尽管花的时间比预计的要多一些。基本上对很多东西的了解又加深了一些。 再后面已经接近年末了，第二期任务做完一段时间过后，搭建了自己的第一个博客，也就是这里。也开始尝试这把自己的一些想法记录下来吧。然后也下决心开始看CSAPP这一本书了。说实话，这本书确实很多东西讲得很好（尽管我现在看的还很少），基本上能把我想要知道的东西都讲了，不过语言还是令人很难受的一个坎，毕竟从初中开始英语就不怎么样。好在还有翻译这种神奇的东西，基本上靠半蒙半查加上一点直觉，慢慢地让自己能够静下心来看这本书了，也算是自己的一个进步了吧。 然后就基本上到了年末了，也就是前几天了。慢慢开始减少了一些花在这方面的时间了，稍微把时间分配给了一下课内的一些知识，毕竟说到底，到现在我都没办法确定自己究竟想要读研究生还是直接出来工作，毕竟大一上学期还是不要太早下论断的好吧。还是得看一下这学期末的成绩吧，如果能够考得比较好，将来有希望能保研去清北复交或者浙大中科大之类的，那还是有可能争取一下的。这个寒假应该就需要结合自己的成绩想清楚了吧。 expection 其实感觉这东西很说不准。毕竟现在真的还没办法未来要做什么。但近期的一些flag还是可以立一下的。尽量在寒假把CSAPP多看一点吧，最好能看完70%以上吧，以及最好多做几个实验，也算是巩固一下自己看书学到的一些知识。然后下学期开始后尽量快点把这本书看完，接着花几个星期的时间把开发艺术探索，源码设计模式等补了，有时间的话看一下争取在大一下学期结束之前把计网和现代操作系统看了吧。基本上大一能把这几本书看完就已经很不错了。 然后如果将来要走偏图形这一块的话，那可能需要稍微为这方面做一点准备了。以及线代一定要学好。如果将来选择争取保研的话，那可能要找一些数学方面的更深入的书籍学习一下，物理可能也需要花一些时间。毕竟理工科无论如何这两个科目一定不能差吧。 然后如果将来选择放弃保研，毕业后就直接出来工作的话，那可能会在大一的暑假看一下linux内核的一些东西或者是Android底层的源码，起码要比现在再深入一些吧。 Summary 最后还是再罗嗦一下吧。总的来说，2018年对我自己来说确实可以称得上是转折性的一年。这一年里发生了太多值得我去回忆的事情。我也很庆幸，自己能够变成现在这个样子，尽管它未必很好。很开心，现在身边能有很多优秀的同学值得我去学习，未来的路子还长，还需要一步一个脚印继续慢慢往前走去。 结尾还是要放点啥，就留下我特别喜欢的一段话吧： 人の人生は、自分の墓へ走る汽车に乗っているようだ。途中は沢山駅があるけど、ずっと最後まで侧にいってくれる人はいない。だから、いってくれた人が降りる前に、いくらさびしくても、感谢の気持ちでさよならと言おう。]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[csapp-Datalab]]></title>
    <url>%2F2018%2F12%2F25%2Fcsapp-Datalab%2F</url>
    <content type="text"><![CDATA[序 这是csapp系列的第一篇文章。本文主要讲一下关于 datalab [Updated 11/2/18] 的解决方法以及简单的思路。如果有哪里写的不清楚或者有问题，欢迎联系我修改。 注：其中某些题目应该有更优的解法。以下仅供参考 bitXor题意：用 ~ 和 &amp; 运算符实现 Xor 运算符思路：我们知道Xor运算符是对每一个位，相同的话返回0，不同的话返回1。题目中仅有 &amp; 是双目运算符，那么我们可以采用 &amp; 运算符获得均为1的位，再取反，同理，用 &amp; 和 ~ 获得均为 0 的位，再取反，最后两者再进行 &amp; ，即可得到答案。解：123int bitXor(int x, int y) &#123; return ~(x&amp;y)&amp;~(~x&amp;~y);&#125; tmin题意：让你输出反码下的最小值思路：水题。。直接由定义得。解：123int tmin(void) &#123; return 1&lt;&lt;31;&#125; isTmax题意：判断一个数是否为反码下的最大值思路：若x为Tmax，x+1取反之后应该等于x。故可以采用取反与原数Xor的思路。但要注意，0xffffffff也满足该性质，需要排除。解：123int isTmax(int x) &#123; return !(~(x+1)^x)&amp;!(!(~x));&#125; allOddBits题意：判断一个数是否所有的奇数位都为1。(位的序号从0到32)思路：我们知道，若奇数位为均为1，则右移一位后偶数位均为1，两者相与的话为0xffffffff。利用该性质可得到答案。不过要注意，偶数位上的1会影响我们的判断，故需要利用掩码将其过滤。(0xA = 1010)解：1234int allOddBits(int x) &#123; x = x &amp; 0xAAAAAAAA; return !(~(x|(x&gt;&gt;1)));&#125; negate题意：求一个数的相反数。思路：水题，由常用结论我们知道，-x = ~x + 1解：123int negate(int x) &#123; return ~x+1;&#125; isAsciiDight题意：判断一个数字是否在(0x30和0x39)之间思路：这道题我想不出比较好的解法。只能暴力判断。即先看2进制下的前26六位是否有值，然后在看下后6位。x+6仍然小于0x40，则x小于0x3。.再看下剩下六位中前两位是否均为1，是的话x大于0x30。解：12345int isAsciiDigit(int x) &#123; int t = x &amp; 0xFFFFFFC0; x = x &amp; 0x3F; return !t&amp;!((x+6)&amp;0x40)&amp;(x&gt;&gt;4)&amp;(x&gt;&gt;5)&amp;1;&#125; conditional题意：实现三目运算符 ？：思路：先用！判断是否为x是否为真。然后在利用与的性质：一个数和0xffffffff相与结果为其本身，和0相与结果为0。解：1234int conditional(int x, int y, int z) &#123; x = !x; return y&amp;(~(!x)+1) | z&amp;(~x+1);&#125; isLessOrEqual题意：判断x是否小于等于y思路：x&lt;=y 则 y - x &gt;= 0。分别取出x和y的符号，进行判断。若y大于0，x小于0，则显然为真。若y小于0，x大于0，则显然为假。剩下的异号的情况则用y + (-x) 判断即可。解：12345int isLessOrEqual(int x, int y) &#123; int sgnx = (x&gt;&gt;31)&amp;1; int sgny = (y&gt;&gt;31)&amp;1; return !sgny &amp; sgnx | !(sgnx^sgny) &amp; !((y + (~x+1))&amp;(1&lt;&lt;31));&#125; logicalNeg题意：使用其他的逻辑运算符和位运算符实现 ！运算符思路：我们知道，一个数的相反数等于其本身的数只有0(注意：~0x80000000 + 1 = 0x80000000)解：123int logicalNeg(int x) &#123; return ((~x+1 | x)&gt;&gt;31)+1;&#125; howManyBits题意：给一个数字x,求出要表示出x需要的最少的位数。思路：个人觉得，本题难度很大。以下的思路可能并不算很好，不过还是可以通过的。 首先，我们知道，对于一个n位的二进制数，能表示的数字的范围为 -2n ~ 2n - 1。故对于输入的整数x，我们可以先将其变成正数，即下方的_mask。现在就只需考虑正数。题目转化为求最高位的1。但最高位的1不是很好求，我们可以将其转化为求二进制下x含有多少个1。 假设当前最高位的1位于第5位，右移并按位或后，第五位，第四位均为1，再向右移两位并且按位或，第二、三、四、五位均为1，以此类推，我们将最高位的1后的所有位全部变成了1。(假设原数为0x0A0BA973，经过处理之后就会变成0x0FFFFFFF)。 接下来考虑如何求出所有位上1的总数。我们可以考虑使用分段的办法。考虑以下的32位二进制数,我们将其分成四个部分： 00000010 | 00100111 | 11010010 | 00110001接下来我们采用掩码分别将其各个部分的1的总数做一个累加，掩码应为： 00000001 | 00000001 | 00000001 | 00000001即对每一个部分，掩码的值都是1。接下来用&amp;运算符获得最低位的数字，四个部分分别为0,1,0,1. 然后，再将x右移一位，再继续进行&amp;运算，以此类推，最后得到四个部分的值分别为：1,4,4,3。即最后得到的sum为： 00000001 | 00000100 | 00000100 | 00000011最后再利用掩码0xff(11111111)，分别得到各个部分的值，做一个累加，得到答案(别忘记+1)。解：12345678910111213141516171819int howManyBits(int x) &#123; int _mask = (x&amp;(1&lt;&lt;31))&gt;&gt;31; x = x^_mask; x |= x&gt;&gt;1; x |= x&gt;&gt;2; x |= x&gt;&gt;4; x |= x&gt;&gt;8; x |= x&gt;&gt;16; int sum = 0, mask = 0x1 | 0x100 | 0x10000 | 0x1000000; sum += x &amp; mask; sum += (x&gt;&gt;1) &amp;mask; sum += (x&gt;&gt;2) &amp;mask; sum += (x&gt;&gt;3) &amp;mask; sum += (x&gt;&gt;4) &amp;mask; sum += (x&gt;&gt;5) &amp;mask; sum += (x&gt;&gt;6) &amp;mask; sum += (x&gt;&gt;7) &amp;mask; return (sum&amp;0xff) + ((sum&gt;&gt;8)&amp;0xff) + ((sum&gt;&gt;16)&amp;0xff) + ((sum&gt;&gt;24)&amp;0xff) + 1;&#125; floatScale2题意：本题给一个无符号数，让你把它看成一个浮点数(都是32位)，让你输出x * 2 的值思路：比较简单，按照浮点数1,8,23的分布将符号，指数，尾数分别取出，并分类讨论即可。解：123456789101112131415unsigned floatScale2(unsigned uf) &#123; unsigned frac = uf&amp;0x007fffff; uf&gt;&gt;=23; unsigned exp = uf&amp;0xff; uf&gt;&gt;=8; if (!exp) &#123; frac &lt;&lt;= 1; int t = frac&gt;&gt;23; if (t) &#123; frac = frac &amp; 0x007fffff; exp++; &#125; &#125; else if (exp != 0xff) exp++; return (uf&lt;&lt;31) + (exp&lt;&lt;23) + frac;&#125; floatFloat2Int题意：给你一个无符号数，并将其看成浮点数(32位)，要求输出(int)x的值思路：本题依然在考察对浮点数的基本理解。解决的思路同上题类似，不再赘述。另外提醒一下，本题有个坑，求得到的bias直接拿来进行右移运算或左移运算会存在问题：&gt;&gt; 和 &lt;&lt; 运算符当偏移量超过32时，会自动进行取模运算，故有可能使得结果出现错误。左移的话有可能还会导致答案溢出。记得分类讨论。解：1234567891011121314151617181920212223242526int floatFloat2Int(unsigned uf) &#123; int frac = uf &amp; 0x007fffff; uf &gt;&gt;= 23; int exp = uf &amp; 0xff; uf &gt;&gt;= 8; int sgn = uf; if (exp == 0xff) return 0x80000000u; else if (!exp) return 0; else &#123; frac |= 0x800000; int bias = exp - 0x7f - 23; if (bias &lt; 0) &#123; bias = -bias; if (bias &gt;= 32) bias = 31; frac &gt;&gt;= bias; &#125; else if (bias &gt; 0) &#123; while(bias) &#123; frac&lt;&lt;=1; bias--; if (frac &lt; 0) return 0x80000000u; &#125; &#125; if (sgn) return -frac; else return frac; &#125;&#125; floatPower2题意：给一个整数x，要求输出2.0x的值。思路：同样，本题依然在考察对浮点数存储的基本理解。要注意的是，+INF的是指exp为0xff，frac为0的值。NaN指的是exp为0xff，frac不为0的值。0的浮点数表示依然为0。解：12345678910unsigned floatPower2(int x) &#123; int sgn = 0, exp = 0, frac = 0; if (x &lt; -126 - 23) return 0; else if (x &lt; -126) frac = 1 &lt;&lt; (149+x); else &#123; exp = x + 127; if (exp &gt; 0xff) return 0x7f800000; &#125; return (exp&lt;&lt;23) + frac;&#125; 结尾 倘若一切顺利，你最终将得到类似这样的一张图片： 那么恭喜你，你的第一个实验————Datalab通关啦！]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>binary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First article]]></title>
    <url>%2F2018%2F12%2F14%2FFirst-article%2F</url>
    <content type="text"><![CDATA[First article 终于基本把博客弄完了 感觉现在充满了成就感O(∩_∩)O。从这星期一开始就想弄了，但是却一直拖着。前两天在学HTML的一些语法，觉得语法真的好多啊，而且有点复杂。然后周三周四就基本都是在看搭博客的一些相关的东西，花了好长时间，一直在踩坑（可能是我比较菜）。买域名，弄github pages什么的。一开始用jekyll的框架来搭建，遇到了无数的问题，最后好在基本解决了，但是又发现踏入了一个新的大坑：找不到好用的模板。然后最后看到了hexo，果断先找模板。在看到了nexT这个主题之后，果断选择入坑。 可能是由于之前jekyll踩的坑有点多，也有可能是hexo比较适合小白。。基本上这个搭建过程中没有出现什么比较大的问题，然后弄完就是各种优化什么的，也算比较顺利吧，到今天早上就基本算是结束了。整体上还是过得去的。（不过貌似手机版看起来的效果比较差？？） 然后在这里就还是来立一个flag吧。以后（至少应该是大学期间吧）这个博客应该是会一直做下去的，尽量每个月至少发一篇博客吧，不过比较忙的时候的话可能没什么办法。基本上大部分博客的内容应该是以硬核为主，不过目前水平不够，也没办法写出比较高质量的东西。内容上可能主要是当前阶段在学习的一些东西，算法，数据结构，或者是自己做的一些小项目，课设什么的也有可能会放进来。目的还是分享吧，如果有什么地方写的不太好，欢迎直接私戳（网页版的话右下角应该是有一个对话框的）。 好吧，憋不出来了。。就这样吧 哦对了，最后放上一张有爱的图片镇楼（p站上找的）。]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
</search>
